Question,Answer,Knowledge Base Context,Generated Answer,BERTScore F1,Cosine Similarity,BLEU Score,METEOR Score,ROUGE-1 F-measure,ROUGE-2 F-measure,ROUGE-L F-measure
"I am trying to send a string via http/post in Racket, this is what I tried so far after reading the Racket HTTP Client Documentation
#lang racket

(require net/http-client)

(define
  myUrl ""https://something.com"")

(http-conn-send!
   (http-conn-open
    myUrl
    #:ssl? #t)
   #:version ""1.1""
   #:method ""POST""
   #:data ""Hello"")

But with this I receive the following error:
tcp-connect: connection failed
  detail: host not found
  address: https://www.w3.org/
  port number: 443
  step: 1
  system error: nodename nor servname provided, or not known; errno=8

I tried it with several different adresses.
I am new to racket and programming in general and unable to figure out what I am missing.
","In your example, the hostname is only the www.w3.org portion -- not including the scheme (http or https) nor any path. So for example this does work:
(http-conn-open ""www.w3.com""
                #:ssl? #t)

To make a post request, you could do this:
#lang racket

(require net/http-client)

(define-values (status headers in)
  (http-sendrecv ""www.w3.com""
                 ""/""
                 #:ssl? #t
                 #:version ""1.1""
                 #:method ""POST""
                 #:data ""Hello""))
(displayln status)
(displayln headers)
(displayln (port->string in))
(close-input-port in)

In Racket, a function can return multiple values. http-sendrecv returns three, and the define-values assigns each one to a variable.
net/http-client provides other functions to let you make a connection to a host, make multiple requests on that connection, then close the connection.
","I am working on a windows account with administrator permissions. The server directory in emacs.d was owned by the group ""Administrators"". I changed the ownership from the user group ""Administrators"" to be owned by the username I am currently working with (which is ""Administrator"") and the error message went away.
This solution is quite similar to the one given in this answer: https://stackoverflow.com/a/2944197/1312456
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

 I am not a smartparens user but I found the answer from its wiki: 
You can bind ) to sp-up-sexp command: 
(define-key smartparens-mode-map "")"" #'sp-up-sexp) 

 I am still clueless with the AppData.ini file, but this question contained the answer I was looking to find in regards to the first question. Simply use (getenv [Input]) with the names below to receive their respective file paths.

(getenv ""APPDATA"") ----------> ""C:\Users\AppData\Roaming""
(getenv ""LOCALAPPDATA"") -----> ""C:\Users\AppData\Local""
(getenv ""ALLUSERSPROFILE"") --> ""C:\ProgramData""

 In your example, the hostname is only the www.w3.org portion -- not including the scheme (http or https) nor any path. So for example this does work:
(http-conn-open ""www.w3.com""
                #:ssl? #t)

To make a post request, you could do this:
#lang racket

(require net/http-client)

(define-values (status headers in)
  (http-sendrecv ""www.w3.com""
                 ""/""
                 #:ssl? #t
                 #:version ""1.1""
                 #:method ""POST""
                 #:data ""Hello""))
(displayln status)
(displayln headers)
(displayln (port->string in))
(close-input-port in)

In Racket, a function can return multiple values. http-sendrecv returns three, and the define-values assigns each one to a variable.
net/http-client provides other functions to let you make a connection to a host, make multiple requests on that connection, then close the connection.
","The error you're encountering is due to using `http-conn-send!` directly without properly handling the connection. Instead of calling `http-conn-send!`, you should use `http-sendrecv` which simplifies the process and handles the connection for you. Here's a corrected version of your code:\n\n```racket\n#lang racket\n(require net/http-client)\n\n(define myUrl \",0.5366,[[0.35816311]],0.029870485201180127,0.12806830293392715,0.2931937172774869,0.07407407407407407,0.14659685863874344
"Is it possible to expand a macro at run time in a compiled lisp executable? I would expect it to be impossible as macro expansion can only happen pre-compilation yet when i call macroexpand in compiled code i get output.
","A macro is a function that's normally called automatically during compilation or evaluation, and whose return value is then compiled or evaluated in place of the original expression.
But since it's just a function, there's nothing preventing it from being called explicitly during run time as well, and that's what MACROEXPAND and MACROEXPAND-1 do.
It's roughly equivalent to:
(defun macroexpand-1 (form &optional env)
  (if (and (listp form) (car form)) ;; list expression
      (let ((macfun (macro-function (car form)))
        (if macfun
            (funcall macfun form env)
            form))
      form))

(Note that this definition doesn't handle symbol macros or use *MACROEXPAND-HOOK*, to keep it simple.)
It's possible to use EVAL-WHEN when defining the macro to make the macro definition only available in the compilation environment. If you do that, trying to expand at run time will fail.
","Macro expansion happens at compile time. Your message indicates that the file that uses the macro was compiled when the macro was not defined, so the compiler assumed that the unknown name my-macro names a function (if you look at the compilation logs, you should see a message to that effect).
Solution: require the file containing macro definitions in files that use them.
 I think the answer to this is macros: if you write a macro which expands to the code you want, then simply place an invocation of the macro at top-level, then the expansion of the macro will end up in the compiled file.
So:
(defmacro foo ()
  (if <compile-time-condition>
      `(setq ...)
      `(setq ...)))

(foo)

Caveat: you can only conditionalise on things you know at compile time: your example of dispatching on UID might not do what you expect.
 Common Lisp provides compiler macros.
These can be used for such optimizations. A compiler macro can conditionally decline to provide an expansion by just returning the form itself. 
 Macros get their arguments passed unevaluated. They may choose to evaluate them. dolist does that for its list argument. It works with an unquoted list passed in for lst in your macro test:
(defmacro test (lst)
  (dolist (x lst)
    (print x)))

That's because at macro-expansion time the dolist sees lst as its argument. So when it evaluates it, it gets the list (1 2 3).
 Recursive macro-expansion works by repeatedly expanding the form until there is no macro to expand. That means that if you want to recursively expand a macro, but ignore certain forms, you'll have to either code your own custom expander, or find someone else's.
Here's a quick example:
(defn my-expander [form]
    (cond (not (list? form)) (mexpand-1 form)
        (= (first form) 'let) form
           :else (map my-expander (mexpand-1 form))))

Please forgive me if I made any mistakes. I'm much stronger with Scheme and CL than Clojure.
--Edit--
Note that the above function will not expand the subforms of a let statement, either.
 Use the macro CHECK-TYPE:
CL-USER 9 > (let ((n ""10""))
              (check-type n integer))

Error: The value ""10"" of N is not of type INTEGER.

","In Common Lisp, macros are expanded at compile time. Once a file is compiled and the resulting executable is run, the original macro forms are not re-expanded unless the code inside the macro is dynamically evaluated during runtime. The `macroexpand` function can still be used in compiled code to inspect the expansion of a macro form, but this does not cause the macro to be expanded again at runtime. If you need behavior that changes based on conditions known only at runtime, you should use functions rather than macros and evaluate those forms dynamically.",0.5285,[[0.33853495]],0.09523993428299832,0.20601336302895323,0.3865546218487395,0.06779661016949154,0.1680672268907563
"I am trying to create a command that will indent a selected region by 4 spaces.
The appropriate commands are: C-u 4 C-x <TAB>, when C-u is a shortcut for ""universal-argument"" command and C-x <TAB> is a shortcut for indent-rigidly, so I've written this function:
(defun my-tab ()
  (interactive)
  (universal-argument 4)
  (indent-rigidly))

But when I'm trying to run the function (with M-x my-tab) I get this error:

Wrong number of arguments: (0 . 0), 1

What is the problem?
Thanks!
","If you look at the documentation for indent-rigidly (C-h f indent-rigidly), you'll notice that it takes 3-4 arguments:
(indent-rigidly START END ARG &optional INTERACTIVE)

So, you should supply the start and end positions to it as well. You should also just give the ARG normally, instead of using universal-argument.
(defun my-tab (start end)
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 ;; Operate on the current line if region is not to be used.
                 (list (line-beginning-position) (line-end-position))))
  (indent-rigidly start end 4))

","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Found your bug. Most of your functions are declared to receive the expression as the first argument and the bindings as the second one, yet on your example you are calling the function passing the bindings as the first argument and the expression as the second. You must either call (evalexp p1 '((x 2) (z 8))) or swap the argument order on your function definitions (I'd suggest this solution, as it seems more natural and looks like the assignment @rainer-joswig linked).
Particularly, subst-bindings and evalexp are the ones which need the change.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","The issue with your function definition lies in the order of the arguments passed to `universal-argument`. The `universal-argument` command is designed to take an optional numeric argument. When you use `(universal-argument 4)`, it's not being passed correctly as an argument to `indent-rigidly`. Instead, you should pass the numeric argument directly to `indent-rigidly`. Here's how you can modify your function:",0.5273,[[0.30153317]],0.05726854882331642,0.2040253545769187,0.34782608695652173,0.06289308176100629,0.16149068322981366
"More specifically, I need any instance of | to be transformed into \|. I tried reading the documentation on reader macros and I am extremely lost. Can somebody explain this in understandable terms, or ideally show me how to write such a macro. 
","You're essentially destroying the usual meaning of | in the usual syntax, so you should really do that in some uniform way to minimize surprises.  Your solution doesn't do that -- it treats | differently based on whether it's the first thing or not, and that's bad.  For example, xxx|xxx reads it as a character in the whole symbol which means that you get a symbol with a name of ""xxx|xxx"", but with an input of |xxx you get two symbols, with names of ""|"" and ""xxx"" respectively.  It's therefore better to just make your syntax treat | as other characters to get a more consistent and easier-to-explain behavior.
Another possible problem with your code is your use of #f as a readtable, which means that the reader is not going to compose with a reader that is potentially modified.
And finally, you should really pay attention to the extra arguments and return a syntax object when they're given.  The reason for that is obvious, and my guess is that your reason for not doing so is that you're interested in just reading such code.  But you should really have one eye looking at potential extensions, and in Racket, and obvious future for such code would be to make up a proper language instead of a read+eval hack.  It's true that it might seem like an overkill, but in this case there is a simple solution of using the ""same as this other character"" shortcut to avoid writing lengthy code.
The following addresses all of these:
(define rt (let ([c (current-readtable)]) (make-readtable c #\| #\a c)))

","Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

 It is the form (customize-option 'my-variable) which is not a command. You cannot bind to an arbitrary quoted form, any more than you can bind to a literal string or an unbound symbol. Some of those would be useful to bind to, but it's not hard to work around the limitations. Write a macro if you find it hard to live with. (As the saying goes, now you have two problems.)
","To transform instances of | into \| using a Lisp reader macro, you need to define a new syntax that gets evaluated at read-time before normal evaluation. Here's an example of how to do this in Common Lisp:\n\n1. Define the syntax: Use the #.(defreadermacro) or simply (set-macro-character) function to associate your desired character with a reader macro.\n2. Implement the transformation logic inside the macro.\n3. Register it as a new syntax using set-dispatch-macro-character if needed.\n\nHere's a simple example of how you can define such a reader macro:\n\n```lisp\n(set-macro-character #\\| (lambda (stream char)\n                           (declare (ignore char))\n                           '|)))\n```\n\nThis sets the | character as a special syntax, which when read will be transformed into \|.\n\nNote that you can also use set-dispatch-macro-character if you want to handle different delimiters differently based on their preceding characters.",0.5342,[[0.30711969]],0.1329898860657232,0.25006964757893935,0.289044289044289,0.0468384074941452,0.13053613053613056
"I'm trying to write a function that adds an element to each element of a given powerset. No matter what it always evaluates (null pset) as true. I can't understand why. 
Here's what I have so far:
(defun addxtopowerset(x pset)
     (cond
        ((null pset) (list x '())) ; If the powerset is null, display x and NIL.
        ;;First display a list combining x and the first item of pset. Then display the first item of pset itself. Then recursively call the function passing the rest of pset as a parameter.
        (T (list 'x (car pset))(list (car pset))
        (addxtopowersetch x (cdr pset))))) 

","First, note that in the terminal case you should return an empty list, since is in the recursion that all the elements of the powerset are processed, and we should assume that a powerset is always a list of list, each of them representing a set (in fact, the powerset of an empty set contains at least one element, the empty set itself).
So, since a powerset is a non-empty list, the task of adding a new element to the powerset can be solved by adding to the result, for each list of the powerset, both the list and a copy of the list with the element added.
In both cases, “add” means: get something and return a new-something, and use the value returned, otherwise, as Rainer Joswig note, “the result go straight into the digital nirvana”. In other words, in the recursive case your function must add the two values, the list and the new list with the element added, to the result of the recursive call. So, here is the function:
(defun addxtopowerset(x pset)
   (if (null pset)
       nil
       (append (list (car pset) (cons x (car pset))) 
               (addxtopowerset x (cdr pset)))))

Finally, here a couple of alternative ways of defining the function, the first one with the high order function mapcan:
(defun addxtopowerset(x pset)
  (mapcan (lambda(y) (list y (cons x y))) pset))

and the second one with a loop:
(defun addxtopowerset(x pset)
  (loop for y in pset append (list y (cons x y))))

","Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Use ext:cd
To display:
[1]> (ext:cd)
#P""/Users/pu/""

To change, add a path name or a string:
[3]> (ext:cd #P""/"")
#P""/""
[3]> (ext:cd)
#P""/""

[3]> (ext:cd ""/Users"")
#P""/Users/""
[3]> (ext:cd)
#P""/Users/""

","The issue with your function is that you are trying to use symbols like 'x' and '(car pset)' directly within the list constructions without properly evaluating them. Additionally, your recursive call structure is incorrect. Here's a corrected version of the function:\n\n```lisp\n(defun addxtopowerset (x pset)\n  (if (null pset)\n      (list x '())\n      (append (list (cons x (car pset)))\n              (addxtopowerset x (cdr pset)))))\n```\nThis function correctly processes each element of the powerset, adding `x` to each one and recursively calling itself with the rest of the list. Note that this version uses `append` for concatenating lists, which is necessary because `(cons x (car pset))` creates a new list.\n\nIf performance is critical and you are dealing with very large lists, consider using an accumulator approach to build the result list in reverse order and then use `nreverse` at the end.",0.6477,[[0.69384994]],0.23172676408951998,0.284500760577919,0.4522613065326633,0.14646464646464646,0.21608040201005022
"I want to paste between every element of a lista special element. In example:
(EINFUEGEN '(A B C) '*);-> (A * B * C)

How can I implement that on the easiest way?
","The fun way:
(cdr (mapcan #'list '#1=(* . #1#) '(a b c)))

The respectable way:
(loop
   for (x . xs) on '(a b c) 
   collect x
   when xs collect '*)


for <var> on <list> iterates over all sublists, meaning var will be bound to (a b c), then (b c) then (c) and finally ().
(x . xs) is a destructuring notation to bind respectively x and xs to the head and tail of each list being visited. This is necessary here to check whether there are remaining elements.
collect <val> adds <val> to implicit collection being built
when <test> <clause> executes the LOOP clause <clause> only when <test> is satisfied. Here, I test if there are more elements in the list; when it is the case, I also collect the star symbol.

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
","You can achieve this by using the `loop` macro or a combination of `cons` and `append`. Here's an example using `loop`: \n\n```\nlisp\n(defun einfuegen (list special-element)\n  (loop for element in list\n        collect element\n        when (not (last list))\n        collect special-element))\n\n(einfuegen '(A B C) '*);-> (A * B * C)\n```\nAlternatively, you can use `cons` and `append`: \n\n```\nlisp\n(defun einfuegen (list special-element)\n  (if list\n      (let ((rest (einfuegen (cdr list) special-element)))\n        (append (list (car list)) (list special-element) rest))\n      nil))\n\n(einfuegen '(A B C) '*);-> (A * B * C)\n```\nBoth methods will insert the `special-element` between every element of the given list.",0.541,[[0.20464002]],0.09551394438629147,0.32230027397599287,0.2891566265060241,0.08097165991902834,0.1606425702811245
"Could someone explain to me what's going on in this very simple code snippet?
(defun test-a ()
  (let ((x '(nil)))
    (setcar x (cons 1 (car x)))
    x))

Upon a calling (test-a) for the first time, I get the expected result: ((1)).
But to my surprise, calling it once more, I get ((1 1)), ((1 1 1)) and so on.
Why is this happening? Am I wrong to expect (test-a) to always return ((1))?
Also note that after re-evaluating the definition of test-a, the return result resets.
Also consider that this function works as I expect:
(defun test-b ()
  (let ((x '(nil)))
    (setq x (cons (cons 1 (car x)) 
                  (cdr x)))))

(test-b) always returns ((1)).
Why aren't test-a and test-b equivalent?
","The Bad
test-a is self-modifying code. This is extremely dangerous. While the variable x disappears at the end of the let form, its initial value persists in the function object, and that is the value you are modifying. Remember that in Lisp a function is a first class object, which can be passed around (just like a number or a list), and, sometimes, modified. This is exactly what you are doing here: the initial value for x is a part of the function object and you are modifying it.
Let us actually see what is happening:
(symbol-function 'test-a)
=> (lambda nil (let ((x (quote (nil)))) (setcar x (cons 1 (car x))) x))
(test-a)
=> ((1))
(symbol-function 'test-a)
=> (lambda nil (let ((x (quote ((1))))) (setcar x (cons 1 (car x))) x))
(test-a)
=> ((1 1))
(symbol-function 'test-a)
=> (lambda nil (let ((x (quote ((1 1))))) (setcar x (cons 1 (car x))) x))
(test-a)
=> ((1 1 1))
(symbol-function 'test-a)
=> (lambda nil (let ((x (quote ((1 1 1))))) (setcar x (cons 1 (car x))) x))

The Good
test-b returns a fresh cons cell and thus is safe. The initial value of x is never modified. The difference between (setcar x ...) and (setq x ...) is that the former modifies the object already stored in the variable x while the latter stores a new object in x. The difference is similar to x.setField(42) vs. x = new MyObject(42) in C++.
The Bottom Line
In general, it is best to treat quoted data like '(1) as constants - do not modify them:

quote returns the argument, without evaluating it.  (quote x) yields x.
  Warning: quote does not construct its return value, but just returns
  the value that was pre-constructed by the Lisp reader (see info node
  Printed Representation). This means that (a . b) is not
  identical to (cons 'a 'b): the former does not cons.  Quoting should
  be reserved for constants that will never be modified by side-effects,
  unless you like self-modifying code. See the common pitfall in info
  node Rearrangement for an example of unexpected results when
  a quoted object is modified.

If you need to modify a list, create it with list or cons or copy-list instead of quote.
See more examples.
PS. This has been duplicated on Emacs.
PPS. See also Why does this function return a different value every time? for an identical Common Lisp issue.
","The question is very subtle, and in the first moment I thought that the call would cause an infinte loop. But the real affair is the following:
Let's start calling F1 and F2 the two functions passed to A the first time, that is
F1 = (lambda() 1)
F2 = (lambda() -1)

So, after the first call of (A 2 F1 F2), A establishes the following environment, that we will name E1:

The test is now false, so A calls B1. B1 first decrements k in E1, then calls again A, passing 1, itself, and x1, which is F1. So this is the call with parameters substituted with their values: (A 1 B1 F1). And the new environment established by this call (E2) is shown in the following picture:

The test is still false, so A calls B2, which first modifies k in E2, then calls A with 0, itself, and x1 (which now is B1). So the call is (A 0 B2 B1), and the new set of environments is now:

The test is now true, so A call x2, which is B1. Now B1 modifies k in its environment (which is E1), and then calls A with 0, itself, and the value of x1, which, in E1, is F1. So the call is (A 0 B1 F1) and the environment established by this call is depicted in the next figure:

And finally, after checking that the test is true, A calls x2, that is F1, which returns 1. At last! 
 According to the R6RS specification:

If <test> yields #f and no <alternate>
  is specified, then the result of the
  expression is unspecified.

So go wild, return anything you want! Although #f or '() are what I, personally, would expect. 
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 The alternate expression for the 'if' expression is ((set! ...) ...).  The first position needs to be either a function or a syntactic form.  In this case you need progn as:
(progn
  (setq list1 ...)
  (setq list2 ...)
  (eql x y))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
","The issue with `test-a` lies in how it modifies the list in place. In Lisp, when you use `setcar`, it directly alters the list structure. In your first call to `(test-a)`, `x` is initialized as `'(nil)`. When you do `(setcar x (cons 1 (car x)))`, it changes the first element of `x` to a new cons cell `(1 . nil)`. However, because `x` still points to this list, subsequent calls continue to modify the same list. To fix this and make `test-a` behave as expected, you should redefine `x` inside the function to ensure each call works independently. This is why `test-b` behaves differently—it reassigns `x` on each call, creating a new list instead of modifying the existing one.",0.5645,[[0.498789]],0.027577715986083332,0.12444260085035777,0.30451127819548873,0.0792452830188679,0.15037593984962405
"In a let form (Clojure here) I can doing something like
(let [[u s v] (svd A)] 
   (do-something-with u v))

where svd returns a list of length three. This is a very natural sort of thing to do, so why isn't that we don't we have
(def [u s v] (svd A))

and its various generalizations as the default behavior of the def form? I don't see how this would interfere with anything that def is already doing. Can someone who understands the Zen of Lisp or Clojure explain why def does not support binding (with destructuring) as powerful as let?
","def is a special form at the compiler level: it makes a Var. def has to be available and usable before destructuring is available. You see something similar with let*, a compiler primitive that supports no destructuring: then after several thousand lines in clojure/core.clj the language is finally powerful enough to provide a version of let with destructuring, as a macro on top of let*. 
If you want, you can write a macro (say, def+) that does this for you. Personally I think it's kinda gross and wouldn't use it, but using a Lisp means getting to use a language that suits you personally.
","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 It is bad style to setq an unknown name.  It is assumed that you mean to create a new global special variable, then set it, but this should be made explicit by introducing these bindings first.  You do this at the top level by using defvar (or defparameter or defconstant) instead, and in lexical blocks by using let, do, multiple-value-bind or similar constructs.
 Though not too clear in the documentation for flet, its macroexpansion reveals that it tolerates sequential binding:
(defun add2 (x)
  (flet ((add1 (x) (1+ x))
         (add1twice (x)
           (add1 (add1 x))))
    (add1twice x)))

The documentation mentions establishing ""let-style bindings""—not let*—but the definition above works nonetheless.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","In Common Lisp, `def` is a special form used for defining functions and variables. It does not support binding with destructuring like `let` because `def` serves a different purpose—it's meant to define a global variable or function that can be accessed throughout the program. On the other hand, `let` is designed specifically for local binding and scope management within a particular lexical context. The ability to destructively bind variables as in `let` is not part of the `def` form's semantics. If you want to define multiple values from a function call with destructuring, you can use `let` or equivalent constructs. For example: `(let [[u s v] (svd A)] (do-something-with u v))`. This approach leverages Common Lisp's powerful macro system and lets you achieve the desired behavior in a way that is consistent with the language's design philosophy.",0.5539,[[0.48285605]],0.18217608819363026,0.3784626270844341,0.4444444444444444,0.08,0.20634920634920634
"I've been attempting to write a Lisp macro that would perfom the equivalent of ++ in other programming languages for semantic reasons.  I've attempted to do this in several different ways, but none of them seem to work, and all are accepted by the interpreter, so I don't know if I have the correct syntax or not.  My idea of how this would be defined would be
(defmacro ++ (variable)
  (incf variable))

but this gives me a SIMPLE-TYPE-ERROR when trying to use it.  What would make it work?
","Remember that a macro returns an expression to be evaluated. In order to do this, you have to backquote:
(defmacro ++ (variable)
   `(incf ,variable))

","Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 Portably, no.  Implementations are free to return whatever kind of string they deem sensible.
I'd use a simple wrapper function and maybe declaim it inline:
(declaim (inline read-simple-line))
(defun read-simple-line (stream)
  (some-> (read-line stream nil)
          (coerce 'simple-base-string)))

(Some-> is from arrows).
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","Your macro definition for `++` looks almost correct. However, in Common Lisp, there is no operator `++`. Instead, you can use the `incf` function to increment a variable's value. The issue with your code might be due to the fact that `variable` is not being used correctly within the macro. Here's how you can define it:

```lisp
(defmacro ++ (variable)
  `(incf ,variable))
```

This macro uses backquote and comma to splice the variable into the form, which is evaluated at macro expansion time.",0.6556,[[0.34975134]],0.16147302770904778,0.4355594377828952,0.3076923076923077,0.0588235294117647,0.17307692307692307
"I understand how quotes are represented in language:
(equal ''(1 2) (list 'quote (list 1 2))) ;; => T

but what about quasi-quotes? is it something like:
(equal ``(1 2) (list '<???> (list 1 2)))

Both quasiquote and backquote instead of <???> don't work.
","There is no standard representation in Common Lisp.  What backquote should do is specified, but there is no equivalent to quote.  In particular the spec says in 2.4.6, after giving the specification of how backquote should behave:

An implementation is free to interpret a backquoted form F1 as any form F2 that, when evaluated, will produce a result that is the same under equal as the result implied by the above definition, provided that the side-effect behavior of the substitute form F2 is also consistent with the description given above.

Note that this is not in fact a problem since backquote is a thing you can implement yourself, while quote needs to be in the guts of the language.
","An example where the difference matters:
* (defun foo () `(,(get-internal-real-time)))
FOO
* (defun bar () '(#.(get-internal-real-time)))
BAR
* (foo)
(44577)
* (foo)
(47651)
* (bar)
(41929)
* (bar)
(41929)

As you can see, when you're not using the value directly (as in the (setq var1 ...) case), the quasi-quote is expanded each time, returning different values. However, with the read-time eval, it's only called once, returning the same value again and again.
 Quasiquoting is the way to selectively allow dereferenced values into your quoted form.
(let ((x 10) (y 20))
   `((x . ,x)
     (y . ,y)))

=> ((X . 10) (Y . 20))

So you use a backtick to start a quasiquote and you use comma before the form that you want to have evaluated before it enters to the quoted form.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Quoting in lisp prevents evaluation of the s-exp and passes it around as a function.
Therefore, you're comparing the non-evaluated function '(reverse (a b)) to the list '(a b)
If you changed the code to 
(equal (reverse '(a b)) '(b a))

(reverse '(a b)) would yield '(b a), and thus the equal comparison would return true.
 The quote operator (for which the apostrophe is syntactic sugar) means that its arguments are not evaluated, i.e. (quote (str1 str2)) returns a list of two symbols.  Use list instead: (list str1 str2).
 ' is not equivalent to list, it's shorthand for quote. You're really doing this:
(setq stuff (quote (one two three (+ 2 2))))

The argument to quote is the expression (one two three (+ 2 2)).
From http://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html: ""The special form quote returns its single argument, as written, without evaluating it"".
","Quasi-quotation in Lisp is represented by the backtick (`) character. It allows for selective unquoting with a comma (,), which causes the expression following it to be evaluated before being included in the final list or form. So, you would not use `<????>` as shown. Instead, you would write something like this:\n\n```\n(equal `(1 2) (list 1 2))\n```\n\nFor your example with quasi-quotation and backquote, it should look like this:\n\n```\n(equal ``((x . ,x) (y . ,y)) (list '((x . ,x) (y . ,y))))\n```\n\nThis correctly demonstrates the use of quasi-quotation to evaluate `x` and `y` before including them in the list.",0.4743,[[0.32292239]],0.10745648660988669,0.27601354729205224,0.23478260869565215,0.02631578947368421,0.13043478260869568
"I am beginner in Lisp. There is a question that I cannot solve.
Show the simplest expression that Lisp will print out when you type the following
expression:
’(a b (c . e) (d . nil))

I tried (cons 'a (cons 'b (cons (cons 'c 'e) (cons (cons 'd nil)))))
However, it wouldn't create (d . nil).
So, is there any way to create such a dot pair?
","
Show the simplest expression that Lisp will print out when you type the following expression

The question does not ask you to create a dotted pair, but how the dotted pair is printed. I suppose this question aims at showing you that lists are just dotted pairs printed in a special way.
If you write this in a REPL:
'(a b (c . e) (d . nil))

The REPL replies:
(A B (C . E) (D))

You have the exact same output if you write:
'(a . (b . ((c . e) . ((d . nil) . nil))))

Basically, (a b) is the list made of a symbol a in front of a sublist (b), written (a . (b)). Here I am only talking about how forms are read. If you write them directly in the REPL, they will first be read, then evaluated, and in that case you will get an error. That's why in the examples are quoted: an expression being quoted is not evaluated, but returned as-is.
If you want to write code that, when evaluated, produces the cons-cell (0 . 1), you have to write this list:
(cons 0 1)

The above is a list of three elements, which could be written equally:
(cons . (0 . (1 . nil)))

Your interpreter will read this list (a symbol, two numbers) and evaluate the resulting form. That forms produces, at runtime, the following cons cell:
(0 . 1)

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 When the reader encounters a syntax-quoted form, that turns out to be a collection, it will iterate over each element and call syntax-quote recursively. The result is consed, beginning with nil.
So it comes down to the question why the following holds:
> (list? (cons 'inc nil))
true
> (list? (cons 'inc (cons 1 nil)))
false

This seems to be a matter of definition.
 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 What you are seeing is the output being concatenated for brevity. The actual list is correct and not affected, but because it would be too long to print to the output, the lisp REPL shortens it when printing and uses # to indicate that it has done so.
","In Lisp, you can create dotted pairs using the cons function directly. For example, to create (d . nil), you should use (cons 'd nil). The simplest expression that will print out (a b (c . e) (d . nil)) is by nesting these dotted pairs appropriately. Here's how you can do it:\n\n(cons 'a (cons 'b (cons (cons 'c 'e) (cons (cons 'd nil)))))",0.611,[[0.39966124]],0.04346980396286849,0.1445036165172126,0.29931972789115646,0.11643835616438354,0.16326530612244897
"I am working on a homework assignment, and the first functions had me doing things like deleting a given element of a list, or displaying a given element of a list.  The next functions want me to delete nested lists, or display them.  Do you have any general tips for working with nested lists? I imagine the functions will be very similar to the ones I wrote before, just tweaked a bit. 
Here are two example of functions I have written so far. Note I must use the ""cond"" style of writing functions. 
(defun delnth(L A)
  (cond ((= A 1) (rest L))
        (t (cons (first L) (delnth (rest L) (- A 1))))))


(defun remv(A L)
  (cond ((eq A (first L)) (remv A (rest L)))
        ((null L) nil)
        (t (cons (first L) (remv A (rest L) )))))

","Both of your functions work with nested cons. '(1 2 3) is (1 . (2 . (3 . ())) and (cons 1 (cons 2 (cons 3 '()))). A nested list would be that you also have nested cons in the car of cons. eg. ((1 . ()) . ()) ; ==> ((1)). 
It's important to be able to see ((1) (2 3)) and understand that it is ((1 . ()) . ((2 . (3 . ())) . ())) so that if you want to access 3 it's obviously the path d,a,d,a and in the reverse you can construct the accessor cadadr. 
cons with cons in the car part are trees. When you make a function that walks the tree you need to walk both the car and the cdr in the event they are cons. Thus:
;; generic function to walk trees and reduce
;; by combiner every value accessed by term 
;; the default argument to combiner is tree-null
(defun accumulate-tree (tree term combiner null-value)
  (labels ((rec (tree)
             (cond ((null tree) null-value)
                   ((atom tree) (funcall term tree))
                   (t (funcall combiner (rec (car tree)) 
                                        (rec (cdr tree)))))))
    (rec tree)))

(defun sum-numbers (tree)
  (accumulate-tree tree
                   #'identity
                   #'+
                   0))

(defun count-numbers (tree)
  (accumulate-tree tree
                   (lambda (v) (if (numberp v) 1 0)) 
                   #'+
                   0))

(sum-numbers '((1) (2 3) (((4)) 5)))   ; ==> 15
(count-numbers '(a b 4 3 (e f 5) . 9)) ; ==> 4

The combiner doesn't need to reduce to an atom:
(defun reverse-tree (tree)
  (accumulate-tree tree
                   #'identity
                   (lambda (a d) (cons d a))
                   '()))
(reverse-tree '((1 2) (3 4))) 
; ==> ((nil (nil . 4) . 3) (nil . 2) . 1)

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You're overcomplicating it. You don't need to sort the CDRs of the sub-lists returned by SPLIT-LIST, just sort the whole lists, and merge them.
(defun MSORT (L)
  (cond ((endp L) nil)
        ((endp (cdr L)) L)
        (t
         (let* ((S (SPLIT-LIST L ))
                (L1 (car S))
                (L2 (cadr S))
                (X (MSORT L1))
                (Y (MSORT L2)))
           (MERGE-LISTS X Y)))))

","When working with nested lists, it's important to keep track of both car and cdr operations. For your homework, you might need to traverse through nested structures using recursion. Here are some general tips:\n\n1. **Flatten Nested Lists**: If needed, convert the nested list into a flat one before processing.\n2. **Recursion**: Use recursive functions to handle each level of nesting. You can use `car` and `cdr` to access elements and sublists.\n3. **Conditionals**: Use `cond` or `if` statements to manage different cases, such as handling empty lists or reaching the end of a sublist.\n\nFor your specific functions:\n- To delete a nested list by index: You need to traverse the nested structure and handle each level accordingly.\n- To display elements of nested lists: Use recursion to print each element, including those in sublists.\n\nHere's an example function that deletes a given sublist from a nested list:\n```lisp\n(defun del-nested (lst index)\n  (cond ((null lst) nil)\n        ((listp (car lst))\n         (cons (del-nested (car lst) index) (del-nested (cdr lst) index)))\n        (t (if (= index 0) (cdr lst) (cons (car lst) (del-nested (cdr lst) (- index 1)))))))\n```\nThis function recursively traverses the nested list and handles each level to delete or keep elements as required.\n\nRemember, for displaying elements of a nested list, you can use similar recursive techniques:\n```lisp\n(defun print-nested-elements (lst)\n  (cond ((null lst) nil)\n        ((listp (car lst))\n         (print-nested-elements (car lst))\n         (print-nested-elements (cdr lst)))\n        (t (print (car lst))\n           (print-nested-elements (cdr lst)))))\n```\nThis will print all elements, including those in sublists.\n",0.6182,[[0.20291928]],0.19091302471448665,0.31293640570369924,0.2851851851851852,0.05947955390334573,0.137037037037037
"i try to describe this problem well with my humble English skills :
i have closed blocks on my dwg file, these blocks are consist of many Polylines which are joined together but they are not uni-body (integrated), all i want is a lisp to draw a polygon over this block and create a uni-body block. is there any way around ? 
thnx
","Assuming that:

when you say ""joined"" you mean their ends are touching, 
when you say ""uni-body"" you actually mean ""joined"" in the AutoCAD sense, 

then try the following:
(defun convert_block_to_polyline (block / old_entlast new_entlast curr polylines_set)
  (setq old_entlast (entlast))
  (command ""explode"" block)
  (setq new_entlast (entlast))
  (setq
    curr (entnext old_entlast)
    polylines_set (ssadd)
    )
  (while (entnext curr)
    (ssadd curr polylines_set)
    (setq curr (entnext curr))
    )
  (command ""join"" (entlast) polylines_set """")
  (princ)
)

This function assumes:

You don't want to retain the original block, if you do then its a simple question of creating a copy before you explode it, and pasting it in the same place afterwards.
The block is made solely of objects which can be included in the join command (lines, polylines etc..)

","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 IMO, it would have been better if the text had said simply:
Conses can also be considered as binary trees, with the car representing one subtree and the cdr representing the other subtree.
Which is chosen for left and which for right is arbitrary. (Of course, consistency etc.) Perhaps the text had already introduced a concrete representation? Or perhaps it did so later, and needed to refer to which was which? If not -- if that statement was all there was, then I think there is no reason to choose sides.
 Why would you do that? What you ask is to split a string (a one-dimensional array of characters) into a list of symbols. Do you really want that?
#\h is a character object printed.
You can print them differently:
CL-USER 8 > (princ #\h)
h

CL-USER 9 > (prin1 #\h)
#\h

Let's print the list using PRINC:
CL-USER 10 > (map nil #'princ (coerce ""Hello!"" 'list))
Hello!

Btw., since strings, vectors and lists are sequences, you can MAP directly over the string...
CL-USER 11 > (map nil #'princ ""Hello!"")
Hello!

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

","Your request seems more related to AutoCAD Lisp rather than Common Lisp. However, I can provide you with a general approach using AutoLISP to achieve your goal of creating a uni-body block from polylines.

1. First, you need to define the vertices of the polygon that will enclose the polylines.
2. Use these vertices to create a new polyline or region.
3. Use the `BLOCK` command to create a new block with the enclosed geometry.

Here is an example of how you might write such a Lisp function in AutoLISP:

```lisp
(defun C:MAKE_UNIBODY_BLOCK (/ pt1 pt2 pts poly)
  (setq pts (mapcar 'polar '(0.0 90.0 180.0 270.0) 50)) ; Define your polygon vertices
  (setq poly (list (cons 0 ",0.566,[[0.25831897]],0.12757554629322232,0.2731229432068202,0.28235294117647053,0.03162055335968379,0.14117647058823526
"In the reddit interview with Peter Norvig, he says  

“For various reasons the set of web
  libraries and protocols were slower to
  develop in LISP than   in other
  languages”

and consequently lisp adoption among the web community went down, and people went after languages with richer library sets.  
Is there a reason for this slowness in the building up the web frameworks by the LISP community? 
","Mr. Norvig's remark seemed to me to be more historical than an assessment of the current situation. Perhaps in the mid to late 90s web related libraries didn't appear as quickly in Common Lisp as they did in other languages like Java.   
But certainly today that is not the case. I can name no less than five Common Lisp web servers off the top of my head (CL-HTTP, Hunchentoot, S-HTTP-Server, Araneida, AllegroServe), not to mention mod-lisp for Apache.  There must be nearly a dozen different web frameworks (KPAX, Weblocks, UncommonWeb, et al). And there are common lisp libraries for every web acronym you can name: SOAP, XML, XLST, FTP, XML-RPC, S3, AJAX.... ad infinitum.  And there are tools that have no analog in other languages, like the wonder of wonders ParenScript. 
See the Common Lisp Directory for a fat list of web libraries: http://www.cl-user.net , many of which are maintained at http://www.common-lisp.net 
","Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Another simple way is to have Lisp running a HTTP server and contact Lisp from the outside via HTTP requests.
 There is an ASDF library called shut-it-down that provides a quit function that works by just having cases for the common CL implementations.
 The reason of this warning is a GNU policy which does not want a package cl to be used in Elisp. But it would be foolish as well to prohibit it completely. So they decided to show a warning.
You can find more information here
 Elisp uses dynamic scoping, which means that variable names really matter.  More specifically, in your case you have a naming conflict between your hist and the hist variable used by ido.  Always use a <prefix>- thingy on global variables to avoid such problems.
","The relative slowness in developing web libraries and frameworks in Lisp can be attributed to several factors. First, the Lisp community has traditionally focused more on language purity, theoretical elegance, and system-level programming rather than web development. This shift in focus meant that resources and efforts were not as concentrated on building extensive web frameworks compared to other languages like Python or Ruby.

Second, while Common Lisp (and its dialects) provide powerful tools for metaprogramming and code generation, the initial complexity of these tools could be a barrier for developers new to the language. This complexity can slow down the development process, especially when creating high-level abstractions like web frameworks.

Additionally, historical context plays a role. When web technologies were developing rapidly in the late 1990s and early 2000s, other languages with more direct web support, such as Perl, PHP, Python, and Ruby, had already established themselves. These languages offered easier entry points for beginners and more immediate practical benefits.

Finally, the modular and extensible nature of Lisp can sometimes make it harder to build a cohesive set of libraries that work well together out-of-the-box compared to monolithic frameworks in other languages.",0.5381,[[0.4440735]],0.1709749288797827,0.33192834562697576,0.31955922865013775,0.04986149584487535,0.15977961432506887
"If I know the position of an element in a list in clisp, then how could I retrieve the element knowing its position. Is there any predefined function for it?
","For lists only there is NTH:
CL-USER> (nth 2 '(1 2 3 4 5)) 
3

For SEQUENCES (vectors, strings, lists ...)  there is ELT:
CL-USER> (elt '(1 2 3 4 5) 2) 
3

If you really need a lot to access element by index, I'll advice you to consider using vectors  (and access elements by aref) instead of lists, especially if you have logn sequences, because accessing element by index in lists may need to travel along all list to your element. 
Of course, if you have small amount of data, you wan't feel any difference, but it looks good to use things right for me.
","See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 Generally return a list of depths. So, if an item is found, then return the list of the single depth. If you branch to the first and rest of the list, then don't 'cons', but 'append'.
Note also that your code does not find all depths.
CL-USER 6 > (search-node '(6 (6)) 6)
0

 From OnLisp:
(defun flatten (tree)
  (if (atom tree)
      (mklist tree)
    (nconc (flatten (car tree))
       (if (cdr tree) (flatten (cdr tree))))))

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

","In CLISP (and Common Lisp in general), there is no predefined function that directly retrieves an element from a list by its position. However, you can achieve this using the `nth` function or by defining your own function. The `nth` function returns the nth element of a list, where the first element has index 0. For example, `(nth 3 '(a b c d e))` would return `d`. If you need to retrieve an element by its position and ensure that the position is valid (i.e., within the bounds of the list), you can use error handling or conditional checks.",0.533,[[0.2702493]],0.15864191562664837,0.2972651605231867,0.31578947368421056,0.048309178743961345,0.1626794258373206
"Is the values function in Common Lisp just syntactic sugar for packaging multiple values into a list that gets destructured by the caller?. I am asking because I thought Common Lisp supports ""true"" multiple value return rather than returning a tuple or a list as in other languages, such as python. Someone just told me that it's just syntactic sugar, so I would like someone to kindly explain it. To try to understand the type that is returned by the values function, I typed (type-of (values 1 2 3)), and the output was BIT. I searched in the Common Lisp reference for that and I couldn't find it mentioned in the datatypes section. Also, can anyone share some resources that suggest how the values function is implemented in Common Lisp?. Thank you.
","Multiple Values in CL
The language Common lisp
is described in the ANSI standard INCITS 226-1994 (R2004) and has many
implementations.
Each can implement multiple values
as it sees fit, and they are allowed, of course, to cons up a list for them
(in fact, the Emacs Lisp compatibility layer for CL does just
that -
but it is, emphatically and intentionally, not a Common Lisp implementation).
Purpose
However, the intent of this facility is to enable passing (at least
some) multiple values without consing (i.e., without allocating
heap memory) and all CL
implementations I know of do that.
In this sense the multiple values facility is an optimization.
Of course, the implementation of this feature can be very different for
different platforms and scenarios. E.g., the first few (say, 20 -
required by the standard) are
stored in a static of thread-local vector, the next several (1000?) are
allocated on the stack, and the rest (if needed) are allocated on the
heap as a vector or list.
Usage
E.g., the function floor returns two values.
If you write
(setq a (floor 10 3))

you capture only the first one and discard the second one, you need to
write
(setf (values q r) (floor 10 3))

to capture both values.  This is similar to what other
languages might express as
q,r = floor(10,3)

using tuples, except that CL does
not allocate memory to pass (just a few) multiple values, and the
other languages often do.
IOW, one can think of multiple values as an ephemeral struct.
Note that CL can convert multiple values to lists:
(destructuring-bind (q r) (multiple-value-list (floor 10 3))
  ; use q & r here
  ...)

instead of the more efficient and concise
(multiple-value-bind (q r) (floor 10 3)
  ; use q & r here
  ...)

MV & type
CL does not have a special type for the ""multiple value object""
exactly because it does not allocate a separate object to pass
around multiple values. In this sense one can, indeed, claim that
values is syntactic sugar.
However, in CL one can declare a
function type returning
multiple values:
(declaim (ftype (real &optional real) (values real real)) floor)

This means that floor returns two values, both
reals (as opposed to returning
a value of type (values real real)), i.e., in this case one might
claim abuse of notation.
Your case
In your specific case, type-of
is an ordinary function (i.e., not a macro or special operator).
You pass it a single object, 1, because, unless you are using
multiple-value-bind and
friends, only the first value is used, so
(type-of (values 1 2 3))

is identical to
(type-of 1)

and type of 1 is bit.
PS: Control return values
One use of values is to
control the return values of a function.
Normally a CL function's return values are those of the last form.
Sometimes it is not desirable, e.g., the last form return multiple
values and you want your function to return one value (or none,
like void in C):
(defun 2values (x y)
  (floor y x))
(defun 1value (x y)
  (values (floor y x)))
(defun no-values (x)
  (print x)
  (values))

","The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 Portably, no.  Implementations are free to return whatever kind of string they deem sensible.
I'd use a simple wrapper function and maybe declaim it inline:
(declaim (inline read-simple-line))
(defun read-simple-line (stream)
  (some-> (read-line stream nil)
          (coerce 'simple-base-string)))

(Some-> is from arrows).
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Have you tried to use the quoted form this way in all the typep usages?:
(typep tree 'element)

 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
","Yes, the `values` function in Common Lisp is indeed syntactic sugar for packaging multiple values into a list that gets destructured by the caller. This means that when you call `values`, it returns a list of the provided arguments. The `BIT` type you observed with `(type-of (values 1 2 3))` likely refers to a binary integer, which might be an implementation detail or a special case depending on the context and specific Common Lisp implementation being used. In general, `values` is used to return multiple values from a function, but these values are returned as a list that can be destructured by the caller. For more detailed information and implementations, you might want to refer to the Common Lisp HyperSpec or other comprehensive Common Lisp documentation.",0.5385,[[0.60748769]],0.011670863916658086,0.10163446026233955,0.27710843373493976,0.08459214501510574,0.13855421686746988
"In Common Lisp, what is more idiomatic way to check if an element is in the list?
Currently I am checking if ""get"" belongs to the list like this:
(some #'(lambda (x) (string= x ""get"")) '(""get"" ""update"" ""delete"" ""replace""))

","Use member function if you need to find nil in the list:
[1]> (member nil '(1 nil 2 (nil)))
    (NIL 2 (NIL))
[2]> (member nil '(1 2 (nil)))
    NIL
[3]> (member nil '(1 2 (nil) nil))
   (NIL)
[4]> (member '(nil) '(1 2 (nil) nil))
   NIL
[5]> (member '(nil) '(1 2 (nil) nil) :test #'equal)
   ((NIL) NIL)
[6]> (member ""asd"" '(1 2 ""asd"" (nil) nil) :test #'equal)
   (""asd"" (NIL) NIL)

","To pass a list of arguments to a function you can use apply, for example
(apply 'insert '(""hello "" ""world""))
 The last line of get-box should be:
(next-part-of-program new-d1 new-d2 new-d3)))))

You should not have parens around the arguments to next-part-of-program
 This is a result of using a constant list in the initializer:
(let ((myList '(0 0 0 0 0 0)))

Change that line to:
(let ((myList (list 0 0 0 0 0 0)))

and it will behave as you expect.  The first line only results in an allocation once (since it's a constant list), but by calling list you force the allocation to occur every time the function is entered.
edit:
This may be helpful, especially towards the end.  Successful Lisp
The answer to this question may also be helpful.
This uses the loop keyword collecting which collects the results of each iteration into a list and returns the list as the value of the loop.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

","In Common Lisp, an idiomatic way to check if an element is in a list is to use the 'member' function. For example, you can check if \",0.438,[[0.0627722]],0.0039039657359049174,0.0859106529209622,0.18750000000000003,0.02127659574468085,0.08333333333333333
"As a non-lisper coming to clojure how should I best understand the naming convention where vars get a name like *var-name*?
This appears to be a lisp convention indicating a global variable. But in clojure such vars appear in namespaces as far as I can tell. 
I would really appreciate a brief explanation of what I should expect when an author has used such vars in their code, ideally with a example of how and why such a var would be used and changed in a clojure library.
","It's a convention used in other Lisps, such as Common Lisp, to distinguish between special variables, as distinct from lexical variables. A special or dynamic variable has its binding stored in a dynamic environment, meaning that its current value as visible to any point in the code depends upon how it may have been bound higher up the call stack, as opposed to being dependent only on the most local lexical binding form (such as let or defn).
Note that in his book Let Over Lambda, Doug Hoyte argues against the ""earmuffs"" asterix convention for naming special variables. He uses an unusual macro style that makes reference to free variables, and he prefers not to commit to or distinguish whether those symbols will eventually refer to lexical or dynamic variables.
Though targeted specifically at Common Lisp, you might enjoy Ron Garret's essay The Idiot's Guide to Special Variables. Much of it can still apply to Clojure.
","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 In clojure binding forms (let, fn, loop, and their progeny), you can bind the rest of a binding vector to a sequence with a trailing &. For instance, 
(let [[a b & xs] (range 5)] xs) ;(2 3 4)

Uses of * and other uses of & are conventions for documenting the structure of argument lists. 
 clojure.core functions are not special in their need to be referred to make them available for unqualified use. The ns macro does several things:

creates the namespace - create-ns
changes the current namespace to that namespace - in-ns
automatically refers all of the clojure.core vars into the new namespace - refer-clojure

You can always use the qualified form of the core function (unqualified is just less typing), so when you get in this situation, this simple call will get you right again:
(clojure.core/refer-clojure)

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 To pass a list of arguments to a function you can use apply, for example
(apply 'insert '(""hello "" ""world""))
","In Clojure, while the naming convention *var-name* is common in Common Lisp for global variables accessible in all scopes, Clojure takes a different approach by organizing code into namespaces. This means that what would be a global variable in Common Lisp is typically managed within a namespace in Clojure. Names like *var-name* are less commonly used in Clojure due to its emphasis on functional programming and immutable data.

However, when you do encounter an asterisk-prefixed symbol (*var-name*) in Clojure code, it usually indicates a global variable that might be accessible across the entire application or within specific parts of it if not strictly confined. Such variables are often used for controlling system-wide state or configuration settings.

For example, imagine a library that needs to keep track of whether certain operations should log additional debug information. You might see something like:

```clojure
(def *debug* false)

(defn perform-operation []
  (if *debug*
    (println ",0.5404,[[0.28651849]],0.12711883821941714,0.35145539171205714,0.30573248407643305,0.038461538461538464,0.15286624203821653
"The following two expressions are equivalent:
(third (list 1 2 3 4))

(first (nthcdr 2 (list 1 2 3 4)))

However, using ""third,"" ""fourth,"" ""fifth,"" etc. isn't always practical and (first (nthcdr n list)) seems a little verbose. Is there a way to say something like (item 2 (list 1 2 3 4)) to get the nth item in a list?
","(nth 3 (list 1 2 3 4))

returns 4th item  (zero based!)
According to the HyperSpec:

Accessor NTH
Description:
nth locates the nth element of list, where the car of the list is the “zeroth” element. Specifically,
(nth n list) ==  (car (nthcdr n list))

Examples:
(nth 0 '(foo bar baz)) =>  FOO
(nth 1 '(foo bar baz)) =>  BAR
(nth 3 '(foo bar baz)) =>  NIL
(setq 0-to-3 (list 0 1 2 3)) =>  (0 1 2 3)
(setf (nth 2 0-to-3) ""two"") =>  ""two""
0-to-3 =>  (0 1 ""two"" 3)


","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 As mentioned in first comment it is necessarily to use (list a b c) form.
 When the reader encounters a syntax-quoted form, that turns out to be a collection, it will iterate over each element and call syntax-quote recursively. The result is consed, beginning with nil.
So it comes down to the question why the following holds:
> (list? (cons 'inc nil))
true
> (list? (cons 'inc (cons 1 nil)))
false

This seems to be a matter of definition.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 The sequence of frames is the linked list (of frames) pointing 'upwards' towards the global environment.  So when an environment is created (for example, in the context of a procedure binding), the 'environment' is a pointer to the frame...which in term points to the enclosing environment (or null, if the global environment).
So ... a qualified 'yes'...it's the first frame in the sense that the rest of the environment is accessible from that first frame.
Does that help?
Cordially,
Dak
","Yes, you can create a custom function to achieve this. In Common Lisp, you can define a function like `(defun item (n lst) (first (nthcdr n lst)))` which takes an index `n` and a list `lst`, and returns the nth item in the list. This provides a more concise way to access elements by their position without using multiple calls to `first` or `nthcdr`. For example, `(item 2 '(1 2 3 4))` will return `3`.",0.5673,[[0.21404883]],0.11046704281506203,0.21231828615149198,0.2530120481927711,0.07317073170731708,0.16867469879518074
"I'm new to Lisp and have no idea how to write this...
You give: (""Test"" ""TEST"" ""third"" ""the last"")
You get:  ((""A"" . ""Test"") (""B"" . ""TEST"") (""C"" . ""third"") (""D"" . ""the last""))
Function: (defun choices (&rest choices))

In C, I can just write a for for this, but Lisp can't +1 to string and loop doesn't have a counter, either... Could someone please give me a sample?
","I would write something like this:
(defun  choices (&rest choices)
  (loop for i from 1 to 26
        and item in choices
        collect (cons (string (digit-char (+ 9 i) 36))
                      item)))

The above code has no error checking for more than 26 choices (and you
didn't specify how to handle them if it's not an error).
You could use CHAR-CODE and CODE-CHAR to ""increment a character"",
but the encoding they provide is not standardized (only some
properties of it are guaranteed). With DIGIT-CHAR in radix 36, we're
guaranteed to get the English alphabet (uppercase) for weights 10 to
35.
And of course, LOOP has a lot of things, including whatever counters you want. 
","decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 (let ((a read)))
   (eval a))

(+ 2 2 2)

=> 6

there's a reason they call it a READ EVAL PRINT LOOP.
 According to the grammar, options must be parenthesized individually.  The defstruct form therefore needs to look like this:
(defstruct (test-struct (:print-function print-test)
                        (:constructor create-test (&key a (b a) c)))
  a
  b
  c)

 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 You will find that, in the REPL, the variable * holds the last result, and + holds the last evaluated form. 
For example:
> (+ 1 2)
  => 3
> +
  => (+ 1 2)
> (+ 2 3)
  => 5
> *
  => 5

Yes, these are standard, and in the HyperSpec.
If you wish to create a list containing the symbol +, rather than its value, you will need to quote it, as such: '+, or (quote +).
","In Lisp, you can achieve similar functionality using recursion or higher-order functions like `mapcar` and `append`. Here’s how you can create a function that takes a list of strings and returns an association list where each string is paired with its corresponding index + 1:\n\n```lisp\n(defun choices (&rest choices)\n  (let ((assoc-list nil))\n    (loop for choice in choices\n          for i from 1\n          do (setq assoc-list (append assoc-list (list (cons i choice))))\n          finally (return assoc-list))))\n\n(choices \",0.5952,[[0.18027912]],0.24091758667501276,0.28876590846985434,0.2980769230769231,0.07766990291262137,0.125
"I'm confused about how defun macro works, because 
(defun x () ""hello"")

will create function x, but symbol x still will be unbound. 
If I'll bind some lambda to x then x will have a value, but it will not be treated by interpreter as function in form like this:
(x)

I think that it is related to the fact that defun should define function in global environment, but I'm not sure what does it exactly mean. Why can't I shadow it in the current environment?
Is there any way to force interpreter treat symbol as function if some lambda was bound to it? For example:
(setq y (lambda () ""I want to be a named function""))
(y)

P.S.: I'm using SBCL.
","Common Lisp has different namespaces for functions and values.
You define functions in the function namespace with DEFUN, FLET, LABELS and some others.
If you want to get a function object as a value, you use FUNCTION. 
(defun foo (x) (1+ x))

(function foo)   ->  #<the function foo>

or shorter:
#'foo    ->   #<the function foo>

If you want to call a function, then you write (foo 100).
If you want to call the function as a value then you need to use FUNCALL or APPLY:
(funcall #'foo 1)

You can pass functions around and call them:
(defun bar (f arg)
  (funcall f arg arg))

(bar #'+ 2)  ->  4

In the case of DEFUN:
It is not (setf (symbol-value 'FOO) (lambda ...)).
It is more like (setf (symbol-function 'foo) (lambda ...)).
Note that the two namespaces enable you to write:
(defun foo (list)
  (list list))

(foo '(1 2 3))  ->  ((1 2 3))

There is no conflict between the built-in function LIST and the variable LIST. Since we have two different namespaces we can use the same name for two different purposes.
Note also that in the case of local functions there is no symbol involved. The namespaces are not necessarily tied to symbols. Thus for local variables a function lookup via a symbol name is not possible. 
","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

 In this case, x[0] is define, x[1] is the variable name, and x[2] is the expression. So, in Python, _, var, exp = x is a ""destructuring assignment"", which destructures the array x into its constituent elements, and assigns them to the variables on the left-hand side.
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 Remember that a macro returns an expression to be evaluated. In order to do this, you have to backquote:
(defmacro ++ (variable)
   `(incf ,variable))

 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
","In Common Lisp, `defun` is indeed a macro that defines functions in the global environment. When you write `(defun x () ",0.5266,[[0.26952605]],1.1880005024671041e-05,0.0407149950347567,0.1282051282051282,0.05172413793103448,0.08547008547008547
"I was studying Lisp and I am not experienced in Lisp programming. In a part of my studies I encountered the below examples:
> (cons ‘a ‘(a b))  ----> (A A B)
> (cons ‘(a b) ‘a)  ----> ((A B).A)

I was wondering why when we have (cons ‘a ‘(a b)) the response is (A A B) and why when we change it a little and put the 'a after (a b), the response is a dotted list like ((A B).A)? What is the difference between the first code line and the second one? What is going on behind these codes?
","It's pretty easy to understand if you think of them as cons-cells.
In short, a cons cell consists of exactly two values. The normal notation for this is to use the dot, e.g.:
(cons 'a 'b) ==> (A . B)

But since lists are used so often in LISP, a better notation is to drop the dot.
Lists are made by having the second element be a new cons cell, with the last ending a terminator (usually nil, or '() in Common Lisp). So these two are equal:
(cons 'a (cons 'b '())) ==> (A B)
(list 'a 'b) ==> (A B)

So (cons 'a 'b) creates a cell [a,b], and (list 'a 'b) will create [a, [b, nil]].  Notice the convention for encoding lists in cons cells: They terminate with an inner nil.
Now, if you cons 'a onto the last list, you create a new cons cell containing [[a, [b, nil]], a]. As this is not a ""proper"" list, i.e. it's not terminated with a nil, the way to write it out is to use the dot: (cons '(a b) 'a) ==> ((a b) . a).
If the dot wasn't printed, it would have to have been a list with the structure [[a, [b, nil]], [a, nil]].
Your example
When you do (cons 'a '(a b)) it will take the symbol 'a and the list '(a b) and put them in a new cons cell.  So this will consist of [a, [a, [b, nil]]].  Since this naturally ends with an inner nil, it's written without dots.
As for (cons '(a b) 'a), now you'll get [[a, [b, nil]], a]. This does not terminate with an inner nil, and therefore the dot notation will be used.
Can we use cons to make the last example end with an inner nil? Yes, if we do
(cons '(a b) (cons 'a '())) ==> ((A B) A)

And, finally,
(list '(a b) 'a))

is equivalent to
(cons (cons (cons 'a (cons 'b '())) (cons 'a '())))

","As mentioned in first comment it is necessarily to use (list a b c) form.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 There is no need to use the sharp-quote syntax here.  Its purpose is to use a function name in a variable position, but a is a variable already.  Just write a instead of #'a.
","In Lisp, `(cons 'a '(a b))` constructs a new list by taking the symbol `a` and consing it onto the beginning of the list `(a b)`. The result is `(A A B)` because `a` (as a symbol) becomes the car of the resulting list, and then the original list `(a b)` follows as its cdr. On the other hand, `(cons '(a b) 'a)` constructs a new cons cell with the list `(a b)` as the car and the symbol `a` as the cdr, hence the result is `((A B). A)`. The first example creates a regular list, while the second one results in a dotted pair where the car is a list and the cdr is a symbol.",0.6093,[[0.4579168]],0.05515086006946009,0.14995226645262805,0.36525612472160357,0.1565995525727069,0.2316258351893096
"Just started to learn LISP and I'm trying to figure out how to write the following recursive function.
So should I have 
(DOT-PRODUCT '(1 2) '(3 4)))

The output should be 11
I've written the following 
(defun DOT-PRODUCT (a b)
  (if (or (null a) (null b))
      0
      (+ (* (first a) (first b))
         (DOT-PRODUCT (rest a) (rest b)))))

And everything seems to work; however, it still works with lists of different lengths. I want it to just work with lists of numbers that have the same length. Where should I add code that returns ""invalid length"" should we have such?
","A simple way is to rewrite the function so that it checks different cases using the conditional form cond:
(defun dot-product (a b)
  (cond ((null a) (if (null b) 0 (error ""invalid length"")))
        ((null b) (error ""invalid length""))
        (t (+ (* (first a) (first b))
              (dot-product (rest a) (rest b))))))

In the first branch of the cond, if the first argument is NIL, the second one must be NIL as well, otherwise an error is generated. In the second branch, we already know that a is not NIL, so an error is immediately generated. Finally, the result is calculated.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Your current code loops through and prints each element of the list, unconditionally.
When you pass it (A (NOT B) C), it is printing every element, one of which is the list (NOT B), and the loop is printing that list. The parentheses are output by the printer to represent that the element being printed is a list.
You need some logic to check if each element is something you'd like to not print, like the symbol NOT or nil, and recurse down when you see a something you want to examine further, such as a list.
","Your current implementation of DOT-PRODUCT works for lists of different lengths and simply adds zeros when a list is shorter. To ensure it only works with lists of the same length, you can add a check at the beginning of your function to compare the lengths of the two input lists using LENGTH. Here’s how you can do it:\n\n```lisp\n(defun DOT-PRODUCT (a b)\n  (if (or (null a) (null b)) ; Check if either list is null\n      0\n      (let ((len-a (length a))\n            (len-b (length b)))\n        (if (/= len-a len-b) ; Compare lengths of the lists\n            'invalid-length\n            (+ (* (first a) (first b))\n               (DOT-PRODUCT (rest a) (rest b)))))))\n```\nThis way, if the lengths are not equal, it will return 'invalid-length instead of proceeding with the computation.",0.6855,[[0.38407286]],0.29509147662675683,0.5317771433985425,0.3983402489626556,0.1506276150627615,0.28215767634854766
"Is it possible to play a MIDI file (existing on the hard drive) from Common Lisp?  If so, how?
","If your Common Lisp implementation supports FFI, you might be able to use a library like PortAudio. (Also see the Common Lisp Foreign Function Interface project). Another option is to use the venerable Simple DirectMedia Layer which already have Lisp bindings. (But you may also have to get Timidity).
","The flexi-streams library provides, among other things, in-memory binary streams.
 AutoLISP does not support multiple threads - programs are executed in 'series' using a single processor thread. As such, this is unfortunately not possible.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 You can first read-sequence (if you know the length ahead of time) or read-bytes while there are some, and then convert them to string with (babel:octets-to-string octets :encoding :utf-8)) (where octets is (make-array expected-length :element-type '(unsigned-byte 8))).
 Use with-input-from-string. 
(with-input-from-string (s ""4 3 2"")
  (let ((a (read s))
        (b (read s))
        (c (read s)))
    (format t ""~a, ~a, ~a~%"" a b c))) 

You could also just read from a file, but reading from a string is much easier for making different test cases.
 My assumption is that ""thread-id"" is some sort of procedure. 
","Playing a MIDI file directly from Common Lisp can be achieved using various libraries. One such library is `trivial-midi`, which allows you to read and play MIDI files. Here’s an example of how you might use it:\n\n1. First, ensure the trivial-midi library is installed.\n2. Then, you can load the file and play it with the following code:\n```lisp\n(require 'trivial-midi)\n(let ((midi-file (truename \",0.52,[[0.20514978]],0.12737802897643802,0.32272325375773653,0.2601626016260163,0.03305785123966942,0.16260162601626016
"Is there a way to pretty-print Lisp-style code string (in other words, a bunch of balanced parentheses and text within) in Python without re-inventing a wheel?
","Short answer
I think a reasonable approach, if you can, is to generate Python lists or custom objects instead of strings and use the pprint module, as suggested by @saulspatz.
Long answer
The whole question look like an instance of an XY-problem. Why? because you are using Python (why not Lisp?) to manipulate strings (why not data-structures?) representing generated Lisp-style code, where Lisp-style is defined as ""a bunch of parentheses and text within"".
To the question ""how to pretty-print?"", I would thus respond ""I wouldn't start from here!"".
The best way to not reinvent the wheel in your case, apart from using existing wheels, is to stick to a simple output format.
But first of all all, why do you need to pretty-print? who will look at the resulting code?
Depending on the exact Lisp dialect you are using and the intended usage of the code, you could format your code very differently. Think about newlines, indentation and maximum width of your text, for example.         The Common Lisp pretty-printer is particulary evolved and I doubt you want to have the same level of configurability.
    If you used Lisp, a simple call to pprint would solve your problem, but you are using Python, so stick with the most reasonable output for the moment because pretty-printing is a can of worms.
If your code is intended for human readers, please:

don't put closing parenthesis on their own lines
don't vertically align open and close parenthesis
don't add spaces between opening parenthesis

This is ugly:
 ( * ( + 3 x )
     (f 
        x
        y
     )
 )

This is better:
(* (+ 3 x)
   (f x y))

Or simply:
(* (+ 3 x) (f x y))

See here for more details.
But before printing, you have to parse your input string and make sure it is well-formed. Maybe you are sure it is well-formed, due to how you generate your forms, but I'd argue that the printer should ignore that and not make too many assumptions. If you passed the pretty-printer an AST represented by Python objects instead of just strings, this would be easier, as suggested in comments. You could build a data-structure or custom classes and use the pprint (python) module. That, as said above, seems to be the way to go in your case, if you can change how you generate your Lisp-style code.
With strings, you are supposed to handle any possible input and reject invalid ones.
This means checking that parenthesis and quotes are balanced (beware of escape characters), etc.
Actually, you don't need to really build an intermediate tree for printing (though it would probably help for other parts of your program), because Lisp-style code is made of forms that are easily nested and use a prefix notation: you can scan your input string from left-to-right and print as required when seeing parenthesis (open parenthesis: recurse; close parenthesis, return from recursion). When you first encounter an unescaped double-quote "", read until the next one "", ... 
This, coupled with a simple printing method, could be sufficient for your needs.
","The most idiomatic solution in Racket would be:
(make-list 5 'a)
=> '(a a a a a)

That is, you should not reinvent the wheel if a built-in function does what you want. But if you need to write it from scratch, this should do the trick:
(define (list-of-obj obj n)
  (letrec ((helper
            (lambda (obj n result)
              (if (> n 0)
                  (helper obj (- n 1) (cons obj result))
                  result))))
    (helper obj n '())))

There were two problems with your code:

The call to helper must be surrounded by (), because that's how you call a procedure in Scheme.
The initial value for the accumulator must be an empty list given that we're building a list as the output, not a 0 as you had it.

 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

 The example is unfortunate, as it only leaves one argument after ""the opening of the parentheses"". But yes, that's how I also think about it. The simpler the better, :) as long as it is correct.
Except that of course the values in the list are first evaluated, so it's not a simply-syntactical process. But as a basic example,
(apply + (list 1 2 3)) 
== 
(      +       1 2 3 )

i.e. the parens around the arguments is what goes away.
For a non-trivial example, see

Matrix multiplication in scheme, List of lists

 JSCL requires (differently from the standard) more than one parameter in the write function, so this is the reason of the error.
If you use print instead, the error does not appear.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 The error is caused by the wrong use of the parentheses. Try this:
(defun helloworld (name)
    (format t ""~%Hello from Lisp, ~A!"" name))

Remeber, you must always use forms, i.e. (operator arguments) instead of commands as in other programming languages.
To reduce the number of these errors, you could use a Common-Lisp aware editor, that align the lines according to their syntactic meaning. One of the best editor in this respect is the combination Emacs + SLIME, but there are other possibilities.
","Yes, you can use libraries like `pprint` in Python to pretty-print Lisp-style code strings. However, since Lisp code often involves nested parentheses and special symbols, a specialized parser might be needed to handle the structure correctly. One approach is to use an existing library such as `clike` which provides support for parsing Lisp-like syntax. Here’s a basic example using `pprint`:",0.5353,[[0.37639997]],0.00015961034608880057,0.05048228612638601,0.1435897435897436,0.030874785591766724,0.08205128205128205
"I have these two lists:
'(and 1 (or a b))
'( (a 0)(b 1) )

I am new to lisp, and I am finding it very hard to figure out how to compare these two lists. I am thinking of creating a comparison function, but I don't know how to compare them one by one as in lisp values aren't returned until the expression is evaluated. Since they aren't the same structure either, I can't assume they will be the same, structurally at least. Any explanation how this works?
Edit: Sorry, I forgot to say why I am comparing. The second list is to suppose to bind the number to everywhere where those variables exists in the first list. So the resulting first list should be:
'(and 1(or 0 1))

","Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You are comparing a list containing 1 & 2 with a list containing the symbols a & b. Symbols are legitimate values in Clojure. '(a b) is equivalent to (list 'a 'b) not (list a b).
 (= '(1 2) (list a b))

Is probably the comparison you want.
 You had too many parentheses in the recursive call. Consider the following:

(is-word-in-list (x (cdr lst))) is equivalent to isWordInList(x(cdr(lst))) in JavaScript syntax
(is-word-in-list x (cdr lst)) is equivalent to isWordInList(x, cdr(lst)) in JavaScript syntax

See the difference?
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 (second expr) is the list (* 3 x) which is not a number, but the function sqrt demands a number for its argument. Since you say you want to do symbolic differentiation, you probably should return a list with the symbol sqrt in it, rather than calling the function.
",Answer not found.,0.3416,[[0.]],2.0749098804739844e-14,0.009380863039399626,0.0,0.0,0.0
"My current understanding is that macros can implement any imaginable concept, including monads, because they ""have the compiler at hands"". Is this true? For example, I have came across this link
Please, give me facts and examples, no passionate answers. Thank you.
","That's kind of an odd comparison. It's a bit like asking ""what can a petrol car do that a diesel generator cannot?"" Er, well, those aren't really the same class of thing...
Lisp macros [which I know almost nothing about] allow you to do compile-time meta-programming. You can use that to achieve all sorts of useful things, from eliminating a bit of boilerplate code to virtually defining an entire new programming language.
Haskell monads are a useful way to structure certain kinds of computations. They make it easy to do certain things which are otherwise a bit tedious. (E.g., checking the result of each and every function to make sure it succeeded before running the next function.) All of this is a run-time thing, though; it has nothing to do with compile-time code generation.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Yes, it's possible. The easiest way would be to simply redefine the class. You do that by issuing another call to DEFCLASS. If you want to do more complicated things, you have to resort to the MOP (MetaObject Protocol). Essentially everything you'd ever want to do is possible using the MOP, but I would need more detailed information as to what it is you're trying to do in order to explain it further.
 My elisp is a bit rusty, but until someone comes up with the actual explanation:  I could get your examples to work a bit more as expected my replacing cmd with (eval cmd) (possibly same with name) in the macro definition body.
Hope this helps.
 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
","Your understanding is correct that macros in Lisp can implement complex concepts because they operate at compile-time and have access to the full power of the language's syntax. However, while macros are extremely powerful, they do not directly support constructs like monads out-of-the-box. Monads are a concept from functional programming that require specific composition rules and operations which can be implemented using macros.

For example, you could create a macro that simulates some aspects of a monad by defining a `bind` operation and other necessary functions. Here's a simple example to illustrate:

```lisp
(defmacro bind ((var expr) &body body)
  `(let ((,var ,expr))
     (if ,var
         (progn ,@body)
         nil)))

;; Usage:
(bind (x (+ 1 2))
  (print x)) ; This will print 3

;; A more complex example with a `return` function to simulate monad-like behavior:
(defun return (value) value)

(defmacro bind ((var expr) &body body)
  `(let ((,var ,expr))
     (if ,var
         (progn (bind (result ,@body)) result)
         nil)))

;; Usage with a monad-like `return` and `bind`
(bind (x (return (+ 1 2)))
  (print x)) ; This will print 3

(bind (y (return (* 2 x)))
  (print y)) ; This will print 6
```

This is a simplified version and does not cover all the nuances of monads, but it demonstrates how macros can be used to implement complex language features.",0.4881,[[0.24821955]],0.08875771272276892,0.3138880663310631,0.2913165266106443,0.03943661971830986,0.12885154061624648
"I am writing a program that recursively iterates through a list, provided the index of the current character and a list of characters. However, when I run the following program:
(defun printAllElementsRecursively (index providedList)
    (if (>= index (length providedList))
        (return-from printAllElementsRecursively NIL)
    )
    (defvar currCharacter (nth index providedList))
    (print (format nil ""Character at index ~a: ~a"" index currCharacter))
    (printAllElementsRecursively (+ index 1) providedList)
)

(printAllElementsRecursively 0 '(A B B A))

I get the following output:
""Character at index 0: A"" 
""Character at index 1: A"" 
""Character at index 2: A"" 
""Character at index 3: A"" 

This seems strange, considering that the value of index does increment correctly.
","You are misusing defvar:

It should never be used inside a function, use let instead or just (nth index providedList) instead of currCharacter.

It defines a new global variable, and only sets it if it has not been set yet, so it sets
currCharacter once only.


You also do not really need return-from, and your code
would be more readable if use used dashes instead of camel case.
E.g.,
(defun print-list-elements-recursively (list)
   (when list
     (print (first list))
     (print-list-elements-recursively (rest list))))

Also, nth is linear in its list argument's length,
so your function is quadratic in it (my version is linear).
","The ' character is a reader macro, i.e. the Lisp reader will expand it into a call to quote. The CLHS entry on quote gives the following evaluation examples:
'a  => A
''a => (QUOTE A) 

Hence:
(rev (list 'a))  =>     (A)
(rev (list ''a)) =>     ((A QUOTE))
(rev ''a)        =>     (A QUOTE)
(rev '(a))       =>     (A)
(rev '('a))      =>     ((A QUOTE))

 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 (with-open-file (str ""/.../filename.txt""
                     :direction :output
                     :if-exists :supersede
                     :if-does-not-exist :create)
  (format str ""write anything ~%""))

You may also choose different settings for the with-open-file macro. If you use :append instead of :supersede then you can write into the text file while preserving its context instead of superseding the available content.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 read-char will return the next available character, and read-line will return an entire line of input as a string. You can use coerce to change a string to a list of characters, e.g.
(coerce ""foo"" 'list) => (#\f #\o #\o)

","The issue with your function lies in the use of `return-from` which exits the entire function when the condition `(>= index (length providedList))` is met. Instead of using `return-from`, you should return a value from the recursive call to avoid early termination. Here's the corrected version of your function:\n\n```lisp\n(defun printAllElementsRecursively (index providedList)\n  (if (>= index (length providedList))\n      nil\n      (progn\n        (defvar currCharacter (nth index providedList))\n        (print (format nil \",0.5869,[[0.2012215]],0.17599089617207925,0.3338524622046479,0.3101604278074867,0.05405405405405405,0.13903743315508021
"I know it should be simple. but I am new to this language and the syntax is kind hard to figure out. 
I have made one function to check whether it's the prime number or not, and bigger function would just create the list with only prime numbers. 
Input is the any given list of numbers. Let's say '(2 3 7 8 4) Then it only should return '(2 3 7)
So I already have checked whether my primeHelper is working or not just calling primehelper with different numbers.
(define (primeHelper x i)
  (cond
    ((<= x 1) #f)
    ((= x 2) #t)
    ((= x 3) #t) 
    ((zero? (modulo x i)) #f)
    ((not(zero? (modulo x i))) #t) 
    (else (primeHelper x (+ i 1)))))

(define (prime lis)
  (cond
    ((null? lis) (display ""() list""))
    ((not(list? lis)) (display ""this is an atom""))
    ((eq? (primeHelper (car lis) 2) #t)(cons (car lis) '()))
    (else (prime (cdr lis)))
    ))

I am just getting a list 2
","There are several problems in your program.
First, primeHelper is wrong. Try it for instance with (primeHelper 33 2): it will return #t, but 33 is not a prime number.
Here is a correct version (with a recursive function):
(define (primeHelper x i)
  (cond ((<= x 1) #f)
        ((= x 2) #t)
        ((>= i x) #t)
        ((zero? (modulo x i)) #f)
        (else (primeHelper x (+ i 1)))))

Also, the prime function is wrong, its recursion is not correct. Here is a possible correct version:
(define (prime lis)
  (cond ((null? lis) '())
        ((primeHelper (car lis) 2) (cons (car lis) (prime (cdr lis))))
        (else (prime (cdr lis)))))

Let’s try it:
(prime '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23))
'(2 3 5 7 11 13 17 19 23)

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

","Your current implementation of `prime` has some issues. The main problem is that you are checking if `(car lis)` is prime and then immediately returning it wrapped in a list. Instead, you should filter all the prime numbers from the list. Here's how you can modify your code to achieve this:\n\n```lisp\n(define (prime lis)\n  (cond\n    ((null? lis) '())\n    ((not(list? lis)) (display \",0.6062,[[0.33884617]],0.07272060960589606,0.14993302785228538,0.251207729468599,0.058536585365853655,0.14492753623188406
"I'm working on converting some existing Python code to CLisp just as an exercise ...
The program reads a list of numbers and creates mean, min, max and standard deviation from the list. I have the file-based function working:
(defun get-file (filename)
   (with-open-file (stream filename)
     (loop for line = (read-line stream nil)
      while line
      collect (parse-float line))))

This works when I call it as
(get-file ""/tmp/my.filename"")

... but I want the program to read standard input and I've tried
various things with no luck.
Any advice?
","Just separate concerns:
(defun get-stream (stream)
  (loop for line = (read-line stream nil)
        while line
        collect (parse-float line)))

(defun get-file (filename)
  (with-open-file (stream filename)
    (get-stream stream)))

Then you can use get-file like you already do, and (get-stream *standard-input*).
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

","To adapt your existing function `get-file` to read from standard input instead of a file, you can modify it to use `*standard-input*`. Here's how you could do it:

```lisp
(defun get-file-from-standard-input ()
  (loop for line = (read-line *standard-input* nil)
        while line
        collect (parse-float line)))
```

You can then call this function like so:

```lisp
(get-file-from-standard-input)
```

This version of the function will read lines from standard input until there are no more lines to read. Each line is parsed as a float and collected into a list.",0.6887,[[0.33944033]],0.3118377425756176,0.42335429317526035,0.4027777777777778,0.21126760563380284,0.2777777777777778
"I am writing the square of sums in racket/scheme recursively. The code sums the numbers right, but it doesn't square it right. I don't know what I am doing wrong. If I pass 10, it should be 3025.
(define (squareOfSums n)
 (if (= n 0)
  0
   (expt (+ n (squareOfSums (- n 1))) 2)))

","You should do the squaring only once, at the end of the recursion. Currently, your code squares at every iteration. One way to solve this problem would be to separate the sum part into a helper procedure, and square the result of calling it. Like this:
(define (squareOfSums n)
  (define (sum n)
    (if (= n 0)
        0
        (+ n (sum (- n 1)))))
  (sqr (sum n)))

Also, did you know that there's a formula to add all natural numbers up to n? This is a nicer solution, with no recursion needed:
(define (squareOfSums n)
  (sqr (/ (* n (+ n 1)) 2)))

Either way, it works as expected:
(squareOfSums 10)
=> 3025

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 No, the answer in the book is right. Note that the expression has 3 occurrences of (quote ()), to create 3 lists. Then it conses various atoms onto the lists. Your answer contains 5 lists, not 3.
(quote ()) simply returns an empty list. (cons 1 (quote ())) adds one item to the empty list to yield (1).
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 This is how I make it work:
(do ([x 6000 (- x 1)])
  ((zero? x))
  (set! lst (cons (my-procedure '((a . 1)(b . 2)(c . 3))) lst)))

 You've got it almost right. However, you're terminating your list with 0, when the correct termination is nil. This code works:
(defun vecmul (list list2)
  (cond ((null list) nil)
     (t (cons (* (car list) (car list2)) (vecmul (cdr list) (cdr list2))))))

When you call (cons 1 2), the cons cell you get is written (1 . 2). the notation (1 2 3 4 5) is just shorthand for (1 . (2 . (3 . (4 . (5 . nil))))). If the cdr of the last cons cell is 6, not nil, then you get (1 . (2 . (3 . (4 . (5 . 6))))), which shortens to (1 2 3 4 5 . 6).
",Answer not found.,0.3631,[[0.]],1.1273279936723772e-23,0.007270083605961469,0.0,0.0,0.0
"I use hunchentoot web server, and upload files there. It stores a file into a temporary location (/tmp/hunchentoot/hunchentoot-XX), and sets the modification and creation date to now. How can I get an original creation date of the file received?
","1) The date is not sent over HTTP at all, it does not depend on your server.
2) You can not expect to always have correct date information from client.
If file format contains date then parse the format. Do this if you are sure format won't be tampered with by malisious user.
If you trust the user let him select date manually.
","(setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 To copy loop use
(setq new_tour (copy-list loop))

 Here's how:

Click on the ""run"" button, as you discovered
Press Esc  + p

And this is the relevant page in the documentation.
 Open the file and read in the data:
(with-open-file (f ""file.txt"")
  (read f))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
",Unable to answer based on the available knowledge.,0.4684,[[0.09935436]],0.0001041377976897813,0.04838709677419355,0.08333333333333333,0.0,0.05555555555555555
"Is there a way to create a directory using common lisp. I want to first create a folder and then put my .txt .png files in that. I know that first I can create the folder externally and then using with-open-file and so on create my files inside the directory. What I want is a common lisp solution for this.
","(ensure-directories-exist ""/path/name/"")

","To use open files, you must save the return value of open and uses it as the second argument to princ. You must also use that same return value as an argument to close.
This is usually done with the convenience macro with-open-file.
The files chapter of Practical Common Lisp shows how to use these and other functions and macros.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
 The reason the ANSI CL standard does not specify the algorithmic complexity of 
library functions is that it is not its job. The standard describes the behavior, and leaves performance to the implementation-specific docs. 
It was assumed that the best theoretical performance will be provided by all implementations (otherwise no one would use it).
To answer your specific question, gethash is O(1) in all implementations.
 I got the answer from RG in comp.lang.lisp: the default behavior of (open ...) in CCL is to give the ownership of the stream to the process that first attempted an I/O operation on it. This can be overriden with the argument :sharing :lock. This is documented in http://ccl.clozure.com/ccl-documentation.html#CCL-Stream-Extensions.
I tested and now it works as expected.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
","In Common Lisp, you can use the function `make-directory` from the `cl-fad` library (Foreign Affairs Directory) or similar libraries to create a directory. Once the directory is created, you can use `with-open-file` to create and write files into it. Here's an example using `cl-fad`:",0.4861,[[0.]],0.004512439047584269,0.149812734082397,0.03636363636363636,0.0,0.03636363636363636
"I have a problem when I'm using macros in clojure. Here is what I'm trying to do.
(defmacro working-example []
  '(+ foo 1))

(defn working-function [foo]
  (working-example))

(working-function 2) ; => 3

(defmacro broken-example [bar]
  `(+ foo ~bar))

(defn broken-function [foo]
  (broken-example 1)) ; => I get error here.

(broken-function 2) ; Should be 3.

I want the broken-example macro to only replace text just like working-example does. Why doesn't it work and how should do I get it to work?
","I'm fairly new to Clojure, but I'll try to explain you what's happening here. Quoting and backquoting are different in how they treat symbols. For example, you can write similar code that result in subtle differences:
user=> '(+ foo 2)
(+ foo 2)
user=> `(+ foo 2)
(clojure.core/+ user/foo 2)

Note how just using backquote ""binds"" the symbols to the corresponding namespace (clojure.core for + and user for foo). In the contrary, quoting just treats the symbol as-is. If you want to correctly write your broken function, you can use the list syntax:
(defmacro broken-example [bar]
  (list '+ 'foo bar))

(defn broken-function [foo]
  (broken-example 1))

(broken-function 2)

Now broken-function outputs the expected result. 
EDIT:
Now thanks to A. Webb comment below, you can also avoid the namespace binding by using this syntax:
(defmacro broken-example [bar]
  `(+ ~'foo ~bar))

","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I'm surprised that you get a result at all. I get an error:
*** - PROGN: variable THE has no value
The following restarts are available:
USE-VALUE      :R1      Input a value to be used instead of THE.
STORE-VALUE    :R2      Input a new value for THE.
ABORT          :R3      Abort main loop

The reason is that strings in Common Lisp must be in double quotes: ""Return ..."". Single quotes are only used to prevent evaluation.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Your ""iterative"" solution is still recursing. It's also not returning the values found in the cond expression.
The following version sets a variable to the found result. Then the loop ends if a result has been found, so it can be returned.
(defun f (item tree)
  (let ((p tree)
        (result nil))
    (while (and p (null result))
      (cond ((equal item (car p)) (setq result p))
            ((and (listp (car p))
                  (equal item (caar p)))
             (setq result (car tree)))
            (t (setq p (cdr p)))))
    result))

 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
","The issue with your `broken-example` macro is that you are not properly handling the `foo` symbol inside the macro. In Common Lisp (and Clojure), when you use a backtick (`) to quote code in a macro, you need to ensure that all symbols used within the quoted form are either quoted or spliced in correctly using tilde (~). Additionally, you should not explicitly pass `foo` as an argument inside the macro body since it is already bound to the first argument of the macro.

Here's how you can correct your macro:

```lisp
(defmacro broken-example [bar]
  `(let ([foo ~bar])
     (+ foo bar)))
```

In this corrected version, `foo` is set to be equal to `bar` within a local scope using `let`. This way, the macro expands correctly and behaves similarly to your working example.",0.6,[[0.48583403]],0.22161415672770055,0.35014975976691215,0.4187725631768954,0.07272727272727274,0.19494584837545126
"Is there in Scala some language construction like lisp's progn?
Thanks!
","Yep, curly braces.
progn evaluates forms, in the order in which they are given.

The values of each form but the last are discarded.

Examples:

 (progn) =>  NIL
 (progn 1 2 3) =>  3
 (progn (values 1 2 3)) =>  1, 2, 3
 (setq a 1) =>  1
 (if a
      (progn (setq a nil) 'here)
      (progn (setq a t) 'there)) =>  HERE
 a =>  NIL

Now the same, but in scala: 
scala> {}

// Unit is not written explicitly, but it is here
scala> {1; 2; 3}
// warnings omitted
// res1: Int = 3

scala> {(1, 2, 3)}
// res2: (Int, Int, Int) = (1,2,3)

// no direct analog for setq, skipping other examples

And to ensure you that evaluates forms, in the order in which they are given:
scala> {println('1'); println('2'); println('3')}
1
2
3

","You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 On anything but Gentoo (which has a very well maintained Lisp overlay), I would use clbuild for now.  I have the hope that XCVB will be usable soon.
 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

","In Scala, you can achieve similar functionality to Lisp's `progn` using a sequence of expressions. For example, you can write multiple statements on a single line without needing a special construct like `progn`. If you want to ensure that all operations in a sequence are evaluated and the value of the last expression is returned or used, you can wrap them in parentheses or use a function that returns the result of its last statement. Scala does not have a direct equivalent of Lisp's `progn`, but you can achieve the same effect through other means.",0.473,[[0.31686376]],0.06049007750312749,0.18343815513626832,0.32,0.053811659192825115,0.13333333333333333
"The following test is rejected:
CL-USER> (apply 'and '(t t t))
; Evaluation aborted on #<CCL::CALL-SPECIAL-OPERATOR-OR-MACRO #x3020013A1F3D>

My first reply was trying to encapsulate the call to the and special operator into a lambda or defining my own definition, but of course it can't work. Since it would results in calling the apply function for 'and on the &rest parameter... How would you tackle the issue?
","Use the function EVERY instead.
(every #'identity '(t t t))  -> t

You can't apply special operators.
Next solution:
(reduce (lambda (a b) (and a b))
        '(t t t)
        :initial-value t)

Don't use APPLY for list operations. Use REDUCE.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 An alternate approach:
(require 'cl)

(defun is-useless-buffer (buffer)
  (let ((name (buffer-name buffer)))
    (and (= ?* (aref name 0))
         (not (string-match ""^\\*shell\\*"" name)))))

(defun kill-useless-buffers ()
  (interactive)
  (loop for buffer being the buffers
        do (and (is-useless-buffer buffer) (kill-buffer buffer))))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

","The issue here is not with how `AND` is called but rather that `APPLY` expects a function and arguments to pass to that function. In your case, `'AND` is the symbol for the special operator `and`, which cannot be directly applied like a regular function using `APPLY`. To use `AND` in such a way, you should simply call it directly without wrapping it with `APPLY`. For example, `(and t t t)` will work as expected. If you need to apply different conditions dynamically, consider defining a lambda function or a list of functions and their arguments.",0.5277,[[0.25261414]],0.08254992860985035,0.2733236151603498,0.26277372262773724,0.07407407407407407,0.17518248175182483
"Does anybody know how to implement method_missing (à la Ruby) in Clojure?
E.g.
(defn method_missing [name & args]
     (foo name args))

It would be very useful for a DSL, if used correctly.
Thanks in advance!
","In Ruby, method_missing is one of the primary constructs for metaprogramming. It's tightly bound to Ruby's object oriented structure, dynamically creating methods in a class from 'metaclasses'. This can be done because in Ruby classes are objects too.
Since Clojure is a functional language, mimicking this Rubyism makes little sense. However, one of the basic idioms of Lisps (such as Clojure), is that code is data: and as code can generate data, it can generate code also. The primary way to do this metaprogramming in Lisp is macros.
I'd suggest reading more about macros and their dos and don'ts. Be advised though that just like in Ruby, dynamically generated code is generally harder to debug and maintain. Often clever use of other functional idioms can be a better structural solution.
","Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

","Clojure does not have a direct equivalent of Ruby's `method_missing` method. However, you can achieve similar behavior using dynamic dispatch with `apply` or by defining a catch-all handler in your namespace. For instance, you could define a handler for methods that are not found:

```clojure
(def *handlers* {})

(defn handle-method [name & args]
  (if-let [handler (get *handlers* name)]
    (handler args)
    (throw (NotFoundException. ",0.4904,[[0.10522339]],0.06594683513517446,0.18407239899892744,0.18999999999999997,0.0202020202020202,0.08
"I'm aware that Common Lisp has different binding environments for functions and variables, but I believe that it also has another binding environment for tagbody labels. Are there even more binding environments than this?  If so, then is it fair to categorize Common Lisp as a Lisp-2?
These question are not meant as pedantry or bike-shedding, I only want to gain a better understanding of Common Lisp and hopefully get some pointers into where to dig deeper into its spec.
","
I'm aware that Common Lisp has different binding environments for
  functions and variables,

That would be namespaces, according to the HyperSpec:

namespace n. 1. bindings whose denotations are restricted to a
  particular kind. The bindings of names to tags is the tag
  namespace.'' 2. any mapping whose domain is a set of names.A
  package defines a namespace.''

(Point 1.)

but I believe that it also has another binding environment for tagbody
  labels. Are there even more binding environments than this?

Yes, there are more namespaces. I even remember a little snippet exposing most of them, but unfortunately, I can't find it anymore¹. It at least exposed variable, function, tag, and block namespaces, but maybe also types and declarations were included. There is also another SO answer that lists these namespaces.

If so, then is it fair to categorize Common Lisp as a Lisp-2?

In the comments to the above linked answer, Rainer Joswig agrees that the ""general debate is about Lisp-1 against Lisp-n"".
The ""2"" might be due to the relative importance of the distinction between value and function slots, or because the objects of the other namespaces aren't first-class objects. For example in the Gabriel/Pitman paper referenced in the other answer:

There is really a larger number of namespaces than just the two that
  are discussed here. As we noted earlier, other namespaces include at
  least those of blocks and tags; type names and declaration names are
  often considered namespaces. Thus, the names Lisp1 and Lisp2, which we
  have been using are misleading. The names Lisp5 and Lisp6 might be
  more appropriate.

and:

In this paper, there are two namespaces of concern, which we
  shall term the ""value namespace"" and the ""function namespace."" Other
  namespaces include tag names (used by TAGBODY and GO) and block names
  (used by BLOCK and RETURN-FROM), but the objects in the location parts
  of their bindings are not first-class Lisp objects.


¹) PAIP, p. 837:
(defun f (f)
  (block f
    (tagbody
     f (catch 'f
         (if (typep f 'f)
             (throw 'f (go f)))
         (funcall #'f (get (symbol-value 'f) 'f))))))

","This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 
Am I misunderstanding how substitute-if works or misunderstanding the representation of the list?

Probably the latter.
#1=... marks a spot in the data structure and #1# refers back to it. The idea is to show that both elements refer to the same list. (See also http://www.lispworks.com/documentation/HyperSpec/Body/02_dhp.htm.)
It's like:
(let ((x '(0)))
  (list '(1) x '(3) x))

Because they refer to the same object, if you were to modify the second list in place, the modification would also show up in the fourth list.
 You are comparing a list containing 1 & 2 with a list containing the symbols a & b. Symbols are legitimate values in Clojure. '(a b) is equivalent to (list 'a 'b) not (list a b).
 (= '(1 2) (list a b))

Is probably the comparison you want.
 Common Lisp (the standard) offers time, which

prints various timing data and other information to trace output

Implementations usually provide more profiling tools which will tell you more detailed information about the function calls &c.
There is also a portable profiler called Metering.
 According to https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Lexical-Binding.html, even when lexical-binding is non-nil, special variables (like x since it was defined with defvar) are still dynamically bound.
 According to wikipedia:

Whether a separate namespace for functions is an advantage is a source of contention in the Lisp community. It is usually referred to as the Lisp-1 vs. Lisp-2 debate. Lisp-1 refers to Scheme's model and Lisp-2 refers to Common Lisp's model.

It's basically about whether variables and functions can have the same name without clashing.   Clojure is a Lisp-1 meaning that it does not allow the same name to be used for a function and a variable simultaneously.
","Common Lisp does indeed have multiple binding environments. In addition to the global environment for variables and functions (which aligns with the idea of a Lisp-2), there are local binding environments such as those created by LET, FLET, LABELS, and other special forms. These local bindings create scopes where variables can be bound independently of any external definitions.

Regarding tagbody labels, these are indeed part of their own lexical scope within the tagbody form, but they do not represent a separate binding environment for variables or functions in the same sense as LET or FLET.

As for whether Common Lisp is categorized as a Lisp-2 language, it primarily aligns with this category due to its use of distinct namespaces for variables and functions. However, the existence of local scopes such as those provided by FLET and LABELS can sometimes blur this distinction. The debate around Lisp-1 vs. Lisp-2 largely centers on the naming collision between global functions and local variables within a single namespace.

To explore these concepts more deeply, you might want to look into Common Lisp HyperSpec, particularly sections related to scope and binding (such as lexical scoping rules). Additionally, resources like ",0.5579,[[0.46756248]],0.09088225430375022,0.20072683122450605,0.35081374321880654,0.07622504537205081,0.1518987341772152
"I found a LISP 1.5 Manual with some code in it.
This one is from Section 1.2
Examples

    cons[A;B]=(A . B)

From reading through the manual it looks like the function cons is taking two atoms as input arguments, A and B, and outputting an S-expression, (A . B).
Question:
How do I put the code cons[A;B] in a repl, run it, and see the output (A . B)?
I'm expecting to do something like:
~ $ lisp1.5
> cons[A;B]
=> (A . B)

For example, if I went to https://www.ruby-lang.org/en/ and saw some code, I would copy it, type irb into my shell and paste it.

~ $ irb
irb(main):001:0> puts ""Hello World!""
Hello World!
=> nil

","Section 1.2 of the manual explains that this is only a notation, used to help readers distinguish between functions and S-expressions (emphasis mine).

We shall introduce some elementary functions of S-expressions. To distinguish
  the functions from the S-expressions themselves, we shall write function names in
  I lower case letters, since atomic symbols consist of only upper case letters. Furthermore,
  the arguments of functions will be grouped in square brackets rather than
  parentheses. As a separator or punctuation mark we shall use the semicolon. 

It is followed by an example:
cons[A ; B] = (A . B)

The manual introduces Lisp, its evaluation model, the compiler, etc. 
The above is the mathematical definition of cons, where A and B are metavariables: for all values A and B, the application of cons on A and B is a cons-cell where the CAR part is A and the CDR part B. If someone developed a denotational semantics to express Ruby's evaluation model, you would have the same kind of definitions. You can convert this notation if you want, i.e. you write (cons 1 2) to test it concretely. But the 1.5 manual is arguably not the best starting point for learning Common Lisp, as standardized since 1994. You could try the following ones, instead:

Practical Common Lisp, Peter Seibel
Paradigms of Artificial Intelligence Programming, Peter Norvig

Please consult Cliki, the Common Lisp wiki.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You just want something like this:
#!/bin/sh
clisp > OUTPUTFILE 2>&1 << EOF
(load ""11.1"")
(make)
EOF 

",Answer not found.,0.3498,[[0.01186393]],4.884040838667476e-39,0.004211412929037693,0.008368200836820085,0.0,0.008368200836820085
"I'm running the following code on Emacs Lisp Interaction:
(defun square (x) (* x x))
(square (square (square 1001)))

which is giving me 1114476179152563777. However, the ((1001^2)^2)^2 is actually 1008028056070056028008001. 
How is this possible?
","Emacs Lisp doesn't implement bignums, it uses the machine's integer type. The range of integers it supports is between most-negative-fixnum and most-positive-fixnum. On a 64-bit system, most-positive-fixnum will be 261-1, which has about 20 decimal digits. 
See Integer Basics in the Elisp manual.
The correct result of your calculation is 25 digits, which is much larger than this. The calculation overflows and wraps around. It should be correct modulo 262.
You could use floating point instead. It has a much larger range, although very large numbers lose precision.
(square (square (square 1001.0)))
1.008028056070056e+24

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You can nest two maps to achieve the desired effect:
(map (lambda (e)
       (map (lambda (f) (f e))
            myfuncs))
     mylist)

In the above mylist is the input list and myfuncs is the list of functions. For example, these lists:
(define myfuncs (list sqrt square cube))
(define mylist '(1 2 3))

... Will produce this output:
'((1 1 1) (1.4142135623730951 4 8) (1.7320508075688772 9 27))

 In the book, authors have an example of formulating an iterative process for computing the Fibonacci numbers.
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))

The point here is that use two parameter a and b to memorise f(n+1) and f(n) during computing. The similar could be applied: we need a, b, c to memorise f(n+2), f(n+1) and f(n)
;; an interative process implementation                                                                                                                       
(define (f-i n)                                                                                                                                               
  ;; f2 is f(n+2), f1 is f(n+1), f0 is f(n)                                                                                                                   
  (define (interative-f f2 f1 f0 count)                                                                                                                       
    (cond                                                                                                                                                     
      ((= count 0) f0)                                                                                                                                         
      (else (interative-f                                                                                                                                      
              (+ f2 (* f1 2) (* f0 3))                                                                                                                          
              f2                                                                                                                                                
              f1                                                                                                                                                
              (- count 1)))))                                                                                                                                   
  (interative-f 2 1 0 n))             

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

","The discrepancy arises due to integer overflow. Emacs Lisp uses arbitrary-precision integers for most operations, but there might be a limit on how large an integer can be before it overflows and wraps around, leading to incorrect results. In this case, the result is likely due to the limitations of the underlying system's integer representation rather than a flaw in your code.",0.5468,[[0.32879125]],0.11956225947625246,0.23953654621609108,0.3764705882352941,0.05952380952380952,0.15294117647058825
"Whats is the best way to execve() from lisp code in SBCL lisp implementation? Or maybe there is one good way working with all implementations?
","There is external-program that provides a portable way to run well... external programs in Common Lisp. It does the job for me, abstracting away the trivialities of the various interfaces provided by compilers is often a good choice, and in regard to the time execve will take the ""performance"" loss if there is any is really not relevant here.
If you really only target SBCL you have sb-ext:run-program which is really a complicated execve. In my experience it still runs programs through /bin/sh and may do PATH lookup anyway so it might not end up being exactly an execve.
","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Another simple way is to have Lisp running a HTTP server and contact Lisp from the outside via HTTP requests.
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 One option is to put (sb-ext:disable-debugger) early in your startup function. When an error occurs and there is no handler, SBCL will print an error and a backtrace and exit.
Another option is to write a function that does what you want on error and set it as your debugger hook; see command-line-debugger in buildapp itself for an example.
 If you use SBCL, you have integrated support for unicode.
String operations
Try to sort with unicode< instead of string-lessp.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
","Unfortunately, there isn't a direct equivalent of execve() in Lisp. However, you can achieve similar functionality by dynamically loading and running code from a file using functions like LOAD or EVAL. For example, to load and execute a file, you could use (LOAD \",0.5211,[[0.1300767]],0.0388523746140151,0.16019417475728157,0.21621621621621623,0.0136986301369863,0.12162162162162163
"Suppose that the following macro execution:
(make-model '((1 2)(3 4)(5 6)(7 8)))

, can generate the following list:
((MAKE-INSTANCE 'MODEL :NAME 7 :ID 8) 
 (MAKE-INSTANCE 'MODEL :NAME 5 :ID 6)
 (MAKE-INSTANCE 'MODEL :NAME 3 :ID 4) 
 (MAKE-INSTANCE 'MODEL :NAME 1 :ID 2))

If I store the result in a parameter (e.g *test*), how could I get lisp to execute the four commands in the list?
","You can use eval:
(mapcar #'eval *test*)

However, this is a suboptimal solution.
You would be much better off saving either a lambda: 
(defmacro make-model-lambda (args)
  (list* 'lambda () (apply #'make-model args)))
(defparameter *test* (make-model-lambda ....))
(funcall *test*)

or just the list of args themselves:
(defparameter *test*
  (mapcar (lambda (name-id)
            (list 'model :name (first name-id) :id (second name-id)))
          '((1 2)(3 4)(5 6)(7 8))))
(mapcar #'apply *test*)

","You have to evaluate each argument recursively, something like:
template <typename T>
auto eval(T t)
{
    return t;
}

template <typename ...Ts>
auto eval(std::tuple<Ts...> tuple)
{
    return std::apply([](auto... args){ return std::invoke(eval(args)...); }, tuple);
}

Demo.
 The instance is passed as the first argument of initialize-instance.
(defmethod initialize-instance :around ((created myclass) ...)
  ;; do something with created
  created)

 To turn make-canned-format into a function, you need to replace
function with
compile or
(coerce (lambda ...) 'function).
However, your refactoring is misguided.
make-canned-format should be a macro - this way it will produce
a closure in the current compilation environment.
The function, however, will produce a closure in the global environment.
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 Because a variable isn't a first-class value that you can pass to another function. In 3.4, the authors implement a make-mutex function that uses clear! as a helper function, which takes a cell. If the cell were represented by a mutable variable, then clear! would have to be defined inside make-mutex! to close over that variable. The same goes for the test-and-set! helper function.
They also could have used, say, a box instead of a cons cell.
 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

","You can use the `mapcar` function to execute each command in the list. Assuming *test* is a list of functions that return make-instance forms, you would do something like this:\n\n```\nlisp\n(mapcar (lambda (command) (funcall command)) *test*)\n```\nThis will call each function stored in the list and execute it.",0.5502,[[0.26654677]],0.10812431312908491,0.21085160728167363,0.3100775193798449,0.11023622047244094,0.21705426356589147
"The code below keeps throwing the following error: 
 caught ERROR:

illegal function call

     (LET ((SOLUTION 'NIL) (FIRST 0) (SECOND 0))
       (DOLIST (EL LST)
         (IF (NUMBERP EL)
             (PUSH EL SOLUTION)
             ((SETF #) (SETF #) (PUSH # SOLUTION))))
       (CAR SOLUTION))

Can anyone see why? Syntactically I can't see anything wrong with it.
Note: I'm using sbcl.
My code:
(defun evalpostfix (lst)
  (let ((solution '())
        (first 0)
        (second 0))
    (dolist (el lst)
      (if (numberp el) ;if
          (push el solution) ;then
          ((setf second (pop solution)) ;else
             (setf first (pop solution))
             (push (funcall el first second) solution))))
    (car solution)))

","((setf second (pop solution)) - two opening parentheses? Why? The syntax for IF with an else form is:
(if test-form then-form else-form)

A form cannot begin with two parentheses - there is only one exception: ((lambda (x) (+ x 1)) 2).
If you want to group more than one expression use something like (progn a b c ... z).
","Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The way you are doing it is tree recursive and its running time will blow up exponentially. The link has efficient alternatives. But, if you want to keep the whole sequence you could do something like,
(defun fib (num)
  (let (seq)
    (labels ((helper (n)                                  ; define local helper function
               (when (<= n num)                           ; stop when reached NUM
                 (if (< n 3) (push 1 seq)
                     (push (+ (car seq) (cadr seq)) seq)) ; sum of previous 2
                 (helper (1+ n)))))                       ; recurse
      (helper 1))                                         ; start from first fib number
    (nreverse seq)))                                      ; reverse the result

 Your recursive addNode (better called add-node if you are a lisper) needs a stop condition.
E.g.,
         (add-node (edge-list)
           (push (car (pop edge-list)) nodes)
           (when edge-list
             (add-node (cdr edge-list))))

Note that there is no reason to use recursion here, a simple mapcar would do just fine:
(defun extract-nodes (el)
  (mapcar #'car el))

 As mentioned in first comment it is necessarily to use (list a b c) form.
","The error you're encountering is due to a misuse of the SETF form within your conditional. The line `((SETF #) (SETF #) (PUSH # SOLUTION))` is invalid because it incorrectly uses multiple SETF forms without properly defining what variables or values they should set. In your corrected code, the equivalent operation would be handled by setting either `first` or `second` based on their current state and then performing the push operation accordingly. Here's a revised version of your function to fix this issue:\n\n```lisp\n(defun evalpostfix (lst)\n  (let ((solution '())\n        (first 0)\n        (second 0))\n    (dolist (el lst)\n      (if (numberp el) ; if\n          (push el solution) ; then\n          (progn ; else\n            (setf second (pop solution)) ; pop the second operand\n            (setf first (pop solution))   ; pop the first operand\n            (let ((result (funcall el first second)))\n              (push result solution)))))\n    (car solution)))\n",0.5074,[[0.21230046]],0.061742025685719404,0.2873096431120081,0.18446601941747573,0.02941176470588235,0.07766990291262137
"I am new to Clojure and Lisp, but love it so far. I am currently trying to understand lazy-seq's and Clojure's ability to define infinite sequences. I have the following code:
(defn geometric
  ([] geometric 1)
  ([n] (cons n (lazy-seq (geometric (* n 1/2))))))

If I run:
(geometric)

in my REPL, it returns 1, as expected. However, if I run,
(take 10 (geometric))

I get the following error:
IllegalArgumentException Don't know how to create ISeq from:
java.lang.Long  clojure.lang.RT.seqFrom

What I expect to get is:
(1 1/2 1/4 1/8 1/16 1/32 1/64 1/128 1/256 1/512)

Why am I getting this error? If I've understood correctly, one should be able to cons n to the lazy-sequence, and take should return the first ten values of the sequence, evaluated recursively.
","You have a small typo in your code:
(defn geometric
  ([] (geometric 1)) ;; notice the added parens around geometric 1
  ([n] (cons n (lazy-seq (geometric (* n 1/2))))))

Without this fix (geometric 1) was working because the implementation was to evaluate expression geometric (just a function value) which was discarded, then 1 expression was evaluated and returned as the function result (it was the last expression in this arity function body).
Now it works as expected:
(take 1 (geometric))
;; => (1)

(take 5 (geometric))
;; => (defn geometric
  ([] geometric 1)
  ([n] (cons n (lazy-seq (geometric (* n 1/2))))))

Notice that you cannot just call (geometric) safely in REPL as it will  try to evaluate an infinite sequence.
","You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You will somehow need to print the whitespace yourself.  Simple extension of your code:
(loop for i from 1 to 5
      do (princ i)
         (princ #\space))

(Note that I used princ instead of prin1.)
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I assume you're using Common-Lisp, which has separate namespaces for variable and function names.  In order to memoize the function named by a symbol, you need to change its function binding, through the accessor `fdefinition':
(setf (fdefinition 'collatz-steps) (memoize #'collatz-steps))

(defun p14 ()
  (let ((mx 0) (my 0))
    (loop for x from 1 to 1000000
          for y = (collatz-steps x)
          when (< my y) do (setf my y mx x))
    mx))

 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
","The issue lies in how you're using `lazy-seq`. In your function, `n` is a long value (which is the default for integer literals in Clojure), and when you use `(cons n (lazy-seq ...))`, it tries to create an ISeq from `n`, which fails because `n` is not directly compatible with sequence operations. To fix this, you should ensure that all elements in your sequence are of a type that can be used as the first element of a sequence, typically symbols or numbers. You can cast `n` to a rational number (e.g., using `(/ n 1)` for division by 1) to keep it as a fraction throughout the sequence. Here's how you can modify your function:\n\n```clojure\n(defn geometric\n  ([] (geometric 1))\n  ([n] (cons (/ n 1) (lazy-seq (geometric (* n 1/2))))))\n\n(geometric)\n(take 10 (geometric))\n```\nThis should give you the expected output: `(1 1/2 1/4 1/8 1/16 1/32 1/64 1/128 1/256 1/512)`.",0.6012,[[0.44364157]],0.25781852551699364,0.38929779979944146,0.4166666666666667,0.13286713286713286,0.2152777777777778
"I wonder why in the following code, d is not being consed into x.
Any hints are much appreciated.
(defun it (x) 
  (setq f '(a b c))
  (dolist (d f)
    (cons d x))
  (print x))

Thank you!
","I don't know a lot about LISP, but here's a few things I think I know that might help you:

(cons d x) doesn't put d ""into"" x; it creates a new value that consists of d, followed by the contents of x. If x is a list, then (cons d x) will also be a list.
(cons d x) doesn't change anything; it creates a value, but if you don't capture that value, it gets discarded again. In particular, that expression doesn't change x.

","You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 Given that this expression is evaluated only for its effect (printing a message), you should explicitly return a value (any value!) as the result of the let form:
(let ((x 1))
  (cond ((< x 2)  
         (display ""hooray"")
         (newline))
        (else 
         (display ""bummer"")
         (newline)))
  'ok)

Now we'll get:
hooray
'ok

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Here's how:

Click on the ""run"" button, as you discovered
Press Esc  + p

And this is the relevant page in the documentation.
","In your function `it`, the variable `x` is being modified by the `cons` operation within the dolist loop. However, the result of `cons d x` is not being stored or returned in any way. The `cons` operation creates a new cons cell but does not modify `x`. To see the effect of each `cons` operation, you should use `(setf x (cons d x))`. This will update `x` with each iteration of the loop.",0.5707,[[0.23295359]],0.16709212074879268,0.2771598050302463,0.3048780487804878,0.09876543209876543,0.17073170731707318
"As I've started learning about lisp, emacs, and ess (Emacs Speaks Statistics), I've come across this concept of inferior-this-or-that. For instance, there's an inferior-ess-mode, inferior-lisp, and Inferior Emacs Lisp Mode.
In all these cases, it seems that some interpreted language is running within emacs, and you can interact with it within a buffer. But why are they inferior and what are they inferior to?
","An inferior mode refers to a mode which run as a subprocess of emacs.  
For example, this is my process tree when I start emacs:
$ pstree 62238
--= 62238 smt /usr/local/Cellar/emacs/HEAD/Emacs.app/Contents/MacOS/Emacs

After I run an inferior tcl shell, this is what my process tree looks like:
$ pstree 62238
-+= 62238 smt /usr/local/Cellar/emacs/HEAD/Emacs.app/Contents/MacOS/Emacs
 \-+= 62359 smt /bin/sh /usr/bin/wish
   \--- 62361 smt /usr/bin/../../System/Library/Frameworks/Tk.framework/Version

Another way of saying this might be that ""inferior"" is synonymous with the prefix ""sub-"" in this context.
","An inferior mode refers to a mode which run as a subprocess of emacs.  
For example, this is my process tree when I start emacs:
$ pstree 62238
--= 62238 smt /usr/local/Cellar/emacs/HEAD/Emacs.app/Contents/MacOS/Emacs

After I run an inferior tcl shell, this is what my process tree looks like:
$ pstree 62238
-+= 62238 smt /usr/local/Cellar/emacs/HEAD/Emacs.app/Contents/MacOS/Emacs
 \-+= 62359 smt /bin/sh /usr/bin/wish
   \--- 62361 smt /usr/bin/../../System/Library/Frameworks/Tk.framework/Version

Another way of saying this might be that ""inferior"" is synonymous with the prefix ""sub-"" in this context.
 
Am I misunderstanding how substitute-if works or misunderstanding the representation of the list?

Probably the latter.
#1=... marks a spot in the data structure and #1# refers back to it. The idea is to show that both elements refer to the same list. (See also http://www.lispworks.com/documentation/HyperSpec/Body/02_dhp.htm.)
It's like:
(let ((x '(0)))
  (list '(1) x '(3) x))

Because they refer to the same object, if you were to modify the second list in place, the modification would also show up in the fourth list.
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 It stands for Aesthetic.  A-formatted output is not escaped.  See http://www.lispworks.com/documentation/HyperSpec/Body/22_cda.htm
Incidentally, S stands for Standard rather than S-expression.
 Yes, it's possible. The easiest way would be to simply redefine the class. You do that by issuing another call to DEFCLASS. If you want to do more complicated things, you have to resort to the MOP (MetaObject Protocol). Essentially everything you'd ever want to do is possible using the MOP, but I would need more detailed information as to what it is you're trying to do in order to explain it further.
 Per R6RS, ... must always follow some identifier to get its ""zero or more"" meaning (it behaves like the Kleene star), so ... and pat ... mean different things: the former is just a literal ... symbol as far as syntax-rules is concerned.
In your example, both forms seem to be the same, but that's because the pattern (_ e1 e2 ...) only fires when there are two or more conjuncts (arguments to and) anyway, since the second pattern (_ e) already handles the case where there's only one conjunct. It doesn't always work this way, and Dybvig apparently found it cleaner to write an explicit ""two or more"" clause rather than ""exactly one"" and ""one or more"" clauses.
","The term 'inferior' in this context refers to a subprocess running inside Emacs that allows you to interact with another interpreted language (like R or Lisp) within an Emacs buffer. These modes are called 'inferior' because they run as a separate process under the control of Emacs, which acts as the parent process. This means you can execute code in these languages directly from within your Emacs editor without leaving it, enhancing productivity and workflow efficiency. Essentially, they are inferior (subordinate or secondary) to the main Emacs process but still integral parts of it.",0.5034,[[0.30513976]],0.13833541674589758,0.23770824867939858,0.3248730964467005,0.08205128205128205,0.15228426395939085
"I want to know how to embed a lisp interpreter into a gui application, i.e. something like what pyshell does for Python.
","Some options:

Write the complete application including the GUI in Lisp: lots of Lisp systems support that
Write the application in Lisp and link C code to it, if you need to call some external GUI libraries: Lisp systems can load and call C (and compatible) libraries.
Embed Lisp into your application: ECL (Embeddable Common Lisp) is an obvious choice. LispWorks (commercial) and Allegro CL (commercial) can deliver Lisp code as shared libraries. You can then load such a shared library into your program.

","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 In Python you create an object by calling the constructor, a function that has the same name as the class. The exact same applies in Hy.
(import sys)
(import [PySide.QtGui [QApplication]])

(setf app (QApplication sys.argv))

Notes:

You assign the object created with setf
Be sure to import all the necessary modules

 Yes - the important thing is not the language but whether the environment in which it runs has permission to modify files.
The AutoCAD W32/Bursted virus was written in a Lisp variant called AutoLISP.
See also:

Debugging what this LISP Virus is doing

 It's very easy. This is the base case:
(remove-nth 0 '(2 3)) ; => (3)

And the default case:
(remove-nth 1 '(1 2 3))         ; ==
(cons 1 (remove-nth 0 '(2 3)))

The only thing left for you to do is to actually implement it!
There is a third case. What if the list is nil? In the strictest sense you cannot do the job and you should signal an error or perhaps there isn't anything to do so it's ok to then have it as a base case that evaluates to '() so that (remove-nth 5 '(1 2)) ; ==> (1 2)
 The reason the ANSI CL standard does not specify the algorithmic complexity of 
library functions is that it is not its job. The standard describes the behavior, and leaves performance to the implementation-specific docs. 
It was assumed that the best theoretical performance will be provided by all implementations (otherwise no one would use it).
To answer your specific question, gethash is O(1) in all implementations.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
","To embed a Lisp interpreter into a GUI application similar to how PyShell works with Python, you can use tools like SBCL (Steel Bank Common Lisp) or other Lisp environments that support embedding. For example, in Hy (a Lisp dialect), you might use the `hyscript` library which allows for dynamic evaluation of Hy code within your application. Additionally, you can leverage the capabilities provided by GUI frameworks such as Qt (via PySide/PyQt). Here's a basic example using Hy and PySide to create a simple GUI with embedded Lisp evaluation:\n\n```python\n(import sys)\n(import [PySide.QtGui [QApplication]])\n\n(setf app (QApplication sys.argv))\n\n(defclass LispEvaluator (QObject):\n  \",0.5516,[[0.35506144]],0.11992010459124396,0.3239074550128535,0.31155778894472363,0.03045685279187817,0.1407035175879397
"I've been looking everywhere for a priority queue implementation for Common Lisp that works, and so far, I've not had much luck. As I'm fairly new to Common Lisp, whenever I see a huge warning/error dump from the REPL, I'm not really sure what to do about it. This isn't helped by the fact that all the priority queue implementations I've found seem to be really old.
Could someone suggest one to me?
","A quick search for ""queue"" on http://quickdocs.org turned up a few choices.  I looked at the description and API of priority-queue and it seems sensible.  You can get it from Quicklisp.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 The primary problem seems to be that you need to reset the file position after each pass.  The infinite loop happens because you never check for the file end (and suppressed the signal).
Side hint: use dolist instead of that dotimes and nth construction.
If you do not want to make n passes (n being the number of patches), and you cannot hold the entire contents in memory, you could write the patches to temporary files, then concatenate them in the desired order.  If you also do not have enough disk space, it becomes an in-place sort problem with varying element sizes, which is a bit more involved.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 A quick search for ""queue"" on http://quickdocs.org turned up a few choices.  I looked at the description and API of priority-queue and it seems sensible.  You can get it from Quicklisp.
","Based on your requirements and the context provided, you might want to consider using the 'priority-queue' library from Quicklisp. It seems to be well-maintained and fits your needs for a priority queue implementation in Common Lisp. You can add it to your project by including \`(ql:quickload \",0.6085,[[0.31133396]],0.16499948928709535,0.32499999999999996,0.38554216867469876,0.09876543209876543,0.21686746987951805
"I'm trying to emulate Lisp-like list in JavaScript (just an exercise with no practical reason), but I'm struggling to figure out how to best represent an empty list.
Is an empty list just a nil value or is it under the hood stored in a cons cell?
I can:
(car '())
NIL
(cdr '())
NIL

but an empty list for sure can not be (cons nil nil), because it would be indistinguishable from a list storing a single nil. It would need to store some other special value.
On the other hand, if an empty list is not built from a cons cell, it seems impossible to have a consistent high-level interface for appending a single value to an existing list. A function like:
(defun append-value (list value) ...

Would modify its argument, but only if it is not an empty list, which seems ugly.
","An empty list is simply the nil symbol (and symbols, by definition, are not conses). car and cdr are defined to return nil if given nil.
As for list-mutation functions, they return a value that you are supposed to reassign to your variable. For example, look at the specification for the nreverse function: it may modify the given list, or not, and you are supposed to use the return value, and not rely on it to be modified in-place.
Even nconc, the quintessential destructive-append function, works that way: its return value is the appended list that you're supposed to use. It is specified to modify the given lists (except the last one) in-place, but if you give it nil as the first argument, it can't very well modify that, so you still have to use the return value.
","An empty list is simply the nil symbol (and symbols, by definition, are not conses). car and cdr are defined to return nil if given nil.
As for list-mutation functions, they return a value that you are supposed to reassign to your variable. For example, look at the specification for the nreverse function: it may modify the given list, or not, and you are supposed to use the return value, and not rely on it to be modified in-place.
Even nconc, the quintessential destructive-append function, works that way: its return value is the appended list that you're supposed to use. It is specified to modify the given lists (except the last one) in-place, but if you give it nil as the first argument, it can't very well modify that, so you still have to use the return value.
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 The message seems pretty clear to me: you are trying to get the first element of an empty list, which conflicts with your specification.
Based on this reference, it seems that first expects a non-empty list, whereas car returns nil when your input is nil.
Either you handle the nil case explicitely with an endp test or you use car instead of first.
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 When evaluated, '(nil) and (list nil) produce similar lists, but the former can be considered constant when present in source code. You should not perform any destructive operations on a constant quoted list in Common Lisp. See http://l1sp.org/cl/3.2.2.3 and http://l1sp.org/cl/quote. In particular, the latter says ""The consequences are undefined if literal objects (including quoted objects) are destructively modified.""
","In Lisp, an empty list is represented by the symbol nil. This is consistent with your observations that (car '()) and (cdr '()) both return NIL. The key point is that nil itself does not need to be stored in a cons cell; it's simply the value used to represent an empty list. When you want to append a single value to an existing list, you can use the function like this: (append-value lst val). If lst is null (nil), append-value will create a new list with val as its only element without modifying anything because nil cannot be modified in-place. This approach ensures that your high-level interface remains clean and consistent.",0.5731,[[0.52708984]],0.1975130808520224,0.3100522193211488,0.44015444015444016,0.09338521400778212,0.23166023166023167
"How to sort a list with sublists?
(setq list '((0) (1) (2) (0 1 5) (0 1 3) (0 1 5) (0 3 0) (0) (1) 
             (2 7 19) (0 0 3 0)))

; restricting the sort to only the first element:

(sort (copy-seq list) #'< :key #'car)

--> ((0) (0 1 5) (0 1 3) (0 1 5) (0 3 0) (0) (0 0 3 0) (1) (1) (2) (2 7 19))

The output I am looking for is sort on all elements of the sublist:
--> ((0) (0) (0 0 3 0) (0 1 3) (0 1 5) (0 1 5) (0 3 0) (1) (1) (2) (2 7 19))

","Start by defining a function that determines whether one list is less than another.  The following example assumes that the lists can only contain numbers:
(defun list< (a b)
  (cond ((null a) (not (null b)))
        ((null b) nil)
        ((= (first a) (first b)) (list< (rest a) (rest b)))
        (t (< (first a) (first b))) ))

Armed with this function, you can now sort the list of lists.
(sort (copy-seq list) #'list<)

","the listp tells you that :
(listp (elt '(a (b c) d) 1))

 Open the file and read in the data:
(with-open-file (f ""file.txt"")
  (read f))

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 As mentioned in first comment it is necessarily to use (list a b c) form.
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
",(define (length lst)\n  (if (null? lst)              ; if the list is empty\n      0                          ; return 0\n      (+ 1 (length (cdr lst)))))) ; otherwise add 1 and advance the recursion over the rest of the list,0.631,[[0.2609637]],0.17006047572425828,0.36642995307779824,0.19417475728155337,0.05940594059405941,0.1553398058252427
"To short-circuit a C function (for example, for testing purposes), I can put an early return in there. For example:
int main(void) {
    puts(""Hello"");
    return;

    ...bunch of other code...
}

Or do a sys.exit(0) in python. Is there a way to do this in DrRacket / Scheme? As often I will have a workbook with a few hundred lines of code and I only want the top few functions to run before exiting. For example:
#lang sicp

(define (filtr function sequence)
  (if (null? sequence) nil
      (let ((this (car sequence))
            (rest (cdr sequence)))
        (if (function this) (cons this (filtr function rest))
            (filtr function rest)))))
              
(filtr  (lambda (x) (> x 5)) '(1 2 3 4 5 6 7 8 9))   
     
(exit)  ; ?? something like this I can drop in to terminate execution?

...200 more lines of code...

Is there a way to do that here?
","#lang racket can do that with the function named... exit. Try:
#lang racket

(display 1)
(exit 0)
(display 2)

#lang sicp doesn't have exit, but you can require it from Racket:
#lang sicp

(#%require (only racket exit))

(display 1)
(exit 0)
(display 2)

Early return from a function can be done using continuation. For example, with the let/cc operator:
#lang racket

(define (fact x)
  (let/cc return
    (if (= x 0)
        1
        (begin
          (display 123)
          (return -1)
          (display 456)
          (* x (fact (- x 1)))))))

(fact 10)
;; display 123
;; and return -1

Or equivalently, with call-with-current-continuation, which exists in both #lang racket and #lang sicp:
(define (fact x)
  (call-with-current-continuation
   (lambda (return)
     (if (= x 0)
         1
         (begin
           (display 123)
           (return -1)
           (display 456)
           (* x (fact (- x 1))))))))

","I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 This is an often asked question. There are possibly duplicates of this on Stackoverflow.
The output can be buffered.
You then need to call the standard Common Lisp function FINISH-OUTPUT to force the IO system to write any pending output.
After that, read.
 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 You got rid of the msg parameter, but you were still trying to use it. Use let to bind a local variable to that value.
(defun timed-notification()
  (interactive)
  (let ((msg ""Take a break, time's up!""))
    (run-at-time 25 nil (lambda (mess) (terminal-notifier-notify ""pomodoro"" mess)) msg)))

","In DrRacket / Scheme, you can use `(exit)` to terminate the execution of your program. This is similar to `sys.exit(0)` in Python or putting an early return in C. For example, if you only want the top few functions to run and then exit, you can insert `(exit)` after those functions. Here's how you could modify your given code snippet to include this behavior:\n\n```scheme\n#lang sicp\n(define (filtr function sequence)\n  (if (null? sequence) nil\n      (let ((this (car sequence))\n            (rest (cdr sequence)))\n        (if (function this) (cons this (filtr function rest))\n            (filtr function rest)))))\n\n(filtr (lambda (x) (> x 5)) '(1 2 3 4 5 6 7 8 9))\n(exit)\n\n...200 more lines of code...\n```\nNote that using `(exit)` will terminate the program immediately, so be careful where you place it.",0.5928,[[0.1895289]],0.19479326974444855,0.339101279911197,0.259927797833935,0.03636363636363637,0.1299638989169675
"I am looking for a version of Scheme or even LISP that I can use to recover some lost Lisp development skills.  Some web capabilities would be nice but not essential. 
I've looked at Plt and MIT scheme and, while both look pretty good, the Plt seems to be more feature rich.  I've also looked at Lisp implementations but all of the seem quite expensive.
I favor free/inexpensive implementations as this is truly likely to just be occasional hobby programming. What recommendations would you have?
","I'd go with Racket. It may not be as fast as SBCL, but it does have excellent libraries and documentation, as well as an integrated environment that's designed to get you developing and running Scheme programs right out of the gate. What I really like about Racket's IDE, DrRacket, is what you don't have to do—you don't have to learn Emacs, you don't have to learn SLIME, you don't have to worry about hunting down third-party libraries, as virtually all libraries meant for Racket can be found in packages. All in all, it really cuts down on the learning curve and allows you to focus on the actual task at hand: writing great code.
Also, it comes with a web server if you want to make Racket-powered websites (which I'm currently looking into).
","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
 PLT Scheme is a very good self-contained Scheme development environment available for several platforms including Windows. It comes with several flavors of Scheme, an IDE with a debugger, and a ton of Scheme libraries for real-world programming.
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 On anything but Gentoo (which has a very well maintained Lisp overlay), I would use clbuild for now.  I have the hope that XCVB will be usable soon.
 Use MIT Scheme.
It's recommended by the authors of SICP, and is used at MIT for the 6.001: Structure and Interpretation of Computer Programs course.
","Based on your requirements for a Scheme or Lisp implementation that can help you recover lost development skills and is free/inexpensive, I recommend using MIT Scheme. It's highly regarded by the authors of SICP and used at MIT for their introductory course. Additionally, it provides a robust environment for programming in both Scheme and Common Lisp. While PLT Scheme (now Racket) offers more features, MIT Scheme is still a strong choice, especially if you're looking for a lightweight and cost-effective solution.",0.5583,[[0.19434051]],0.06409771116199038,0.21032831737346103,0.22707423580786026,0.00881057268722467,0.12227074235807858
"I have to do this:
(or a w (or f r t) r (not p) (or (not p) a))

==> (a w f r t r (not p) (not p) a)

I've done this function:
(defun remove-or (x)
  (cond ((null x) x)
    ((atom x) x)
    ((and (listp x) (eq (first x) 'or)) (remove-or (cdr x)))
    (T (cons (remove-or (first x))
             (remove-or (rest x))))))

But the result is: 
(or a w (or f r t) r (not p) (or (not p) a))

==> (a w (f r t) r (not p) ((not p) a))

How can I delete the ""( )"" ?
","You need to check earlier for or-sublists like '((or ...) ...) so you can transform it into '(... ...).
The condition for it, simply is: 
(and (listp lst) (listp (first lst))
     (eq (first (first lst)) 'or))

And the transformer:
(append (remove-or (rest (first lst)))
        (remove-or (rest lst)))

So this brings us to the your function with slightly modified third condition branch:
(defun remove-or (lst)
  (cond ((null lst) lst)
        ((atom lst) lst)
        ((and (listp lst) (listp (first lst))
              (eq (first (first lst)) 'or))
         (append (remove-or (rest (first lst)))
                 (remove-or (rest lst))))
        (t (cons (remove-or (first lst))
                 (remove-or (rest lst))))))

But this function will not handle a one special case: the or in the very beginning of the list: (OR a b (or (or c d) e)). But having an additional condition branch like ((and (listp x) (eq (first x) 'or)) (remove-or (cdr x))) we will remove also ors acting like a variables: (a b or c or).
So this case must be handled separately, for instance:
(defun remove-or-head (lst)
   (remove-or (if (and (listp lst) (eq (first lst) 'or))
                  (rest lst)
                  lst))

To put it all together with recursive function hidden:
(defun remove-or (lst)
  (labels ((remove-or-rec (lst)
             (cond ((null lst) lst)
                   ((atom lst) lst)
                   ((and (listp lst) (listp (first lst))
                         (eq (first (first lst)) 'or))
                    (append (remove-or-rec (rest (first lst)))
                            (remove-or-rec (rest lst))))
                   (t (cons (remove-or-rec (first lst))
                          (remove-or-rec (rest lst)))))))
    (remove-or-rec (if (and (listp lst) (eq 'or (first lst)))
                       (rest lst)
                       lst))))

","An alternative way to do the same thing:
(defun remove-all-nth (list period)
   (remove-if
    (let ((iterator 0))
      (lambda (x)
        (declare (ignore x))
        (= 0 (mod (incf iterator) period)))) list))
(remove-all-nth '(1 2 3 4 5 6 7 8 9 0) 3)
; (1 2 4 5 7 8 0)

 Based on this question it would be:
(remove-if #'evenp '(0 1 2 3))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","The issue you're encountering is due to how the function `remove-or` processes nested forms. To remove the extra parentheses, you need to ensure that when an OR form is encountered and removed, its arguments are processed recursively to flatten them out.

Here's a revised version of your function:

```lisp
(defun remove-or (x)
  (cond ((null x) nil)
        ((atom x) x)
        ((eq (first x) 'or)
         (loop for arg in (cdr x)
               append (remove-or arg)))
        (t (cons (remove-or (first x))
                 (remove-or (rest x))))))
```

This function uses a loop to process each argument of the OR form and recursively calls `remove-or` on them, effectively flattening out nested forms.

Example usage:

```lisp
(remove-or '(or a w (or f r t) r (not p) (or (not p) a)))
; => (a w f r t r (not p) (not p) a)
```

This should give you the desired output without extra parentheses.",0.6853,[[0.43102517]],0.11569682382048571,0.25042015727560846,0.32850241545893716,0.13106796116504854,0.2222222222222222
"How to get the intersection of multiple lists using elisp?  I'm a elisp newbie but I'm imagining there is some builtin function or a nicer solution using reduce.  I cobbled this together, but it seems overly complicated.
;; get the intersection of these lists
;; result should be (3 4 5)
(setq test '((0 1 2 3 4 5) (2 3 4 5 6) (3 4 5 6 7)))

(require 'cl-lib)
(cl-remove-if-not
 (lambda (x) (cl-every
         (lambda (y) (> (length (memq x y) ) 0 ) )
         (cdr test) ) )
 (car test) )
;; ( 3 4 5)

","There is a cl-intersection that takes only two operands:
(cl-intersection '(0 1 2 3 4 5) '(2 3 4 5 6))

You can use it do define your own intersection:
(defun my-intersection(l)
    (cond ((null l) nil)
          ((null (cdr l)) (car l))
          (t (cl-intersection (car l) (my-intersection (cdr l))))))

(my-intersection '((0 1 2 3 4 5) (2 3 4 5 6) (3 4 5 6 7)))

Updated
Thanks to the @Tobias comment below, you could have in the new function the same keyword parameters of cl-intersection, that is (:test :test-not :key) and propagate them to all the calls to it inside the recursion.
Here is the extended version:
(defun my-intersection(l &rest cl-keys)
    (cond ((null l) nil)
          ((null (cdr l)) (car l))
          (t (apply 'cl-intersection (car l) (apply 'my-intersection (cdr l) cl-keys) cl-keys))))

","Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 A solution that uses your initial approach is the following:
(defun max-occurrences(l)
  (let* ((occurrences (remove-duplicates 
                        (mapcar #'(lambda (elt) (cons elt (count elt l))) l) 
                        :test 'equal))
         (max-occurrence (reduce #'max occurrences :initial-value 0 :key #'cdr)))
    (mapcar #'car (remove-if-not (lambda(x) (= x max-occurrence)) occurrences :key #'cdr))))

However, this solution is not efficient, since it has a cost of O(n2) (in the initial phase, each element of the list is compared with all the others to count its frequency). 
Edited
A more efficient solution could be obtained for instance by using a hash table (with the improvement suggested in the comment by @uselpa):
(defun max-occurrences(l)
   (let* ((table (make-hash-table))
          (max-count (loop for elt in l maximize (incf (gethash elt table 0)))))
     (loop for elt being the hash-key of table using (hash-value count)
        when (= count max-count) collect elt)))

 I figured it out:
The first check of the function needed to be (null? L) as car and cdr cannot work on any empty list.
(define (remove A L)
    (cond   ( (null? L)             '() )
            ( (equal? A (car L))       (remove A (cdr L)) )
            ( (not(equal? A (car L)))  (cons (car L) (remove A (cdr L))) )
    )
)

 You're overcomplicating it. You don't need to sort the CDRs of the sub-lists returned by SPLIT-LIST, just sort the whole lists, and merge them.
(defun MSORT (L)
  (cond ((endp L) nil)
        ((endp (cdr L)) L)
        (t
         (let* ((S (SPLIT-LIST L ))
                (L1 (car S))
                (L2 (cadr S))
                (X (MSORT L1))
                (Y (MSORT L2)))
           (MERGE-LISTS X Y)))))

 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
","In Common Lisp, you can use the `reduce` function along with a helper function to find the intersection of multiple lists. Here's an example:

```lisp
(defun intersect (lst1 lst2)
  (remove-if-not (lambda (x) (member x lst2)) lst1))

(defun intersect-multiple (&rest lists)
  (apply 'reduce (lambda (acc lst) (intersect acc lst)) lists :from-end t))
```

You can then use `intersect-multiple` to find the intersection of your lists:

```lisp
(setq test '((0 1 2 3 4 5) (2 3 4 5 6) (3 4 5 6 7)))
(intersect-multiple test)
```

This will give you `(3 4 5)` as the intersection of the lists.",0.6314,[[0.22894929]],0.22452143547538303,0.2751226052836068,0.41434262948207173,0.15261044176706828,0.2310756972111554
"I have written the following macro, that defines records with a custom string representation.
(defmacro defrecord*
  [rname args]
  `(defrecord ~rname [~@args]
     Object
     (toString [_]
       ~(let [kvs (->> args
                       (map (fn [arg] [(str arg "": "") arg]))
                       (interpose "", "")
                       (apply concat))]
          `(str ~rname ""("" ~@kvs "")"")))))

However what toString returns is not quite what I am expecting.
(defrecord* Foo [bar baz]) 
(.toString (Foo. 3 4))

> ""class user.Foo(bar: 3, baz: 4)""

I'd like my toString to return Foo(bar: 3, baz: 4) in this case. What change do I need to make to get a string representation in this format?
Also what changes, if any, should I make to the above code to make it more idiomatic?
","Just replace ~rname with '~rname - you want the actual symbol Foo, not its value in the current scope, which is the class user.Foo.
You also have (apply concat) and (interpose "", "") in the wrong order - you'll be treating "", "" as a sequence, and adding \, and \space characters instead of a single string. Once you swap that, it becomes clear that you want mapcat instead of (apply concat (map ...)). So I'd replace your whole let-block with something like:
`(str '~rname
      ""("" ~@(interpose "", ""
                       (mapcat (fn [arg] [(str arg "": "") arg])
                               args))
      "")"")

Or if you really want to grind out that performance, you can compute ~(str ""("" rname) at compile-time instead of at runtime.
Please note, though, that as of Clojure 1.3 records already print in a way very similar to this, so if you're just doing this to make debugging easy, don't bother. If you're doing it because you're using .toString's output later on down the line...well, shame on whoever wrote that code, as .toString is mostly for debugging stuff.
","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

","The issue with your macro is that the `toString` method's return value is being quoted. To fix this and make your code more idiomatic, you need to remove the quotes around the generated string. Here’s how you can modify your macro:\n\n```lisp\n(defmacro defrecord* [rname args]\n  `(defrecord ~rname [~@args]\n     Object\n     (toString [_]\n       (str ~rname \",0.5858,[[0.3409524]],0.03424579808831121,0.13028273357759154,0.2531645569620253,0.01702127659574468,0.11814345991561181
"On the xkcd site today, the following appeared as a joke in a <script language=""scheme""> tag
so what does the following code do / represent?
(define
  (eval exp env)
  (cond ((self-evaluating? exp) exp)
    ((variable? exp)
      (lookup-variable-value exp env))
    ((quoted? exp)
      (text-of-quotation exp))
    ((assignment? exp)
      (eval-assignment exp env))
    ((definition? exp)
      (eval-definition exp env))
    ((if? exp)
      (eval-if exp env))
    ((lambda? exp)
      (make-procedure
        (lambda-parameters exp)
        (lambda-body exp)  env))
    ((begin? exp)
      (eval-sequence (begin-actions exp) env))
    ((cond? exp)
      (eval (cond->if exp) env))
    ((application? exp)
      (apply (eval (operator exp) env)
        (list-of-values (operands exp) env)))
    (else  (error ""Common Lisp or Netscape Navigator 4.0+ Required"" exp))))

","It's essentially a simple interpreter, if you assume that all the requisite methods are filled in.
","You may use the code letter `e' of the interactive declaration to access the event; e.g., the following will make left click insert the event data at the point clicked:
(define-key global-map (kbd ""<down-mouse-1>"")
  (lambda (event)
    (interactive ""e"")
    (message ""%s"" event)
    (let ((posn (elt event 1)))
      (with-selected-window (posn-window posn)
        (goto-char (posn-point posn))
        (insert (format ""%s"" event))))))

 The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 You have to evaluate each argument recursively, something like:
template <typename T>
auto eval(T t)
{
    return t;
}

template <typename ...Ts>
auto eval(std::tuple<Ts...> tuple)
{
    return std::apply([](auto... args){ return std::invoke(eval(args)...); }, tuple);
}

Demo.
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 To pass a list of arguments to a function you can use apply, for example
(apply 'insert '(""hello "" ""world""))
","The provided code snippet is a Common Lisp interpreter function named `eval`. It evaluates an expression (`exp`) within a specific environment (`env`). The function uses pattern matching to handle different types of expressions: self-evaluating forms, variables, quoted expressions, assignments, definitions, if statements, lambda expressions, begin blocks, conditionals, and applications. For applications (function calls), it first evaluates the operator and then collects the values of the operands using `list-of-values`. The function uses helper functions like `self-evaluating?`, `variable?`, `quoted?`, `assignment?`, `definition?`, `if?`, `lambda?`, `begin?`, `cond?`, and others to determine the type of expression. If none of these cases match, it returns an error message indicating that Common Lisp or Netscape Navigator 4.0+ is required.",0.4499,[[0.14912204]],0.019508917446428492,0.1842948717948718,0.08955223880597016,0.0,0.059701492537313446
"I want to solve a lisp function that returns a NUMBER(count) of numbers which are greater than the first number in the list.The list is a linear list of numbers.
(defun foo (lst) 
  (cond ((null lst) 0)
        (car = k)
        ((> (car lst) k) 
        (1+ (foo (cdr lst))))
  (T (foo (cdr lst)))))

My problem is that I cannot keep the first element and compare it with the others.
","Your function indented correctly looks like this:
(defun foo (lst) 
  (cond ((null lst) 0) 
        (car = k)              ; strange cond term         
        ((> (car lst) k)        
         (1+ (foo (cdr lst))))
        (T (foo (cdr lst)))))   

I have commented the second term in your cond. It is quite strange. It first evaluates the variable car (not the function #'car). If car is not nil it first evaluates the variable = (not the function #'=) and since it is not the last consequent expression in the cond term it throws that away and returns the last which is k. 
Secondly you write that you say you use the first element as comparison, however you call it k in your function but it is not defined anywhere. You need to do something before you do the recursion and thus you cannot let the actual function do the recursion since it will take the first element each time. Here is where labels can be used:
;; didn't call it foo since it's not very descriptive
(defun count-larger-than-first (list)
  (let ((first (car list)))
    (labels ((helper (list)
               (cond ((null list) 0)
                     ((> (car list) first) 
                      (1+ (helper (cdr list))))
                     (t (helper (cdr list))))))
      (helper (cdr list)))))

Of course. Since you now have  the possibility to add more arguments I would have added an accumulator:
(defun count-larger-than-first (list)
  (let ((first (car list)))
    (labels ((helper (list acc)
               (cond ((null list) acc)
                     ((> (car list) first) 
                      (helper (cdr list) (1+ acc)))
                     (t (helper (cdr list) acc)))))
      (helper (cdr list) 0))))

And of course recursion might blow the stack so you should really write it without in Common Lisp:
(defun count-larger-than-first (list)
  (let ((first (car list)))
    (loop :for element :in (cdr list)
          :counting (> element first))))

There are higher order functions that count too which might be more suitable:
(defun count-larger-than-first (list)
  (let ((first (car list)))
    (count-if (lambda (element) (> element first))
              (cdr list))))

","Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 I don't understand why your function takes 2 arguments when it's going to rearrange one list.
Your t case is almost correct, but you've practically turned it inside out - it should be
(cons (car x) (Func1 (cdr x)))

That is, a list where the car is the same as in the input, and the cdr is the result of flattening the cdr of the input.
The listp case looks like it's suffering from a similar form of ""inside-out-ness"".
Apart from the inexplicable y you have all the right bits but in the wrong order, except that it needs two Func1 calls - one for the car and one for the cdr.  
I'll leave the rearrangement of the bits in that case as an exercise.
 You have a little bug in your code, try this in the EVALPlus procedure:
(+ (car argList) (car (cdr argList)))

Remember that cdr retrieves the next list, not the next element. After obtaining the next list, we call car to obtain its first element.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
","To solve this, you need to keep track of both the count and the first element of the list. Here's how you can modify your function:\n\n```lisp\n(defun foo (lst)\n  (let ((k (car lst)))\n    (labels ((helper (sublist count)\n               (if (null sublist)\n                   count\n                   (if (> (car sublist) k)\n                       (helper (cdr sublist) (+ count 1))\n                       (helper (cdr sublist) count)))))\n      (helper (cdr lst) 0))))\n```\n\nThis version of the function uses a helper function to maintain both the count and the first element of the list. The `k` is set as the first element, and then it recursively checks the rest of the list against this value.",0.6912,[[0.57140942]],0.08559101498096759,0.23093360951192493,0.3472222222222222,0.08372093023255814,0.16666666666666669
"I'm watching these tutorials on Lisp and I've been following along so far. However, when I try to evaluate this function,
(defun tailfact (n &optional (intermediate 1))
  (if (= n 1)
    (return-from tailfact intermediate))
  (tailfact (1 - n) (* n intermediate)))

(tailfact 5)

I get an Invalid function warning (I'm running this in Emacs). Not sure what to make of it, or how to fix it.
","You accidentally wrote a space within the 1- (which is a function for subtracting 1 from the given number). Remove that space (that is, use (1- n) instead of (1 - n)) and try again.
Also, Emacs Lisp doesn't have return-from. Just say intermediate instead of (return-from tailfact intermediate). You do have to move the tailfact call within the if expression though, as the else clause.
Oh, in my testing, I found another point of difference between Common Lisp and Emacs Lisp: the latter doesn't support a default value for optional arguments, and it always uses nil. So here's one way to port your code to elisp:
(defun tailfact (n &optional intermediate)
  (let ((intermediate (or intermediate 1)))
    (if (= n 1)
        intermediate
      (tailfact (1- n) (* n intermediate)))))

However, let me be the first to agree with Rainer's comment. If you're learning from Common Lisp resources, you really should be using a Common Lisp implementation. I've heard that SLIME is an awesome Emacs mode for integrating with major CL implementations, including SBCL (which is probably one of the most commonly-used CL implementations).
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I'm surprised that you get a result at all. I get an error:
*** - PROGN: variable THE has no value
The following restarts are available:
USE-VALUE      :R1      Input a value to be used instead of THE.
STORE-VALUE    :R2      Input a new value for THE.
ABORT          :R3      Abort main loop

The reason is that strings in Common Lisp must be in double quotes: ""Return ..."". Single quotes are only used to prevent evaluation.
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
","The issue you're encountering is due to the incorrect usage of the decrement operator. In Common Lisp, the correct way to decrement `n` by 1 would be `(1- n)` rather than `(1 - n)`. Additionally, ensure that the function is correctly defined and that there are no typos or other issues in your code. Here's how you should define the `tailfact` function:

```lisp
(defun tailfact (n &optional (intermediate 1))
  (if (= n 1)
      intermediate
    (tailfact (1- n) (* n intermediate))))
```

You can then evaluate `(tailfact 5)` to get the factorial of 5. If you still encounter issues, make sure that your Emacs environment is correctly set up and that there are no other errors in your code.",0.6546,[[0.50115817]],0.25499710238930257,0.30386932482690127,0.4078947368421052,0.17218543046357615,0.22368421052631576
"I want to program a function to find C(n,k) using tail recursion, and I would greatly appreciate your help.
I have reached this:
(defun tail-recursive-binomial (n k)
  (cond ((or (< n k) (< k 0)) NIL)
        ((or (= k 0) (= n k)) 1)
        (T (* (tail-recursive-binomial (- n 1) (- k 1)) (/ n k)))))

Using the following property of the binomial coefficients.
But I don't know how to make the recursive call to be the last instruction executed by each instance, since there the last one is the product. I have been trying it by using an auxiliary function, which I think is the only way, but I haven't found a solution.
","As starblue suggests, use a recursive auxiliary function:
(defun binom (n k)
  (if (or (< n k) (< k 0))
    NIL  ; there are better ways to handle errors in Lisp
    (binom-r n k 1)))

;; acc is an accumulator variable
(defun binom-r (n k acc)
  (if (or (= k 0) (= n k))
    acc
    (binom-r (- n 1) (- k 1) (* acc (/ n k)))))

Or, give the main function an optional accumulator argument with a default value of 1 (the recursive base case):
(defun binom (n k &optional (acc 1))
  (cond ((or (< n k) (< k 0)) NIL)
        ((or (= k 0) (= n k)) acc)
        (T (binom (- n 1) (- k 1) (* acc (/ n k))))))

The latter option is slightly less efficient, since the error condition is checked in every recursive call.
","A simple recursive solution:
(defun remove-nth (n list)
  (declare
    (type (integer 0) n)
    (type list list))
  (if (or (zerop n) (null list))
    (cdr list)
    (cons (car list) (remove-nth (1- n) (cdr list)))))

This will share the common tail, except in the case where the list has n or more elements, in which case it returns a new list with the same elements as the provided one.
 An example: if list is (3 3 5 6 6 6 9), the loop will examine each list element in turn, and set these hash keys to t: 3, 5, 6, and 9.  Since 3 and 6 are duplicated in the list, no new hash key will be created for those elements.  Finally hash-table-count returns the number of keys in the hash table, i.e. 4.
 The right-hand side of and and or are tail expressions (see R5RS section 3.5), so you can safely use those for iterative purposes.
 I can give you a couple of pointers, because this looks like homework:

The base case of the recursion is when the list is empty (null), and not when there are less than two elements in the list
Consider defining a helper function with an extra parameter, an ""accumulator"" initialized in the empty list. For each element in the original list, cons it at the head of the accumulator. When the input list is empty, return the accumulator

As an aside note, the above solution is tail-recursive.
 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
 The loop/recur version is the right way.  Clojure cannot optimize tail calls due to limitations of the JVM. 
","To convert your existing recursive binomial coefficient function into a tail-recursive one, you can use an accumulator. Here's how you can do it:\n\n```lisp\n(defun tail-recursive-binomial (n k)\n  (labels ((binom-helper (n k acc)\n             (if (or (< n k) (< k 0))\n                 nil\n                 (if (= k 0)\n                     acc\n                     (binom-helper (- n 1) (- k 1) (* acc (/ n k)))))))\n    (binom-helper n k 1)))\n```\n\nIn this solution, `binom-helper` is an inner function that takes three arguments: the current values of `n`, `k`, and an accumulator `acc`. The base case returns the accumulator when appropriate. Otherwise, it makes a recursive call with updated parameters, ensuring the last operation in each recursive call is the multiplication and assignment to the accumulator. This transformation allows the recursion to be tail-recursive.",0.6645,[[0.51128433]],0.3754534140716715,0.41685303311896715,0.5056603773584906,0.21292775665399238,0.3169811320754717
"I have the core saved. How do I make sbcl load it automatically?
","The -core command line argument should do it. From the man page:
   --core <corefilename>
      Use the specified Lisp core file instead of the default. (See the FILES section  for  the
      standard  core,  or the system documentation for SB-EXT:SAVE-LISP-AND-DIE for information
      about how to create a custom core.) Note that if the Lisp core  file  is  a  user-created
      core  file,  it  may  run  a  nonstandard  toplevel which does not recognize the standard
      toplevel options.

","To lock all existing packages just call:
(dolist (package list-all-packages)
  (sb-ext:lock-package package))

 If you use SBCL, you have integrated support for unicode.
String operations
Try to sort with unicode< instead of string-lessp.
 One option is to put (sb-ext:disable-debugger) early in your startup function. When an error occurs and there is no handler, SBCL will print an error and a backtrace and exit.
Another option is to write a function that does what you want on error and set it as your debugger hook; see command-line-debugger in buildapp itself for an example.
 I guess that you have to enter a main loop to keep the program running.  The example at http://www.xach.com/lisp/buildapp/ uses the SBCL-specific (sb-impl::toplevel-repl nil).
 Make sure your SBCL was compiled with thread support. When running single-threaded, the Hunchentoot request handling loop does not return to the REPL.
Threading is not the default setting in the binaries from http://www.sbcl.org/ for Mac OS X. On Mac OS X, I usually download the sbcl.org binaries to get started, then download the sources and rebuild with ./make.sh --fancy to get a number of fancy features, including threads. See the INSTALL document in the sources for details.
 The only way is running under gdb and setting a break in SP_ueber and using call back_trace_out(0,0) when the breakpoint is reached.
","To make SBCL load a core file automatically, you can use the -C option followed by the path to your core file when starting SBCL. For example: `sbcl --core my-core-file.core`. This will instruct SBCL to start with that specific core image.",0.532,[[0.40066254]],0.04728632220833321,0.16377649325626203,0.2764227642276422,0.06611570247933884,0.16260162601626016
"I have a text file containing a list of property lists.  The content looks like the following.  How can I load it into a property list?
((:NOMBREMATERIA ""LENGUAJES DE PROGRAMACIÓN"" :IDMATERIA   ""FIEC01552""
  :CLASES NIL :NOTAPROYECTOS NIL   :HORASSEMESTRE ""40"" :NOTAEXAMENES NIL 
  :NOTATAREAS NIL   :CONTRIBUCION_TAREAS 0.1 :CONTRIBUCION_NOTAPROYECTO 0.5   
  :CONTRIBUCION_NOTAEXAMEN 0.4)
 (:NOMBREMATERIA ""HERRAMIENTAS DE COLABORACION DIGITAL"" :IDMATERIA ""FIEC06460""
  :CLASES NIL :NOTAPROYECTOS NIL   :HORASSEMESTRE ""40"" :NOTAEXAMENES NIL
  :NOTATAREAS NIL   :CONTRIBUCION_TAREAS 0.1 :CONTRIBUCION_NOTAPROYECTO 0.5
  :CONTRIBUCION_NOTAEXAMEN 0.4))

","Open the file and read in the data:
(with-open-file (f ""file.txt"")
  (read f))

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 nconc is a destructive operation that alters its first argument by changing its tail. In this case, it means that the constant list '(oh my) gets a new tail.
To hopefully make this clearer. It's a bit like this:
; Hidden variable inside exclaim
oh_my = oh → my → nil

(exclaim '(lions and tigers and bears)) =
    lions → and → tigers → and → bears → oh_my

(nconc * '(goodness)) destructively appends goodness to the last result:
    lions → and → tigers → and → bears → oh → my → goodness → nil
so now, oh_my = oh → my → goodness → nil

Replacing '(oh my) with (list 'oh 'my) fixes this because there is no longer a constant being shared by all and sundry. Each call to exclaim generates a new list (the list function's purpose in life is to create brand new lists).
 In the book, authors have an example of formulating an iterative process for computing the Fibonacci numbers.
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))

The point here is that use two parameter a and b to memorise f(n+1) and f(n) during computing. The similar could be applied: we need a, b, c to memorise f(n+2), f(n+1) and f(n)
;; an interative process implementation                                                                                                                       
(define (f-i n)                                                                                                                                               
  ;; f2 is f(n+2), f1 is f(n+1), f0 is f(n)                                                                                                                   
  (define (interative-f f2 f1 f0 count)                                                                                                                       
    (cond                                                                                                                                                     
      ((= count 0) f0)                                                                                                                                         
      (else (interative-f                                                                                                                                      
              (+ f2 (* f1 2) (* f0 3))                                                                                                                          
              f2                                                                                                                                                
              f1                                                                                                                                                
              (- count 1)))))                                                                                                                                   
  (interative-f 2 1 0 n))             

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 According to the hyperspec () is just an alternative notation for writing the symbol nil, however since it's the exact same object CL will only use one notation when printing it. It won't be the alternative notation unless the particular implementation has it as a configurable feature.
In you function, when you process car you need to check if the result is empty. Something like this:
(let ((a (trgni (car lista))))
  (if (null a)
      (trgni (cdr lista))            ; don't include this null value
      (cons a (trgni (cdr lista))))) ; include since it's not null

Note that this only works for nested lists like '(1 (nil nil nil) 2) which should become (1 2), but what if the argument is (nil nil nil)? Then it won't have any sensible value except nil to evaluate it to as nil is the empty list.
",Answer not found.,0.3763,[[0.]],8.78739713611392e-05,0.03731343283582089,0.0,0.0,0.0
"When I started learning CL from Practical Common Lisp, as is preached in the book, I started off with Allegro CL compiler. I stopped using it, since its commerical, yet free bit didn't impress me. It needed a connection to its remote server for some licensing stuffs.
I switched to 'clisp' and am using it. Now, I have been hearing about SBCL and planning to start using it as well.
So, the question is: How do the various ANSI CL implementations differ? Any practical experience of using one over the other ?
Thank you.
","There are portions of ANSI CL that leave certain details up to the implementations to determine; you will find that for those parts of the standard, each implementation will have its own quirks.
Also, look for things that are important to the runtime but not defined in the language: things like threading and multiprocessing and garbage collection will vary substantially in performance and reliability.
I have found SBCL to be the easiest implementation to work with in Linux; it has good support for threading in Linux.  I can't say much about the garbage collector, because it hasn't mattered to me much yet.
On Windows, your best bet will probably be Allegro or LispWorks, although I've had some success with clisp on Windows.  The Windows port of SBCL is progressing, but I haven't used it much, so I can't really comment.
Generally speaking, an understanding of these kinds of things that are difficult to acquire through research or analysis; it comes through experience.  Just pick a decent implementation that you're comfortable with, and get to work.  You'll figure out the tricky stuff as you go.
","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 Hmmm, apparently the answer is ""Don't use clisp or gcl"". The library loads without complaint in sbcl.
Not very satisfying, but at least there's a solution.
 CLISP is not really a programming language. It is an implementation of the programming language Common Lisp with many extensions.
You can load files with the function LOAD.
 The reason of this warning is a GNU policy which does not want a package cl to be used in Elisp. But it would be foolish as well to prohibit it completely. So they decided to show a warning.
You can find more information here
","The Common Lisp implementations such as CLISP, SBCL (Steel Bank Common Lisp), and Allegro CL (now part of Franz Inc.) differ in several aspects including performance, features, support, and maintenance. Here’s a brief comparison based on your interest and the context provided:

1. **Performance**: SBCL is generally considered to be one of the fastest implementations due to its advanced just-in-time (JIT) compiler optimizations.

2. **Features and Maintenance**: SBCL has been actively maintained and updated more frequently than CLISP, which hasn't received significant updates in recent years. This makes SBCL a more reliable choice for development and deployment.

3. **Commercial vs Free**: Allegro CL is a commercial product with extensive documentation and support, but it can be expensive. SBCL, on the other hand, is free and open-source.

4. **Licensing and Compatibility**: If you face any issues related to licensing or compatibility (as mentioned in the context), using SBCL might be more straightforward since it doesn't have the same restrictions as CLISP regarding package names like `cl`.

5. **Integration and Ecosystem**: SBCL integrates well with other tools and environments, making it easier for development workflows.

6. **Community Support**: Both SBCL and Allegro CL benefit from active communities, but SBCL has a broader community support base due to its open-source nature.

In practical experience, many users find that transitioning from CLISP to SBCL improves their overall Lisp programming experience due to better performance, more features, and fewer compatibility issues. However, the best choice depends on your specific needs and constraints.",0.5507,[[0.39892962]],0.1275736678370223,0.3367754048345459,0.3056179775280899,0.03160270880361174,0.13932584269662923
"In Common Lisp, there are obviously some special characters that act as shortcuts for certain forms. 'x means (quote x). #'f means (function f). I had thought those (as well as backtick) were the only ones, but then I learned about #(), which is apparently a vector, and just today someone mentioned #., which apparently does something with evaluation time.
Try as I might, I can't seem to find a comprehensive list of which prefix symbols mean something and what they do? Is this something that's left to the implementation to decide, or could someone point me to somewhere in the standard that lists these shortcuts comprehensively?
","The HyperSpec, in 2.4 Standard Macro Characters, enumerates ""the macro characters defined initially in a conforming implementation"".  You can define your own using set-macro-character, which handles the types like ' which have no ""prefix"" to them, and set-dispatch-macro-character, which handles the type that are prefixed by a dispatch character (typically #). 
In addition to the HyperSpec, you may find Chapter 17, Read Macros from Paul Graham's On Lisp helpful.  It begins with an implementation of ', i.e., the macro character that expands to (quote ...).  Answers to How to define symbols that will work like ( and ) by symbol macro? are also helpful, as there are some uses of set-macro-character.
","You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 There is no need to use the sharp-quote syntax here.  Its purpose is to use a function name in a variable position, but a is a variable already.  Just write a instead of #'a.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The #' is a reader macro. #'+ is an abbreviation for (function +). ' is a reader macro expanding to (quote …). The latter returns its argument unevaluated. So, '(#'+ +) yields ((function +) +) (#'+ will be turned into (function +) at read-time). The first of this is just the list (function +), which is not a function. Now, (function +) is printed as #'+, which is what you see in the debugger.
Using non-literal lists will work:
CL-USER> (funcall (first (list #'+ '+)) 1)
1

 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
","In Common Lisp, certain symbols prefixed with a # are used for specific purposes. These include ' (quote), #\ (character constant), #\ (string), #() (vector), #.(macro for evaluating forms at macro expansion time), and others. The standard documentation and the implementation details may vary slightly between different implementations, but generally, these are standardized. You can find more detailed information about these in the Common Lisp HyperSpec or the official ANSI CL standard. Additionally, some readers might define their own reader macros which could extend this list.",0.5579,[[0.33151134]],0.10647652956191861,0.27847972125365855,0.34693877551020413,0.010309278350515464,0.14285714285714285
"In The Structure and Interpretation of Computer Programs part 3.2, an ""environment"" is defined as ""a sequence of frames.""  But as far as I can see, the book doesn't further discuss the difference between an environment and a frame.  Also, I suspect the drawings of environments conflates them with frames because books drawings are small and 2-D, and don't readily show time-evolution short of another full drawing.  
So would it be correct to think of an environment at creation as being the same as its first frame?  And then when any change occurs in the environment (an extant binding changed, a new binding created), the environment adds a new frame to its sequence of frames?  If that understanding is NOT correct, then what exactly is the difference between an environment and a frame?
Thanks in advance for any help!
","The sequence of frames is the linked list (of frames) pointing 'upwards' towards the global environment.  So when an environment is created (for example, in the context of a procedure binding), the 'environment' is a pointer to the frame...which in term points to the enclosing environment (or null, if the global environment).
So ... a qualified 'yes'...it's the first frame in the sense that the rest of the environment is accessible from that first frame.
Does that help?
Cordially,
Dak
","The sequence of frames is the linked list (of frames) pointing 'upwards' towards the global environment.  So when an environment is created (for example, in the context of a procedure binding), the 'environment' is a pointer to the frame...which in term points to the enclosing environment (or null, if the global environment).
So ... a qualified 'yes'...it's the first frame in the sense that the rest of the environment is accessible from that first frame.
Does that help?
Cordially,
Dak
 As mentioned in first comment it is necessarily to use (list a b c) form.
 You are modifying literal data. It's best to avoid it, since its effects are undefined in portable code. Imagine a compiler which saves space by sharing literal lists.
Make sure that your variable *BF* has freshly allocated data. Use COPY-TREE to copy the list every time you initialize the variable.
 You cannot mutate literal data, such as '(BUF), and expect sane results. And in your code, the nconc is a mutating operation.
In terms of the ""why"" you're seeing the behaviour you're seeing, it's due to the (setq buf '(BUF)) expression. That sets it to the same object each time, because it's a literal datum—which you're not supposed to mutate with the likes of nconc. If you changed it to (setq buf (list 'BUF)), then it would generate a new object each time, and you can safely nconc that.
 I think I have known what happen.
The second program returns 1, because the symbol x is captured by cbr's param x. When the body of  cbr is evaluated, there are two bindings in the environment: one is the let binding x = 1, the other is x = x which is created by cbr's application. The symbol x in the (set x 2) uses the later one.
A workaround of this question is:
(let ((gen-x (gensym)))
  (set gen-x 1)
  (cbr gen-x)
  (symbol-value gen-x))
;; cbr (symbol-name x) g36
;; cbr (symbol-value x) 1
;; 2 

 ""If a tree falls in a forest and no one is around to hear it, does it make a sound?""
It's not valid to use define in any context where a return value could meaningfully be obtained. So it's moot whether it has a return value or not; you'll never be able to observe it.
",Answer not found.,0.3792,[[0.]],3.918998545081367e-15,0.008880994671403198,0.0,0.0,0.0
"I need to check if given number is divisible by 2 (if yes, output should be 2), by 3( if yes, output should be 3) and if number is not divisible by 2 or 3 (eg 11) output should be same as given number.
Here is my code:
(defun funk (a)    
(cond 
  ((evenp a)2) 
 ((rem a 3)3)
 (t a) 
))

it shows 3 even if i define a as 11.
","You need to test whether the remainder is zero.
((zerop (rem a 3)) 3)

","New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Check the order of the arguments of the function mod. It should be:
(= (mod (car list) 2) 0)

To avoid this mistake, you can use the function evenp instead.
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

","The issue with your code is that `(rem a 3)` returns the remainder when `a` is divided by 3. If you want to check if `a` is divisible by 3, you should use `(= (mod a 3) 0)` instead of `(rem a 3)`. Here's the corrected function:\n\n```lisp\n(defun funk (a)\n  (cond\n    ((evenp a) 2)\n    ((= (mod a 3) 0) 3)\n    (t a)))\n```\nThis will correctly return 2 for numbers divisible by 2, 3 for numbers divisible by 3, and the number itself if it's not divisible by either.",0.5435,[[0.21962465]],0.05779777718808107,0.2846116878123799,0.16216216216216217,0.05504587155963303,0.12612612612612611
"I’d like to wrap the built-in:
     (concatenate ‘string <arg1> <arg2> .. <argn>)

To be something like this:
     (strcat <arg1> <arg2> ... <argn>)

The issue is - how to do var-args in common-lisp?  I see two possible paths:

accept a list as a parameter, then splat it / apply it [neither of which I know either]
var-args special syntax in common-lisp?  ex: ...

Thanks
","(defun strcat (&rest args)
  (apply #'concatenate 'string args))

","
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
","In Common Lisp, you can handle var-args by using a list as an argument and then processing it within the function. Here’s how you can create a function `strcat` that behaves similarly to the built-in `concatenate 'string` but with more flexible syntax for arguments:\n\n```lisp\n(defun strcat (&rest args)\n  (apply #'concatenate 'string args))\n```\n\nThis definition uses `&rest` to collect all positional arguments into a list named `args`. The `apply` function then calls `concatenate 'string` with the collected arguments.\n\nAlternatively, if you want to use a different syntax like `(strcat arg1 arg2 ...)` without explicitly using lists, you can write:\n\n```lisp\n(defun strcat (&rest args)\n  (let ((*read-eval* nil))\n    (apply #'concatenate 'string args)))\n```\n\nHere, we ensure that the arguments are not evaluated by setting `*read-eval*` to `nil`, and then apply the string concatenation.\n",0.5395,[[0.46067201]],0.06079897405264327,0.314285449713402,0.10126582278481014,0.07692307692307691,0.10126582278481014
"How to know if a function evaluates its arguments?
Setq seems not to evaluate its arguments but 
Break 15 [16]> (setq j (kjl klj))
*** - EVAL: undefined function KJL

So when is the evaluation done?
cond and and seem not to evaluate their arguments as well but...
Break 18 [19]> (cond ((eql nil nil) (write ""lkj"")))
""lkj""
""lkj""
Break 18 [19]> (cond ((eql nil (not nil)) (write ""lkj""))
NIL

in the example above cond has to evaluate (eql nil nil) to know if it's true or not, hasn't it?
","Theory: Form Evaluation
Functions
The runtime evaluates the arguments before passing them to a function (such as eql).
E.g., when you write (eql a 1), the function eql gets the value of the variable a and the value of the literal 1 which is itself.
Macros
The runtime does not evaluate the arguments of macros (such as cond and and).
Macros convert their arguments to code which is then evaluated by the runtime.
E.g., when you write cond ((eql nil nil) (write ""lkj""))), it is expanded to something like:
> (macroexpand '(cond ((eql nil nil) (write ""lkj""))))
(IF (EQL NIL NIL)
    (PROGN (WRITE ""lkj""))
    NIL)

and then the if form is evaluated according to its spec as the special operator.
Of course, you don't want to actually read the macroexpansion of cond to understand what it does - you read the doc. However, you do use macroexpand to debug your own macros.
Special Operators
The runtime handles special operators (such as setq), well, specially, i.e., the behavior is idiosyncratic to each special operator.
E.g., when you write (setq a (! 4)), the runtime does not evaluate a, it does, however, evaluate (! 4), it discovers that ! is fbound to a function, so it evaluates 4 (it evaluates to itself), then calls the function binding of ! with argument 4, and assigns the return value (24) to the variable a.
Order
Actually, as @Paulo mentioned in the comments, the symbol is checked for being a special operator first (because an implementation can implement a macro as a special operator and vv); it cannot be a macro and a function at the same time (but you can use compiler macros). This is out of the scope of this question though...
Practice: Use CLHS
Edit your code in Emacs, load clhs.el, and view the doc of the symbol you are interested in.
The do will say right away what the symbol is defined as.
","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You've got it almost right. However, you're terminating your list with 0, when the correct termination is nil. This code works:
(defun vecmul (list list2)
  (cond ((null list) nil)
     (t (cons (* (car list) (car list2)) (vecmul (cdr list) (cdr list2))))))

When you call (cons 1 2), the cons cell you get is written (1 . 2). the notation (1 2 3 4 5) is just shorthand for (1 . (2 . (3 . (4 . (5 . nil))))). If the cdr of the last cons cell is 6, not nil, then you get (1 . (2 . (3 . (4 . (5 . 6))))), which shortens to (1 2 3 4 5 . 6).
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

 nconc is a destructive operation that alters its first argument by changing its tail. In this case, it means that the constant list '(oh my) gets a new tail.
To hopefully make this clearer. It's a bit like this:
; Hidden variable inside exclaim
oh_my = oh → my → nil

(exclaim '(lions and tigers and bears)) =
    lions → and → tigers → and → bears → oh_my

(nconc * '(goodness)) destructively appends goodness to the last result:
    lions → and → tigers → and → bears → oh → my → goodness → nil
so now, oh_my = oh → my → goodness → nil

Replacing '(oh my) with (list 'oh 'my) fixes this because there is no longer a constant being shared by all and sundry. Each call to exclaim generates a new list (the list function's purpose in life is to create brand new lists).
","In Lisp, functions like `caar`, `cdr`, and `cons` do not evaluate their arguments unless explicitly designed to do so. The evaluation of arguments is controlled by the function itself or by the context in which it is used. For example, `(caar '((6 4 2 3)))` evaluates its argument because `caar` expects a list structure, and it will signal an error if given something that is not a list (as in your initial question about `(caar '(6 4 2 3))`).\n\nRegarding the use of `append` vs. `nconc`, `append` returns a new concatenated list without modifying any of the original lists, whereas `nconc` modifies the first list destructively by appending to its tail. If you want to append an element and return a new list without altering the originals, use `append`. For instance:\n\n```lisp\n(defun vecmul (list list2)\n  (cond ((null list) nil)\n        (t (cons (* (car list) (car list2)) (vecmul (cdr list) (cdr list2))))))\n```\nThis function builds a new list by consing elements together.\n\nAlso, when dealing with lists that you intend to modify, always ensure they are not quoted constants. Using `(list 'oh 'my)` instead of `'(oh my)` can prevent unintended side effects.",0.5477,[[0.36661072]],0.12800486603262337,0.2417760211838623,0.30326295585412666,0.03468208092485549,0.1381957773512476
"I realize this is probably a really stupid question but i have no idea why this isnt working and i pretty much gave up. basically i tried:
(setq answer (string (read)))

and
(setq answer 0)
(format answer ""~s"" (read))

and 
(setq answer (read))

when i try to evaluate 
(if (stringp answer) 
    (princ ""works"")
    (princ ""failed""))

on any of the above tries it always comes out failed.
what am i doing wrong?
","Or you could just do:
(setq answer (read-line))

That gives you a string right there.
[1]> (setq answer (read))
3
3
[2]> (type-of answer)
(INTEGER 0 16777215)
[3]> (setq answer (read-line))
3
""3""
[4]> (type-of answer)
(SIMPLE-BASE-STRING 1)
[5]>

","I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Turns out a different environment will do the trick.
I used Gnu Common Lisp (http://www.cs.utexas.edu/~novak/gclwin.html) and the answer is returning as expected.
 It's a very cool idea - would be great for evaluating mathematical expressions but you simply can't set an operator (or the logic behind it) to a variable.  Sorry :-)
 Your argument to run-test is evaluated once, so ""eq1"" sees 'a which is (quote a) (a list of length 2) which is, of course, fails under eq.
Similarly, (return-symbol) is not evaluated and ""eq1"" sees the lists of length 1 which are not identical under eq.
You would have discovered that by simply adding print to multi-comp.
Your code would probably work is you replace (multi-comp key a b) with (multi-comp key (eval a) (eval b)).
Please note that the fact that you need eval is a very strong indicator that you are doing something horribly wrong.
PS. I urge you to use ERT instead of rolling your own.
 In addition to all the other excellent answers, here is a way to avoid landing in the debugger (a la scheme):
(set-global-handler 'error 'sys::abortonerror)

This is NOT recommended, learn the debugger instead!
E.g., use :q to escape from all the debuggers to the top level REPL.
","The issue you're encountering is due to how Common Lisp handles input and output. The function (read) reads a form from the standard input stream and evaluates it. In your case, when you use (setq answer (read)), you are trying to assign an evaluated expression directly to `answer`. However, `(read)` returns a form that needs to be evaluated to produce a value. When you check with (if (stringp answer) ...), the result of (read) is not a string, but rather the form itself, which cannot be directly compared using `stringp`.

To fix this, you should first read the input and then evaluate it if necessary. For example:

```lisp
(setq answer (eval (read)))
(if (stringp answer)
    (princ ",0.5202,[[0.30262257]],0.10800912835978731,0.26888512161697553,0.1987577639751553,0.050314465408805034,0.16149068322981366
"With common lisp and I am assuming the introspection properties.  How can I add code to common lisp code that will tell me when a function is called and when has finished executing.  I want to take any lisp code and this particular modification to the code.  I figure with lisp's AST analysis, this should be possible.
","You can use (trace function) for a simple mechanism. For something more involved, here is a good discussion from comp.lang.lisp.
[CL_USER]>
(defun fac (n)
    ""Naïve factorial implementation""
    (if (< 1 n)
        (* n (fac (- n 1)))
        1))
FAC
[CL_USER]> (trace fac)
;; Tracing function FAC.
(FAC)
[CL_USER]> (fac 5)
1. Trace: (FAC '5)
2. Trace: (FAC '4)
3. Trace: (FAC '3)
4. Trace: (FAC '2)
5. Trace: (FAC '1)
5. Trace: FAC ==> 1
4. Trace: FAC ==> 2
3. Trace: FAC ==> 6
2. Trace: FAC ==> 24
1. Trace: FAC ==> 120
120
[CL_USER]> 

","Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 This is a result of using a constant list in the initializer:
(let ((myList '(0 0 0 0 0 0)))

Change that line to:
(let ((myList (list 0 0 0 0 0 0)))

and it will behave as you expect.  The first line only results in an allocation once (since it's a constant list), but by calling list you force the allocation to occur every time the function is entered.
edit:
This may be helpful, especially towards the end.  Successful Lisp
The answer to this question may also be helpful.
This uses the loop keyword collecting which collects the results of each iteration into a list and returns the list as the value of the loop.
 Common Lisp provides compiler macros.
These can be used for such optimizations. A compiler macro can conditionally decline to provide an expansion by just returning the form itself. 
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Quoting in lisp prevents evaluation of the s-exp and passes it around as a function.
Therefore, you're comparing the non-evaluated function '(reverse (a b)) to the list '(a b)
If you changed the code to 
(equal (reverse '(a b)) '(b a))

(reverse '(a b)) would yield '(b a), and thus the equal comparison would return true.
 Function calls in Lisp are cons cells:
(cons 1 2)
==> (1 . 2)

If you fix your code:
(defun insertcell (R L)
  (cond ((< (caar L) (car R)) (cons (car L) (insertcell R (cdr L))))
        (t (cons R L))))

it works:
(insertcell '(2 . b) '((1 . a) (3 . c) (4 . d)))
==> ((1 . A) (2 . B) (3 . C) (4 . D))

Note that you also need to do (caar L), not (car L) because L is an alist, so to access the first key you need to call car twice.
","To achieve introspection for function calls and their completion in Common Lisp, you can redefine or use `macrolet` to create a custom macro that wraps around your function definitions. This approach leverages the fact that all function definitions are macros at some level in Common Lisp. Here’s an example of how you could do this:

```lisp
(defmacro with-introspection ((&rest names) &body body)
  ",0.4871,[[0.04165786]],0.022198526805698924,0.13875123885034688,0.11320754716981131,0.012738853503184712,0.07547169811320754
"I am trying to get the first row under the column with the title ""Name"" so for example for https://en.wikipedia.org/wiki/List_of_the_heaviest_people I want to return the name ""Jon Brower Minnoch"". My code so far is as follows, but I think there must be a more general way of getting the name:
(defun find-tag (tag doc)
 (when (listp doc)
  (when (string= (xmls:node-name doc) tag)
   (return-from find-tag doc))
  (loop for child in (xmls:node-children doc)
   for find = (find-tag tag child)
   when find do (return-from find-tag find)))
  nil)

(defun parse-list-website (url)
  (second (second (second (third (find-tag ""td"" (html5-parser:parse-html5 (drakma:http-request url) :dom :xmls)))))))

and then to call the function:
(parse-list-website ""https://en.wikipedia.org/wiki/List_of_the_heaviest_people"")

I am not very good with xmls and don't know how to get an get a td under a certain column header.
","The elements in the document returned by html5-parser:parse-html5 are in the form:
(""name"" (attribute-alist) &rest children)

You could access the parts with the standard list manipulation functions, but xmls also provides functions node-name, node-attrs and node-children to access the three parts. It's a little bit clearer to use those. Edit: there are also functions xmlrep-attrib-value, to get the value of an attribute and xmlrep-tagmatch to match the tag name. The children are either plain strings, or elements in the same format.
So for example, a html document with a 2x2 table would look like this:
(defparameter *doc*
  '(""html"" ()
     (""head"" ()
       (""title"" ()
         ""Some title""))
     (""body"" ()
       (""table"" ((""class"" ""some-class""))
         (""tr"" ((""class"" ""odd""))
           (""td"" () ""Some string"")
           (""td"" () ""Another string""))
         (""tr"" ((""class"" ""even""))
           (""td"" () ""Third string"")
           (""td"" () ""Fourth string""))))))

In order to traverse the dom-tree, lets define a recursive depth-first search like this (note that the if-let depends on the alexandria library (either import it, or change it to alexandria:if-let)):
(defun find-tag (predicate doc &optional path)
  (when (funcall predicate doc path)
    (return-from find-tag doc))

  (when (listp doc)
    (let ((path (cons doc path)))
      (dolist (child (xmls:node-children doc))
        (if-let ((find (find-tag predicate child path)))
          (return-from find-tag find))))))

It's called with a predicate function and a document. The predicate function gets called with two arguments; the element being matched and a list of its ancestors. In order to find the first <td>, you could do this:
(find-tag (lambda (el path)
            (declare (ignore path))
            (and (listp el)
                 (xmls:xmlrep-tagmatch ""td"" el)))
          *doc*)
; => (""td"" NIL ""Some string"")

Or to find the first <td> in the even row:
(find-tag (lambda (el path)
            (and (listp el)
                 (xmls:xmlrep-tagmatch ""td"" el)
                 (string= (xmls:xmlrep-attrib-value ""class"" (first path))
                          ""even"")))
          *doc*)
; => (""td"" NIL ""Third string"")

Getting the second <td> on the even row would require something like this:
(let ((matches 0))
  (find-tag (lambda (el path)
              (when (and (listp el)
                         (xmls:xmlrep-tagmatch ""td"" el)
                         (string= (xmls:xmlrep-attrib-value ""class"" (first path))
                                  ""even""))
                (incf matches))
              (= matches 2))
            *doc*))

You could define a helper function to find the nth tag:
(defun find-nth-tag (n tag doc)
  (let ((matches 0))
    (find-tag (lambda (el path)
                (declare (ignore path))
                (when (and (listp el)
                           (xmls:xmlrep-tagmatch tag el))
                  (incf matches))
                (= matches n))
              doc)))
(find-nth-tag 2 ""td"" *doc*) ; => (""td"" NIL ""Another string"")
(find-nth-tag 4 ""td"" *doc*) ; => (""td"" NIL ""Fourth string"")

You might want to have a simple helper to get the text of a node:
(defun node-text (el)
  (if (listp el)
      (first (xmls:node-children el))
      el))

You could define similiar helpers to do whatever you need to do in your application. Using these, the example you gave would look like this:
(defparameter *doc*
  (html5-parser:parse-html5
   (drakma:http-request ""https://en.wikipedia.org/wiki/List_of_the_heaviest_people"")
   :dom :xmls))

(node-text (find-nth-tag 1 ""a"" (find-nth-tag 1 ""td"" *doc*)))
; => ""Jon Brower Minnoch""

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You need to use (apply #'lstbuilder (cdr args)) in order to ""splat"" the list's contents as the function call arguments.
 To use ido-find-file, change the interactive specification for the filename argument to F.  That is:
(interactive ""r\nFFilename: "")

That's assuming you're already using ido for opening other files, as by (ido-mode 1) in your .emacs file.
The function to open a file in the background, by which I assume you mean to open a file without displaying it immediately, is called find-file-noselect.
I don't know why the entire buffer after the region would be killed by that call to kill-region; I don't see that happen when I use your code.
 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

",Answer not found.,0.2766,[[0.]],2.0175789181419894e-145,0.001397506847783554,0.0,0.0,0.0
"I have a list that looks like (A (B (C D)) (E (F))) which represents this tree:
      A
    /  \
  B      E
 / \    /
C   D  F

How do I print it as (A B E C D F) ?
This is as far as I managed:
((lambda(tree) (loop for ele in tree do (print ele))) my-list)

But it prints:
A
(B (C D))
(E (F))
NIL

I'm pretty new to Common LISP so there may be functions that I should've used. If that's the case then enlight me.
Thanks.
","Taking your question at face value, you want to print out the nodes in 'breadth-first' order, rather than using one of the standard, depth-first orderings: 'in-order' or 'pre-order' or 'post-order'.

in-order: C B D A E F
pre-order: A B C D E F
post-order: C D B F E A
requested order: A B E C D F

In your tree structure, each element can be either an atom, or a list with one element, or a list with two elements.  The first element of a list is always an atom.
What I think the pseudo-code needs to look like is approximately:
Given a list 'remains-of-tree':
    Create empty 'next-level' list
    Foreach item in `remains-of-tree`
        Print the CAR of `remains-of-tree`
        If the CDR of `remains-of-tree` is not empty
             CONS the first item onto 'next-level'
             If there is a second item, CONS that onto `next-level`
    Recurse, passing `next-level` as argument.

I'm 100% sure that can be cleaned up (that looks like trivial tail recursion, all else apart).  However, I think it works.
Start: (A (B (C D)) (E (F)))
Level 1:
Print CAR: A
Add (B (C D)) to next-level: ((B (C D)))
Add (E (F)) to next-level: ((B (C D)) (E (F)))
Pass ((B (C D) (E (F))) to level 2:
Level 2:
Item 1 is (B (C D))
Print CAR: B
Push C to next-level: (C)
Push D to next-level: (C D)
Item 2 is (E (F))
Print CAR: E
Push F to next-level: (C D F)
Pass (C D F) to level 3:
Level 3:
Item 1 is C
Print CAR: C
Item 2 is D
Print CAR: D
Item 3 is F
Print CAR: F

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 I'd make use of the signum function to know if I should increment or decrement.
(defun mapnum (func start end)
    (do ((i start)
        (j end (+ j (signum (- start end))))
        (res nil))
    ((equal i j) res)
    (setf res (cons (funcall func j) res))))

EDIT: modified the code to avoid appending to the end of the list.
","To print the elements of the tree structure (A (B (C D)) (E (F))) in a linearized form like (A B E C D F), you can use a function that traverses the tree and collects its elements. Here is an example using Common Lisp:\n\n```lisp\n(defun flatten-tree (tree)\n  (labels ((traverse (subtree res)\n             (cond ((null subtree) nil)\n                   ((atom subtree) (cons subtree res))\n                   (t (traverse (car subtree) (traverse (cdr subtree) res))))))\n    (traverse tree '())))\n\n(defun print-tree-elements (tree)\n  (dolist (element (flatten-tree tree))\n    (format t ",0.5855,[[0.20518783]],0.08782323508008306,0.1772004284375418,0.21393034825870644,0.08,0.14925373134328357
"I want to make a function to get the N-th first element of a list.
For example : 
>>(firsts 3 '(a b c d e))

return : (a b c)
I made that :
(define (firsts number lst)
  (let ((maliste '()))
        (if (equal? 0 number)
            maliste
            (and (set! maliste (cons (car lst) maliste)) (firsts (- number 1) (cdr lst))))))

But it doesn't work, I think I should use a let but I don't know how.
Thanks .
","It's a lot simpler, remember - you should try to think functionally. In Lisp, using set! (or other operations that mutate state) is discouraged, a recursive solution is the natural approach. Assuming that the list has enough elements, this should work:
(define (firsts number lst)
  ; as an exercise: add an extra condition for handling the
  ; case when the list is empty before the number is zero
  (if (equal? 0 number)
      '()
      (cons (car lst)
            (firsts (- number 1) (cdr lst)))))

","As mentioned in first comment it is necessarily to use (list a b c) form.
 The way you are doing it is tree recursive and its running time will blow up exponentially. The link has efficient alternatives. But, if you want to keep the whole sequence you could do something like,
(defun fib (num)
  (let (seq)
    (labels ((helper (n)                                  ; define local helper function
               (when (<= n num)                           ; stop when reached NUM
                 (if (< n 3) (push 1 seq)
                     (push (+ (car seq) (cadr seq)) seq)) ; sum of previous 2
                 (helper (1+ n)))))                       ; recurse
      (helper 1))                                         ; start from first fib number
    (nreverse seq)))                                      ; reverse the result

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
","You can create a function to get the first N elements of a list using recursion and a local variable to accumulate the results. Here's an example in Lisp:

```lisp
(defun firsts (number lst)
  (if (or (null lst) (< number 1))
      nil                         ; Return an empty list if lst is null or number is less than 1
      (cons (car lst)            ; Add the first element of lst to the result
            (firsts (- number 1) (cdr lst))))) ; Recur with the rest of the list and decrement number

;; Example usage:
(firsts 3 '(a b c d e)) ;; Returns: (a b c)
",0.6888,[[0.5297835]],0.3426941669166649,0.4348946542955211,0.4482758620689655,0.12790697674418605,0.2413793103448276
"There are many differences between Common Lisp and Scheme such as whether functions and variables share a namespace, whether macros are hygienic, and how strongly functional style is preferred; this shows up in some vocabulary differences such as setq  vs set!.
But quite a bit of vocabulary is still shared, such as quote and cons.
I'm looking for a full list of vocabulary shared between the languages. Does such a thing exist?
Alternatively, I could make one myself given the vocabulary of each language, i.e. a list of all the known symbols including language primitives, standard library macros and functions. Do those exist for Common Lisp (as in the standard) and Scheme (as in any RxRS, or failing that, any dialect)?
","You are looking for this web page:
http://hyperpolyglot.org/lisp
","The convention I use is to use a unique word: salza, skippy, zs3, etc. I don't really try to have a direct relationship to the library functionality. I try to avoid generic words that others might use like ""zlib"" or ""zip"" or ""png"".
Edi Weitz uses Frank Zappa-related words to name many of his packages: Hunchentoot, Drakma, etc.
Some people use Java-style org.foo.bar reversed domain naming.
So, the direct answer is no, there isn't a common, agreed-upon convention that everyone uses.
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 Common Lisp has Parenscript, that allows you to generate JavaScript from Lisp syntax, and be able to use reader macros.
You can also hook it with slime-proxy and swank-js to have a fully interactive experience.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

","There isn't a comprehensive, officially published list of shared vocabulary between Common Lisp and Scheme. However, there are some symbols that are commonly used in both languages due to their historical and semantic similarities. For example, 'quote', 'lambda', 'cons', and 'car' are present in both. To create your own list, you can refer to the official documentation for each language: the HyperSpec for Common Lisp and R5RS or later versions of Scheme. These resources provide detailed listings of symbols, functions, and macros that are part of their respective standards.",0.4067,[[0.13705004]],0.012732188979973701,0.1997137652875358,0.07920792079207921,0.0,0.05940594059405941
"I'm forming a class for some work on molecular dynamics as follows:
(defclass %atom (particle)
  ((name :initarg :name :initform (error ""Every atom in the system must have a name!""))
   (mass :accessor mass :initarg :mass :initform (getmass name))
   (charge :accessor charge :initarg :charge :initform (getcharge name))))

Initially I thought that I could somehow refer to other slots within the class definition with an initform i.e. (getmass name) - but that turns out to be untrue (or does it?!?). Instead, I'm told that initialize-instance would be the place to put all that initialization stuff... fair enough.
The question I have, then, is when is :initform used? What's the idiomatic preference? I've seen it used as above for generating (error ""..."") code, and also to initialize default arguments when an :initarg is not provided. But both of those could easily fit into initialize-instance and may make more sense there. Is there a particular way :initform is generally used?
","Usually one would use :initform to give a slot some default value. With defclass one can't compute initforms simply based on other slots. There are also other complications, so :initform should be used for simple forms.
Examples

set the z slot of a 3d-vector object to 0.0
set the list of windows in a screen object to NIL
set the 'key function' slot in an object to #'identity
set the 'report string' slot in an error to ""an error occured""

Any other more complicated set up of slot values should be done in a method. If the object needs to be set up automatically after MAKE-INSTANCE use an :AFTER method to INITIALIZE-INSTANCE.
","The sequence of frames is the linked list (of frames) pointing 'upwards' towards the global environment.  So when an environment is created (for example, in the context of a procedure binding), the 'environment' is a pointer to the frame...which in term points to the enclosing environment (or null, if the global environment).
So ... a qualified 'yes'...it's the first frame in the sense that the rest of the environment is accessible from that first frame.
Does that help?
Cordially,
Dak
 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 nconc is a destructive operation that alters its first argument by changing its tail. In this case, it means that the constant list '(oh my) gets a new tail.
To hopefully make this clearer. It's a bit like this:
; Hidden variable inside exclaim
oh_my = oh → my → nil

(exclaim '(lions and tigers and bears)) =
    lions → and → tigers → and → bears → oh_my

(nconc * '(goodness)) destructively appends goodness to the last result:
    lions → and → tigers → and → bears → oh → my → goodness → nil
so now, oh_my = oh → my → goodness → nil

Replacing '(oh my) with (list 'oh 'my) fixes this because there is no longer a constant being shared by all and sundry. Each call to exclaim generates a new list (the list function's purpose in life is to create brand new lists).
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 'name is read to (quote name).
FUNCTION expects a name for a function, a list (setf some-name) or a lambda expression.
(quote name) is neither. So it is an error to use it.
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
",":initform is specifically used for providing default values that will be assigned to slot variables when an instance of the class is created, if no value is provided for the corresponding :initarg during object initialization. It is not designed for complex operations like calling functions or performing conditional logic; such tasks are better suited for the initialize-instance method. Using :initform for simple defaults can make your code cleaner and more concise. However, for more complex initializations, it's idiomatic to handle them within the initialize-instance method.",0.576,[[0.28290167]],0.11804405663099253,0.28759049672692266,0.30243902439024395,0.04926108374384237,0.15609756097560976
"Is there a way (with loop or iterate, doesn't matter) to iterate over sequence backwards? 
Apart from (loop for i downfrom 10 to 1 by 1 do (print i)) which works with indexes, and requires length, or (loop for elt in (reverse seq)) which requires reversing sequence (even worse then the first option).
","Iterate can do it:
(iterate (for x :in-sequence #(1 2 3) :downto 0)
         (princ x))
; => 321

As others have noted, this will be very inefficient if used on lists.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 The example is unfortunate, as it only leaves one argument after ""the opening of the parentheses"". But yes, that's how I also think about it. The simpler the better, :) as long as it is correct.
Except that of course the values in the list are first evaluated, so it's not a simply-syntactical process. But as a basic example,
(apply + (list 1 2 3)) 
== 
(      +       1 2 3 )

i.e. the parens around the arguments is what goes away.
For a non-trivial example, see

Matrix multiplication in scheme, List of lists

 The easiest way is to reverse the result:
(defun pozpar (lst)
  (do ((l lst (cddr l))
       (x '() (cons (car l) x)))
      ((null l)
       (nreverse x))))

(pozpar '(1 2 3 4 5))
==> (1 3 5)

Notes

This returns, not outputs the value you want.
Prepending values and reverting the result is a common Lisp coding pattern.
Since append is linear in the length of its argument, using it in a loop produces quadratic code.
I formatted the code in the standard Lisp way. If you use this style, lispers will have an easier time reading your code, and, consequently, more willing to help you.

 The primary problem seems to be that you need to reset the file position after each pass.  The infinite loop happens because you never check for the file end (and suppressed the signal).
Side hint: use dolist instead of that dotimes and nth construction.
If you do not want to make n passes (n being the number of patches), and you cannot hold the entire contents in memory, you could write the patches to temporary files, then concatenate them in the desired order.  If you also do not have enough disk space, it becomes an in-place sort problem with varying element sizes, which is a bit more involved.
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
","Yes, you can iterate over a sequence backwards without explicitly reversing it. In Common Lisp, you can use the `do` loop with proper initialization and step parameters to achieve this. For example, if you have a list `(1 2 3 4 5)`, you can use:\n\n```lisp\n(do ((lst '(1 2 3 4 5) (cdr lst))\n     (elt (car lst)))\n    ((null lst))\n  (print elt))\n```\nThis loop initializes `lst` with the list and `elt` with its first element. On each iteration, it sets `lst` to `(cdr lst)` and `elt` to `(car lst)`, effectively moving backward through the list.",0.5355,[[0.13088205]],0.07362216227265529,0.3215492496756404,0.25757575757575757,0.030769230769230767,0.1515151515151515
"What version/dialect/implementation of LISP is this meant to run on?
(I do understand that the book is written in Common LISP (as specified in the introduction) and that it predates the 1994 CL standard). 

Split question into two to make it clearer.
","If we look at auxfns.lisp found on Peter Norvig's web page for the book, there's this bit
(eval-when (eval compile load)
  ;; Make it ok to place a function definition on a built-in LISP symbol.
  #+(or Allegro EXCL)
  (dolist (pkg '(excl common-lisp common-lisp-user))
    (setf (excl:package-definition-lock (find-package pkg)) nil))

  ;; Don't warn if a function is defined in multiple files --
  ;; this happens often since we refine several programs.
  #+Lispworks
  (setq *PACKAGES-FOR-WARN-ON-REDEFINITION* nil)

  #+LCL 
   (compiler-options :warnings nil)
  )

which suggests its supposed to work in Franz Allegro, Lucid Lisp, or Lispworks
","As mentioned in first comment it is necessarily to use (list a b c) form.
 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
","The code examples provided are meant to run on a Common Lisp implementation. Specifically, the use of functions like REDUCE, WITH-OPEN-FILE, and READ-EVAL is consistent with Common Lisp practices. The CLISP implementation notes and examples also align with Common Lisp standards.",0.4916,[[0.17513624]],0.01389188012379192,0.12121212121212123,0.17567567567567569,0.0410958904109589,0.12162162162162163
"Many Lisp-family languages have a little bit of syntax sugar for things like addition or comparison allowing more than two operands, if optionally omitting the alternate branch etc. There would be something to be said for implementing these with macros, that would expand (+ a b c) to (+ a (+ b c)) etc; this would make the actual runtime code cleaner, simpler and slightly faster (because the logic to check for extra arguments would not have to run every time you add a pair of numbers).
However, the usual macro expansion algorithm is 'keep expanding the outermost form over and over until you get a non-macro result'. So that means e.g. + had better not be a macro that expands to +, even a reduced version, or you get an infinite loop.
Is there any existing Lisp that solves this problem at macro expansion time? If so, how does it do it?
","Common Lisp provides compiler macros.
These can be used for such optimizations. A compiler macro can conditionally decline to provide an expansion by just returning the form itself. 
","Macro expansion happens at compile time. Your message indicates that the file that uses the macro was compiled when the macro was not defined, so the compiler assumed that the unknown name my-macro names a function (if you look at the compilation logs, you should see a message to that effect).
Solution: require the file containing macro definitions in files that use them.
 Recursive macro-expansion works by repeatedly expanding the form until there is no macro to expand. That means that if you want to recursively expand a macro, but ignore certain forms, you'll have to either code your own custom expander, or find someone else's.
Here's a quick example:
(defn my-expander [form]
    (cond (not (list? form)) (mexpand-1 form)
        (= (first form) 'let) form
           :else (map my-expander (mexpand-1 form))))

Please forgive me if I made any mistakes. I'm much stronger with Scheme and CL than Clojure.
--Edit--
Note that the above function will not expand the subforms of a let statement, either.
 Common Lisp provides compiler macros.
These can be used for such optimizations. A compiler macro can conditionally decline to provide an expansion by just returning the form itself. 
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You have three options:

Rewrite the algorithm to be tail-recursive or, equivalently, iterative
Change the algorithm all together
Increase the lisp's stack size

","The solution to your problem can be approached by defining a custom macro that handles multiple arguments recursively. Instead of expanding the form immediately, you can write a macro that deconstructs the list and processes it in a way that avoids infinite recursion. Common Lisp provides compiler macros which can help with such optimizations. However, for this specific case, you would need to implement a custom expander function as shown below.",0.6193,[[0.32232052]],0.17387753861052963,0.5379010971818476,0.3434343434343434,0.14432989690721648,0.18181818181818182
"I have this:
(defun promptread (prompt) 
  (format *query-io* ""~10t~a:"" prompt)
  (force-output *query-io*)
  (read-line *query-io*))
(defun prompt-cd ()
    (make-cd
     (promptread ""Artist"")
     (promptread ""Album"")
     (promptread ""Rating"")
     (promptread ""Like [y/n]"")))

It works, however the format ~10t only affects the first call to promptread inside make-cd; the others are left-aligned without this padding.
Why would this be?
REPL:
CL-USER> (addcds)
          Artist:Dixie
 Album:Funny
 Rating:22

The first promptread is indented because of the format with ~10t but not the others, which use the same exact format call.
","The problem is that after force-output and readline, the cursor is not known to formatto be at position 0. Thus absolute tabulation will fail.  If you start the format string with ~&, you will see this as an additional newline will be outputted anyway.
To solve the problem use the @ modifier to get relative tabulation:
(format *query-io* ""~10@t~a:"" prompt)

","Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 As mentioned in first comment it is necessarily to use (list a b c) form.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 (defun latex-bibleverse-snippet ()
  (interactive)
  (insert ""\\bibleverse{}()"")
  (backward-char 3))

(global-set-key (kbd ""C-c v"") 'latex-bibleverse-snippet)

Maybe a quick and dirty answer. Or you can take a look at YASnippet, or Predictive mode(provide IntelliSense features for some major modes (currently: LaTeX, Texinfo, HTML). ) :-)
","The issue arises because the `format` function only affects the output of the first call within a single dynamic extent. Once control leaves the scope of that `format` call, any subsequent calls to `format` or `read-line` will not have the same formatting context. To ensure consistent formatting for all prompts, you should include the format specification in each `promptread` call. Here's how you can modify your function to apply the formatting to all prompts consistently:",0.5463,[[0.36183427]],0.10791978532746767,0.29850746268656714,0.27338129496402874,0.014598540145985403,0.18705035971223022
"I'm working on a lisp interpreter and implemented rational numbers. I thought they have the advantage over doubles to be able to represent numbers like 1/3. I did some calculations to compare the results. I was surprised by the results
with doubles
(* 3.0 (/ 1.0 3.0)) -> 1
(* 3.0 (/ 4.0 3.0)) -> 4
(* 81.0 (/ 1.0 81.0)) -> 1

with ratios:
(* 3 (/ 1 3)) -> 1
(* 3 (/ 4 3)) -> 4
(* 81 (/ 1 81)) -> 1

Why are the results of the floating point operations exact? There must be a loss of precision. doubles cannot store an infinit number of digits. Or do I miss something?
I did a quick test with a small C-Application. Same result.
#include <stdio.h>

int main()   
{  
    double a1 = 1, b1 = 3;  
    double a2 = 1, b2 = 81;  

    printf(""result : %f\n"", a1 / b1 * b1); 
    printf(""result : %f\n"", a2 / b2 * b2);

    return 0;  
}  

Output is:
result : 1.000000
result : 1.000000
MFG
Martin
","For the first case, the exact result of the multiply is half way between 1.0 and the largest double that is less than 1.0. Under IEEE 754 round-to-nearest rules, half way numbers are rounded to even, in this case to 1.0. In effect, the rounding of the result of the multiply undid the error introduced by rounding of the division result.
This Java program illustrates what is happening. The conversions to BigDecimal and the BigDecimal arithmetic operations are all exact:
import java.math.BigDecimal;

public class Test {
  public static void main(String[] args) {
    double a1 = 1, b1 = 3;

    System.out.println(""Final Result: "" + ((a1 / b1) * b1));
    BigDecimal divResult = new BigDecimal(a1 / b1);
    System.out.println(""Division Result: "" + divResult);
    BigDecimal multiplyResult = divResult.multiply(BigDecimal.valueOf(3));
    System.out.println(""Multiply Result: "" + multiplyResult);
    System.out.println(""Error rounding up to 1.0: ""
        + BigDecimal.valueOf(1).subtract(multiplyResult));
    BigDecimal nextDown = new BigDecimal(Math.nextAfter(1.0, 0));
    System.out.println(""Next double down from 1.0: "" + nextDown);
    System.out.println(""Error rounding down: ""
        + multiplyResult.subtract(nextDown));
  }
}

The output is:
Final Result: 1.0
Division Result: 0.333333333333333314829616256247390992939472198486328125
Multiply Result: 0.999999999999999944488848768742172978818416595458984375
Error rounding up to 1.0: 5.5511151231257827021181583404541015625E-17
Next double down from 1.0: 0.99999999999999988897769753748434595763683319091796875
Error rounding down: 5.5511151231257827021181583404541015625E-17

The output for the second, similar, case is:
Final Result: 1.0
Division Result: 0.012345679012345678327022824305458925664424896240234375
Multiply Result: 0.9999999999999999444888487687421729788184165954589843750
Error rounding up to 1.0: 5.55111512312578270211815834045410156250E-17
Next double down from 1.0: 0.99999999999999988897769753748434595763683319091796875
Error rounding down: 5.55111512312578270211815834045410156250E-17

This program illustrates a situation in which rounding error can accumulate:
import java.math.BigDecimal;

public class Test {
  public static void main(String[] args) {
    double tenth = 0.1;
    double sum = 0;
    for (int i = 0; i < 10; i++) {
      sum += tenth;
    }
    System.out.println(""Sum: "" + new BigDecimal(sum));
    System.out.println(""Product: "" + new BigDecimal(10.0 * tenth));
  }
}

Output:
Sum: 0.99999999999999988897769753748434595763683319091796875
Product: 1

Multiplying by 10 rounds to 1.0. Doing the same multiplication by repeated addition does not get the exact answer.
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Break 2 [6]> (FactorialRec ""A"")
Argument must be a number.

It works on my machine. So I think you were passing A but not ""A""?
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
",Answer not found.,0.3093,[[0.01815168]],3.4042416167602025e-67,0.003636363636363636,0.011627906976744188,0.0,0.005813953488372094
"I installed LispCabinet and after the first start it tells me:
server-ensure-safe-dir: The directory `c:/Documents and Settings/Administrator/ApplicationData/.emacs.d/server' is unsafe
What does this mean, how did it come, is it dangerous and what can I do about it?
","I am working on a windows account with administrator permissions. The server directory in emacs.d was owned by the group ""Administrators"". I changed the ownership from the user group ""Administrators"" to be owned by the username I am currently working with (which is ""Administrator"") and the error message went away.
This solution is quite similar to the one given in this answer: https://stackoverflow.com/a/2944197/1312456
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 Confirmed.  I see the same behavior with ccl 1.9 (64-bit or 32-bit) on Mac OS X 10.8.
I created an empty subdirectory using mkdir 'a;b' and I see:
(make-pathname :directory '(:absolute ""Users"" ""gazonk"" ""foo"" ""*"") :name :wild))
> Error: Illegal directory string ""/Users/gazonk/foo/a;b/""
> While executing: CCL::%DIRECTORY-STRING-LIST, in process listener(1).

Update:
Based on Rainer's comment, it sounds like this is likely a ccl bug.
Recommend asking on the #ccl irc channel or submitting a bug report here (requires registration).
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Found your bug. Most of your functions are declared to receive the expression as the first argument and the bindings as the second one, yet on your example you are calling the function passing the bindings as the first argument and the expression as the second. You must either call (evalexp p1 '((x 2) (z 8))) or swap the argument order on your function definitions (I'd suggest this solution, as it seems more natural and looks like the assignment @rainer-joswig linked).
Particularly, subst-bindings and evalexp are the ones which need the change.
 I don't know where it's specified, but looking at the code shows that the queue functions are indeed thread safe.
The queue functions all expand into calls to DEFINE-LOCKING-FN which in turns expands to a DEFINE-LOCKING-FN/BASE which results in a DEFUN of the function with the content wrapped in a WITH-LOCK-HELD.
","The error message you're seeing indicates that Emacs (or a Lisp environment) has determined the specified directory (`c:/Documents and Settings/Administrator/ApplicationData/.emacs.d/server`) is unsafe. This usually means that the directory contains elements that could potentially be malicious or pose a security risk.

Here are some possible reasons for this:

1. **Permissions**: The directory might have incorrect permissions, allowing execution of scripts that could harm your system.
2. **Malicious Content**: There might be files in the directory that were not intended to be there and could be harmful if executed.
3. **Confusion with File Paths**: Sometimes, especially on Windows, the path might contain spaces or special characters which can cause issues.

To resolve this issue:

- **Check Permissions**: Ensure that only necessary users have write access to the directory.
- **Inspect Directory Content**: Manually check the contents of the `.emacs.d/server` directory to see if there are any suspicious files.
- **Reconfigure Emacs**: You might want to specify a different directory for server operations by setting `server-socket-dir`. For example, you can set it in your Emacs configuration file (`.emacs`) as follows:

  ```lisp
  (setq server-socket-dir ",0.5206,[[0.35390783]],0.06831769757394784,0.3136205510231916,0.2471042471042471,0.05447470817120622,0.12355212355212356
"I have a string like ""2d 6:36"", and I want to multiply that amount of hours by a constant.
This means I want this to be calculated:
(2*24 + 6 + 36/60) * constant

or, in general
(d*24 + h + m/60)

Any help?
Edit: I only have the string not, the d, h and m.
","You need parse your string in something useful, for example a list of integers, you can use cl-ppcre for this:
(defun parse-day-and-time (string)
  ""Get string like 3d 23:40 and return list (3 23 40)""
  (multiple-value-bind (str matches)
    (cl-ppcre:scan-to-strings ""(\\d+)d ([0-9]|0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])"" string)
    (declare (ignore str))
    (when (< (length matches) 3)
      (error ""Wrong day and time string: ~A"" string))
    (map 'list #'parse-integer matches)))

Then you can do yout calculation:
(defun mult-time (string-time coeff)
  (destructuring-bind (days hours minutes)
    (parse-day-and-time string-time)
    (* coeff (+ (* 24 days) hours (/ minutes 60)))))

CL-USER> (mult-time ""2d 6:36"" 300)
16380

Of cause if you want to do some more calculations with your time, may be it will be better to represent it as amount of seconds, do your calculation with it, then return it in any string you want.
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The cut is not used for efficiency, but to commit to the first solution (see the comment next to the !/0: ""single solution: longest input match""). If you comment out the !/0, you get for example:
?- parse(""abc"", E).
E = [s(abc)] ;
E = [s(ab), s(c)] ;
E = [s(a), s(bc)] ;
E = [s(a), s(b), s(c)] ;
false.

It is clear that only the first solution, consisting of the longest sequence of characters that form a token, is desired in such cases. Given the example above, I therefore disagree with ""false"": expression//1 is ambiguous, because number//1 and symbolr//1 are. In Mercury, you could use the determinism declaration cc_nondet to commit to a solution, if any.
 In the book, authors have an example of formulating an iterative process for computing the Fibonacci numbers.
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))

The point here is that use two parameter a and b to memorise f(n+1) and f(n) during computing. The similar could be applied: we need a, b, c to memorise f(n+2), f(n+1) and f(n)
;; an interative process implementation                                                                                                                       
(define (f-i n)                                                                                                                                               
  ;; f2 is f(n+2), f1 is f(n+1), f0 is f(n)                                                                                                                   
  (define (interative-f f2 f1 f0 count)                                                                                                                       
    (cond                                                                                                                                                     
      ((= count 0) f0)                                                                                                                                         
      (else (interative-f                                                                                                                                      
              (+ f2 (* f1 2) (* f0 3))                                                                                                                          
              f2                                                                                                                                                
              f1                                                                                                                                                
              (- count 1)))))                                                                                                                                   
  (interative-f 2 1 0 n))             

 The code, after being printed and read back, is no longer the same code.  In particular, the two instances of #:G2867 in the printed representation would be read back as two separated symbols (albeit sharing the same name), while they should be the same in the original internal representation.
Try setting *PRINT-CIRCLE* to T to preserve the identity in the printed representation of the macro-expanded code.
 One problem is you have your < and > reversed. Assuming you want your left sub tree to be the smaller, then (< value (car tree)) should call again with the (cadr tree).
Also you should use #t instead of (#t).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","To achieve this, you can parse the string into its components (d, h, m) first. Here's an example of how you could do it in Lisp using a combination of string operations and arithmetic:\n\n1. Parse the string to extract d, h, and m.\n2. Convert them to their numerical equivalents.\n3. Perform the calculation.\n\nHere’s a sample implementation:\n```lisp\n(defun parse-time (time-str constant)\n  (let* ((parts (cl-ppcre:split ",0.5677,[[0.40712615]],0.04733397928022969,0.1431540060032325,0.2727272727272727,0.03333333333333334,0.14876033057851243
"I'm writing a function that returns elements which appear in one list and not in another. For example,
(except '(a b c) '(a d b e f))

will return '(c). The first argument can be an atom, and both are assumed to be flat. Here's my code:
(define (except lm ln)
  (cond ((null? ln) lm)
        ((not (list? lm))
         (cond ((in? lm ln) '())
               (#t lm)))
        ((null? lm) '())
        ((in? (car lm) ln) (except (cdr lm) ln))
        (#t (cons (car lm) (except (cdr lm) ln)))))

Then an error returns saying ""except: misuse of unit import keyword in: (except (cdr lm) ln)"". 
Why this is happening?
","Looks like you're running into some problem with the unit library which has an except keyword defined.  But it should still be possible to use it as a name for your function, so I'm guessing that something else is wrong.  It'll be possible to say more if you provide the complete code that you're trying to run.
","Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You've got it almost right. However, you're terminating your list with 0, when the correct termination is nil. This code works:
(defun vecmul (list list2)
  (cond ((null list) nil)
     (t (cons (* (car list) (car list2)) (vecmul (cdr list) (cdr list2))))))

When you call (cons 1 2), the cons cell you get is written (1 . 2). the notation (1 2 3 4 5) is just shorthand for (1 . (2 . (3 . (4 . (5 . nil))))). If the cdr of the last cons cell is 6, not nil, then you get (1 . (2 . (3 . (4 . (5 . 6))))), which shortens to (1 2 3 4 5 . 6).
 nconc is a destructive operation that alters its first argument by changing its tail. In this case, it means that the constant list '(oh my) gets a new tail.
To hopefully make this clearer. It's a bit like this:
; Hidden variable inside exclaim
oh_my = oh → my → nil

(exclaim '(lions and tigers and bears)) =
    lions → and → tigers → and → bears → oh_my

(nconc * '(goodness)) destructively appends goodness to the last result:
    lions → and → tigers → and → bears → oh → my → goodness → nil
so now, oh_my = oh → my → goodness → nil

Replacing '(oh my) with (list 'oh 'my) fixes this because there is no longer a constant being shared by all and sundry. Each call to exclaim generates a new list (the list function's purpose in life is to create brand new lists).
","The issue lies in the incorrect use of keywords within the `cond` expressions. In Scheme/Lisp, you should not use parentheses around the condition and result pairs. The correct structure for a `cond` expression is to have each clause on a separate line with no surrounding parentheses. Here's how your function should look:",0.5269,[[0.1910053]],0.09505042875135826,0.3286501538341707,0.24347826086956523,0.017699115044247787,0.12173913043478261
"I've added this code snippet to my stumpwmrc file:
(defun load-swank ()
  ""Load a swank server""
  (ql:quickload 'swank)
  (require 'swank)
  (setq swank:*use-dedicated-output-stream* nil)
  (setq slime-net-coding-system 'utf-8-unix)
  (swank:create-server :port 4006))
(load-swank)

I am expecting to open a socket server, accepting the ""swank"" protocol. Thus I could connect to it with emacs (thanks to Slime).
But when I login and and stumpwm is reading its configuration file, here is the error message I get:
15:00:34 Outputting a message:
         ^B^1*Error loading ^b/home/ybaumes/.stumpwmrc^B: ^nThe name ""SWANK"" does not designate any package.

How can I fix that? I invoke 'require, or even 'quickload functions. What's the issue here?
","A typical error is this:
You load the file and the reader sees the code:
SWANK is not loaded
(defun load-swank ()
  ""Load a swank server""

SWANK is not loaded
  (ql:quickload 'swank)

SWANK is not loaded - remember, we are still reading the form.
  (require 'swank)

SWANK is not loaded - remember, we are still reading the form.
Now use us a symbol in package which is not existing... the reader complains:
  (setq swank:*use-dedicated-output-stream* nil)  ; the package SWANK does not exist yet.

  (setq slime-net-coding-system 'utf-8-unix)
  (swank:create-server :port 4006))

Now you want to load SWANK:
(load-swank)

You can't use a symbol from a package which does not exist.
For example what works is this inside the function:
(setf (symbol-value (read-from-string ""swank:*use-dedicated-output-stream*"")) nil)

and so on.
You need to find the symbol at runtime of that function. Use (find-symbol ""FOO"" ""SWANK"") (remember Common Lisp is upcase internally) or (read-from-string ""SWANK::FOO"").
","I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
",Answer not found.,0.3681,[[0.08461696]],4.340012667907315e-32,0.0064350064350064354,0.011494252873563218,0.0,0.011494252873563218
"What is the best way to do GUIs in Clojure?
Is there an example of some functional Swing or SWT wrapper?
Or some integration with JavaFX declarative GUI description which could be easily wrapped to s-expressions using some macrology?
Any tutorials?
","I will humbly suggest Seesaw. 
Here's a REPL-based tutorial that assumes no Java or Swing knowledge.

Seesaw's a lot like what @tomjen suggests. Here's ""Hello, World"":
(use 'seesaw.core)

(-> (frame :title ""Hello""
       :content ""Hello, Seesaw""
       :on-close :exit)
  pack!
  show!)

and here's @Abhijith and @dsm's example, translated pretty literally:
(ns seesaw-test.core
  (:use seesaw.core))

(defn handler
  [event]
  (alert event
    (str ""<html>Hello from <b>Clojure</b>. Button ""
      (.getActionCommand event) "" clicked."")))

(-> (frame :title ""Hello Swing"" :on-close :exit
           :content (button :text ""Click Me"" :listen [:action handler]))
  pack!
  show!)

","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
 In Python you create an object by calling the constructor, a function that has the same name as the class. The exact same applies in Hy.
(import sys)
(import [PySide.QtGui [QApplication]])

(setf app (QApplication sys.argv))

Notes:

You assign the object created with setf
Be sure to import all the necessary modules

","The context provided does not directly relate to your question about the best way to do GUIs in Clojure. However, for creating GUI applications in Clojure, you can use libraries such as SWCL (Swing with Clojure), which is a set of tools and macros that allow you to create Swing-based GUIs using a more idiomatic Clojure syntax. Another option is using JavaFX with Clojure, where you can leverage the power of JavaFX's declarative GUI description while wrapping it in s-expressions through macrology.

For example, SWCL allows you to define Swing components and layouts using macros like `defpanel`, which helps in creating more readable and maintainable code. Here is a simple example:

```clojure
(require '[swcl.swing :as swing])

(defpanel main-panel []
  (let [label (swing/label ",0.5374,[[0.08737183]],0.08084548730453962,0.25846124808898846,0.14414414414414414,0.0,0.0990990990990991
"I am attempting to assign the variable a the parameter (list) in my function. I keep getting variable L has no value, how can I assign the variable inside the function the list parameter?
   (defun pali(list)
    (defvar a nil)
    (defvar b nil)
    (setq a (list))
    (setq b (reverse list))
    )

","If I'm understanding correctly, what you want is
(defun pali (list)
   (let ((a list))
        ((b (reverse list)))
     ...))

It's almost certainly wrong to put DEFVAR inside a function, and likely to hurt you badly if you use DEFVAR with names like A and B. DEFVAR makes a global variable, and it makes the symbol that names it ""special""; everywhere you use it in future, you'll be getting the symbol-value instead of a lexical variable. Strange things will happen when you're not expecting it. That's why DEFVAR variables are usually named like A, etc., instead of just A. Use LET to make a normal lexical variable. And then there's not a lot of point setting it to NIL initially and then using SETQ to alter it, though you can do that if you like. Even just
(let (a b)
   (setq a list
         b (reverse list))
   ...)

if that's what you want [Note you can use a single SETQ to set many variables. Don't have to, of course]
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 The error in your code is that you're assigning a list as a fdefinition instead of a function. I would consider it a bug in your implementation though that this is causing a segfault. (I'm not sure if it is actually a bug in the sense that it's violating the standard, but it would definitely be much nicer if the implementation would catch and report this error itself.)
To turn the list starting with lambda into a function, you need to evaluate it. On the other hand, the eval around the setf doesn't seem to be necessary at all. So a possible solution is to switch the positions of the eval and setf:
(setf (fdefinition name) (eval `(lambda (this ,@args) ,@body)))

 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

","In your function definition, you are trying to assign the parameter `list` directly with `(list)`, which is incorrect. Instead, you should use the parameter name `list` within the function body to reference the passed list. Here's how you can correct it:\n\n```lisp\n(defun pali (list)\n  (defvar a nil)\n  (defvar b nil)\n  (setq a list)\n  (setq b (reverse list))\n  (equal a b))\n```\nThis will correctly assign the passed `list` to variable `a`. Note that you also need to compare `a` and `b` at the end of the function, as this is likely what you intended.",0.5781,[[0.49376819]],0.1348142279901823,0.22633244098320757,0.3826714801444044,0.07999999999999999,0.18050541516245489
"Is there a way in Lisp to include code from other Lisp files?
For example, in C++ I can do this:
#include <iostream>
#include <string>
#include ""myfile.h""
etc...

And in Python,
import antigravity
import my_module
etc...

Is there a Lisp equivalent?
","In addition to Rainer's answer:
If you want to load ASDF-systems, use:
(asdf:load-system 'my-system)

Some Lisp implementations (CCL for example) also allow using require for loading ASDF systems, but that functionality is implementation dependent.  If you are using Slime, and want to load a system interactively, you can do so by typing ,l my-system at the Slime REPL.
Another thing I wanted to point out is that, unlike in Python, using require or load in CL does not have anything to do with packages (think ""namespaces"").  So, if the code you are loading or requiring lives in its own package, you will either have to use its exported symbols qualified (foo:bar), or include those packages in the package your code lives in ((defpackage my-package (:use cl package-you-want-to-use ...) ...)). This does not only differ from Python imports, but also from C preprocessor #includes, the latter being mere textual inclusions.
","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 In my Emacs, function kill-sexp is bound to C-M-k. That is, assuming the point is just before an opening delimiter of a balanced expression, press Control, Meta, and k at the same time.
This same command works in various other non-Lisp modes, such as killing brace-delimited blocks in a C-style mode, though the kill-sexp command may not be bound to the same keys.
 In ANSI Common Lisp:
(sort (copy-list '((a 22) (b 2) (c 5)))  #'< :key #'second)
-> ((B 2) (C 5) (A 22))

The copy-list is there because sort clobbers the input list. We need that because our input list is a literal, but even if it isn't, sometimes you don't want to scramble the original object that you wish to sort.
 As I understand it you want to invoke the list_image with two arguments, --eval and '(package::method \""some_argument\"")' where the single quotes is just there to prevent the shell from breaking it up into multiple arguments.
Then you should use
Runtime.getRuntime().exec(new String[] {""lisp_image"", ""--eval"", ""(package::method \""some_argument\"")""});

 In Python there is no primitive operation that modifies a file “in-place”; instead,
there is a function of an helper class fileinput, that gives the illusion of
modifying a file in place by first copying the file to a backup file, and then
reading the backup file and writing the result of processing it to the original one. From the manual:

Optional in-place filtering: if the keyword argument inplace=1 is passed
  to fileinput.input() or to the FileInput constructor, the file is moved
  to a backup file and standard output is directed to the input file
  (if a file of the same name as the backup file already exists,
  it will be replaced silently).
  This makes it possible to write a filter that rewrites its input file in place.
  If the backup parameter is given (typically as backup='.'),
  it specifies the extension for the backup file, and the backup file remains
  around; by default, the extension is '.bak' and it is deleted when the output
  file is closed. In-place filtering is disabled when standard input is read.

So, the way of doing this operation in Common Lisp is to mimic the
Python code, by first copying the file to a backup file, for instance using this function my-copy-file, then writing the following code:
(defun in-place-subst (file)
  (let ((backup-file (concatenate 'string file "".bak"")))
    (my-copy-file file backup-file)
    (with-open-file (in-stream backup-file)
      (with-open-file (out-stream file :direction :output :if-exists :supersede)
        (loop for line = (read-line in-stream nil)
           while line do
             (write-line (cl-ppcre:regex-replace-all ""foo"" line ""bar"") out-stream))))))

 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

","In Common Lisp, you can include code from other files using the `load` or `compile-file` functions. The `load` function loads and evaluates forms from a file, while `compile-file` compiles the file into a fasl (fast load) file. For instance, if you have a file named `my-code.lisp`, you can include its code in your current session by evaluating `(load \",0.5484,[[0.27850477]],0.04450911563048068,0.15386869871043374,0.2986425339366516,0.0273972602739726,0.14479638009049775
"I am trying to write a sorting code in lisp language.
But I am not sure how to do it.
I want to use sort function of lisp using sequence.
I am trying to create sequence like this-
(setq arr (make-sequence '(vector integer) 10   :initial-element (read)))
(terpri)
(write arr)

This will set the initial element to user input. But I want to take input from the user and I have no idea how to do it. Any suggestion will be helpful.
","You can make vectors with MAKE-ARRAY. You can set its fill-pointer to 0, and then use a loop to add 10 numbers to it with VECTOR-PUSH:
(let ((vec (make-array 10 :fill-pointer 0)))
  (dotimes (i 10 vec)
    (format *query-io* ""Number ~d/10: "" (1+ i))
    (finish-output *query-io*)
    (vector-push (parse-integer (read-line *query-io*)) vec)))

You could also achieve the same like this:
(make-array 10 :initial-contents
            (loop
               for i from 1 to 10
               do (format *query-io* ""Number ~d/10: "" i)
               do (finish-output *query-io*)
               collecting (parse-integer (read-line *query-io*))))

But that creates a temporary list for the input.
Also, as Svante suggested, you can use MAP-INTO:
;; If you don't want the number in the prompt, you can remove the LET
(let ((i 0))
  (map-into (make-array 10)
            (lambda () 
              (format *query-io* ""Number ~d/10: "" (incf i))
              (finish-output *query-io*)
              (parse-integer (read-line *query-io*)))))

","The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The sort function accepts a predicate that will be used to tell when an element precedes another (see the hyperspec).
So, define a function compare-3rd:
(defun compare-3rd (a b)
  (< (nth 2 a) (nth 2 b)))

And use it as the predicate:
(sort '(( (1 2 3) nil 4)
    ( (1 2 3) nil 2)
    ( (1 2 3) nil 3))
      'compare-3rd)

==> (((1 2 3) NIL 2) ((1 2 3) NIL 3) ((1 2 3) NIL 4))

Of course, if you want descending order you may use > instead of < in compare-3rd.
 read-char will return the next available character, and read-line will return an entire line of input as a string. You can use coerce to change a string to a list of characters, e.g.
(coerce ""foo"" 'list) => (#\f #\o #\o)

 Use with-input-from-string. 
(with-input-from-string (s ""4 3 2"")
  (let ((a (read s))
        (b (read s))
        (c (read s)))
    (format t ""~a, ~a, ~a~%"" a b c))) 

You could also just read from a file, but reading from a string is much easier for making different test cases.
 You can first read-sequence (if you know the length ahead of time) or read-bytes while there are some, and then convert them to string with (babel:octets-to-string octets :encoding :utf-8)) (where octets is (make-array expected-length :element-type '(unsigned-byte 8))).
","To create a sequence with elements initialized based on user input in Lisp, you can use the `make-sequence` function combined with `loop`. Here is an example of how to achieve this for a vector of integers where each element is read from the user. This approach allows you to dynamically fill the vector with user-provided values.\n\n```lisp\n(defun get-user-input-vector (length)\n  (let ((vector (make-sequence '(vector integer) length :initial-element 0)))\n    (loop for i below length do\n          (format t \",0.5928,[[0.22418244]],0.05504205295927137,0.18129307328208327,0.3187250996015936,0.048192771084337345,0.1593625498007968
"I'm new to lisp and I'm looking for a function to do a stored in place adjoin, is there any? i found the pushnew macro but it seems to work on items not lists.
(pushnew '((1)) '((1) (1 2) (1 2 3)))
(pushnew '(1) lst) => ((1) (1) (1 2) (1 2 3))

","PUSHNEW is the modifying version of ADJOIN. You need to use the proper :TEST argument for comparing the kind of elements the list contains (such as #'EQUAL for lists).
CL-USER> (defparameter *list* (list (list 1)
                                    (list 1 2)
                                    (list 1 2 3)))
*LIST*
CL-USER> (adjoin '(1) *list*)                ; Adds
((1) (1) (1 2) (1 2 3))
CL-USER> (adjoin '(1) *list* :test #'equal)  ; Doesn't add
((1) (1 2) (1 2 3))
CL-USER> (pushnew '(1) *list*)               ; Pushes
((1) (1) (1 2) (1 2 3))
CL-USER> *list*
((1) (1) (1 2) (1 2 3))
CL-USER> (pushnew '(1) *list* :test #'equal) ; Doesn't push
((1) (1) (1 2) (1 2 3))

","I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

","For adding lists into a list of lists, you can use `push` instead of `pushnew`. The `pushnew` function is designed to add an item if it's not already in the list, but `push` adds an element at the beginning of a list. Here's how you can use `push` to add a list into another list of lists:\n\n```lisp\n(defun r (list-of-lists new-list)\n  (let ((result nil))\n    (dolist (sublist list-of-lists result)\n      (push sublist result))\n    (push new-list result)\n    result))\n\n(r '((1) (2) (3)) '(4 5))) ;; => ((1) (2) (3) (4 5))\n```\nAlternatively, you can use `append` to concatenate the lists but be mindful of performance implications for large lists.",0.6027,[[0.41238518]],0.12801784916695771,0.27986839846566036,0.3206751054852321,0.0425531914893617,0.2109704641350211
"I have program that runs for long periods of time and I'd like to interrupt it but not with ctrl-c ctrl-c. I also don't want the system to wait for a keystroke every so often. Instead, if I do press a key, I want it to wrap things up and exit. I found listen and read-char-no-hang but I can't get it to work right. Here's what I tried to do
(let ((f nil))
  (loop while (not f) do
     (if (listen)
       (setf f t)))))

Obviously, this is doing less than a sloth on Xanax as far as finding key=-presses. What am I doing wrong?
","CCL has multithreading, I believe. You could try spawning a worker thread in the background and have a control thread doing a blocking read, and then communicating via a special variable.  The following works in Lispworks, I don't have CCL available.  You'd have to translate the mp:process-run-function to whatever CCL uses to spawn threads:
(defparameter *f* nil)
(defun cmd-loop ()
  (setf *f* nil)
  (mp:process-run-function ""work"" () #'do-work)  ; Spawn worker
  (read-char *terminal-io*)                      ; Blocking read
  (setf *f* t))
(defun do-work ()
  (loop while (not *f*)
        do 
          (format t ""~a "" *f*)
          (finish-output)))
(cmd-loop)

The big assumption I'm making here is that CCL multithreading works similarily to LW multithreading, so that both threads can access the shared state variable *f*.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 If you just want to mutate the argument structure object:
(defun dec (s)
  (decf (first (spider-values s)))  ; mutates the list of values
  (pop (spider-continuation s))
  s)

 Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
","To achieve your goal of interrupting a long-running program based on key presses without waiting for a keystroke and without using ctrl-c ctrl-c, you can use a combination of `listen` and `read-char-no-hang`. However, the issue in your code is that it doesn't handle the character correctly. Here’s how you can do it:\n\n```lisp\n(defun my-interrupt-handler ()
  (let ((char (read-char-no-hang)))
    (when (eq char #\q)   ; Example: exit on pressing 'q'
      (format t ",0.5891,[[0.18148116]],0.11893857290823392,0.20909497585882428,0.23364485981308414,0.02830188679245283,0.12149532710280374
"I'm trying to implement the Towers of Hanoi.I'm not printing out anything between my recursive calls yet, but I keep getting an error saying 

'('(LIST) 'NIL 'NIL) should be a lambda expression

I've read that the reason this happens is because of a problem with the parenthesis, however I cannot seem to find what my problem is. I think it's happening in the pass-list function when I am trying to call the hanoi function.  My code:
(defun pass-list(list)
   (hanoi('('(list)'()'())))
)

(defun hanoi ('('(1) '(2) '(3)))

    (hanoi '('(cdr 1) '(cons(car 1) 2) '(3)))

    (hanoi '('(cons(car 3)1) '(2)'(cdr 3)))
 )

","This code has many syntax problems;  there are erroneous quotes all over the place, and it looks like you're trying to use numbers as variables, which will not work.  The source of the particular error message that you mentioned comes from 
(hanoi('('(list)'()'())))

First, understand that the quotes in  'x and '(a b c) are shorthand for the forms (quote x) and (quote (a b c)), and that (quote anything) is the syntax for getting anything, without anything being evaluated.  So '(1 2 3) gives you the list (1 2 3), and '1 gives you 1. quote is just a symbol though, and can be present in other lists, so '('(list)'()'()) is the same as (quote ((quote (list)) (quote ()) (quote ()))) which evaluates to the list ((quote (list)) (quote ()) (quote ())).  Since () can also be written nil (or NIL), this last is the same as ('(list) 'NIL 'NIL).  In Common Lisp, function calls look like
(function arg1 arg2 ...)

where each argi is a form, and function is either a symbol (e.g., list, hanoi, car) or a list, in which case it must be a lambda expression, e.g., (lambda (x) (+ x x)).  So, in your line
(hanoi('('(list)'()'())))

we have a function call.  function is hanoi, and arg1 is ('('(list)'()'())).  But how will this arg1 be evaluated?  Well, it's a list, which means it's a function application.  What's the function part?  It's 
'('(list)'()'())

which is the same as 
'('(list 'NIL 'NIL))

But as  I just said, the only kind of list that can be function is a lambda expression.  This clearly isn't a lambda expression, so you get the error that you're seeing.  
I can't be sure, but it looks like you were aiming for something like the following.  The line marked with ** is sort of problematic, because you're calling hanoi with some arguments, and when it returns (if it ever returns;  it seems to me like you'd recurse forever in this case), you don't do anything with the result.  It's ignored, and then you go onto the third line.
(defun pass-list(list)
  (hanoi (list list) '() '()))

(defun hanoi (a b c)
  (hanoi (rest a) (cons (first a) b) c)  ; **
  (hanoi (cons (first c) a) b (rest c)))

If hanoi is supposed to take a single list as an argument, and that list is supposed to contain three lists (I'm not sure why you'd do it that way instead of having hanoi take just three arguments, but that's a different question, I suppose), it's easy enough to modify;  just take an argument abc and extract the first, second, and third lists from it, and pass a single list to hanoi on the recursive call:
(defun hanoi (abc)
  (let ((a (first abc))
        (b (second abc))
        (c (third abc)))
    (hanoi (list (rest a) (cons (first a) b) c))
    (hanoi (list (cons (first c) a) b (rest c)))))

I'd actually probably use destructuring-bind here to simplify getting a, b, and c out of abc:
(defun hanoi (abc)
  (destructuring-bind (a b c) abc
    (hanoi (list (rest a) (cons (first a) b) c))
    (hanoi (list (cons (first c) a) b (rest c)))))

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 As mentioned in first comment it is necessarily to use (list a b c) form.
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

",Answer not found.,0.335,[[0.01112982]],1.3887803392820635e-107,0.002260397830018083,0.003717472118959108,0.0,0.003717472118959108
"I am new to lisp. I am trying to read numbers from user and want to store it as a list. For example: if the user enters 1 2 3 4 5, then the list would contain 5 elements (1 2 3 4 5). I tried (parse-integer(read-line) :junk-allowed t) but it returns only the first element. How should I do this? Thanks.
","Use read
The simplest option is to ask the user to enter the list (with the parens) and just call (read).
The second option is to put the parens yourself:
(read-from-string (concatenate 'string ""("" (read-line) "")""))

safety and security
Note that the power of the Lisp reader can put you in trouble. E.g., if the user types #.(start-ww3) instead of (1 2 3) at your prompt, you might not reach your bomb shelter in time.
This means that you must bind *read-eval* to nil when calling read on text you do not control.
Call parse-integer repeatedly
Finally, you can call parse-integer in a loop
(defun parse-integers (s &optional (start 0))
  (loop with num do 
    (setf (values num start) (parse-integer s :start start :junk-allowed t))
    while num collect num))

or recursively:
(defun parse-integers (s &optional (start 0))
  (multiple-value-bind (num end) 
      (parse-integer s :start start :junk-allowed t)
    (and num (cons num (parse-integers s end)))))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 Use read
The simplest option is to ask the user to enter the list (with the parens) and just call (read).
The second option is to put the parens yourself:
(read-from-string (concatenate 'string ""("" (read-line) "")""))

safety and security
Note that the power of the Lisp reader can put you in trouble. E.g., if the user types #.(start-ww3) instead of (1 2 3) at your prompt, you might not reach your bomb shelter in time.
This means that you must bind *read-eval* to nil when calling read on text you do not control.
Call parse-integer repeatedly
Finally, you can call parse-integer in a loop
(defun parse-integers (s &optional (start 0))
  (loop with num do 
    (setf (values num start) (parse-integer s :start start :junk-allowed t))
    while num collect num))

or recursively:
(defun parse-integers (s &optional (start 0))
  (multiple-value-bind (num end) 
      (parse-integer s :start start :junk-allowed t)
    (and num (cons num (parse-integers s end)))))

",You can read a list of numbers from user input by using read-from-string and concatenate the inputs into a proper list structure. Here's an example of how you might do this in Lisp:\n\n```lisp\n(defun read-list-of-numbers()\n  (let ((input (read-line)))\n    (read-from-string (concatenate 'string \,0.5854,[[0.28245304]],0.03351933568675854,0.13279019817742643,0.25112107623318386,0.07239819004524888,0.11659192825112107
"In some implementations of Common LISP we can say that for the following expression
(eq 'a 'a)

Is true because 'a and 'a are the ""same atom"". 
This may be implementation dependent, but it seems the phrase (used in a popular LISP teaching book) assumes that atoms of the same value are stored in the same location in memory. 
In Java, two interned strings of the same value are stored in the same location in memory. 
Now Clojure on the JVM inherits Java's legacy, but is it true to say that two atoms in Clojure (on JVM) having the same value are the same atom? (ie how does Clojure's atom storage mechanism work?)
","First, ""atom"" has a different meaning in Clojure than in most other Lisps. See http://clojure.org/atoms
Clojure's = function uses value-based equality. So two objects with equal values will be = even if they are stored in different locations in memory.
To test if two objects are actually the same object, at the same address in memory, use the identical? function.
","According to https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Lexical-Binding.html, even when lexical-binding is non-nil, special variables (like x since it was defined with defvar) are still dynamically bound.
 The loop/recur version is the right way.  Clojure cannot optimize tail calls due to limitations of the JVM. 
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 In Clojure, the atom predicate isn't so important because Clojure emphasizes various other types of (immutable) data structures rather than focusing on cons cells / lists. 
It could also cause confusion. How would you expect this function to behave when given a hashmap, a set or a vector for example? Or a Java object that represents some complex mutable data structure? 
Also the name ""atom"" is used for something completely different - it's one of Clojure's core concurrency mechanisms to manage shared, synchronous, independent state.
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Ben Hyde noted in a comment that R. Matthew Emerson spoke to this issue on the Clozure mailing list, pointing out that Clozure CL's default external format has been changed to :utf-8.  As a result, he  suggested this alternative:

We changed the default external format to :utf-8 in the 1.9 release. 
  This is probably tripping you up.
       Try specifying an appropriate external-format explicitly, e.g.,
(defun test (file)
  (with-open-file (stream file :external-format :iso-8859-1)
    (loop while (read stream nil nil))))


","In Clojure running on the JVM, atoms with the same value are not necessarily stored at the same memory location. Unlike some implementations of Common Lisp where 'a' and 'a' might be stored in the same place if they are interned symbols, Clojure does not automatically intern all identical values. The concept of interning is more relevant to immutable objects like strings or symbols that can be shared across the program. For atoms (which are mutable), each one maintains its own identity and state independent of other atoms with the same value. This design choice in Clojure aligns with its focus on immutability and functional programming principles.",0.5644,[[0.40260318]],0.15344024363780742,0.3355481727574751,0.37647058823529406,0.08333333333333333,0.2
"Recently, I was reading article ""Root Of Lisp"" from Paul Graham.I encountered some questions.From the book, it defines expression as two :1.atom;2.list, while list is consisted of zero or many expressions.Then it sayes that a list can be evaluated.Now I hava some problems:

Can every list be evaluated?Is every list an expression?
If a list can be evaluated, then it may have its first element  as an operator,so an operator is an expression?Is operator atomic or another?
The operator car returns the first element of a list, if the list can be evaluated, then what will it return , the operator?Can you give me some sample of this to show how to use the returned value?
The operator cdr returns elements besides the first element as a list,then this returned list can't be evaluated?

I am a freshman for Lisp,I don't know whether I hava explained my problems clearly.
","A Lisp S-expression (sexp) is either an atom, or a list of sexps.
1
All Lisp forms (that is, things that can be evaluated) are sexps, but not all sexps are Lisp forms.
More specifically, a Lisp form is any atom, or a list whose first element is a symbol.
(foo 42)       ; valid Lisp form
(undefined 42) ; Lisp form, but invalid because of undefined function
(42 foo)       ; not a Lisp form - numbers aren't symbols

2
As I just mentioned, the ""operator"" (first element) of a list-that-is-a-Lisp-form must be a symbol. (A Lisp-1 (e.g. Scheme) allows any Lisp form in the operator position, but Roots of Lisp is discussing the original (a Lisp-2), and Common Lisp (a Lisp-2); they restrict the operator position to symbols.)
3
Lisp code, before compilation, is Lisp data. That is important.
If I said (car 'foo), the program would complain; and rightly so, because foo isn't a list.
If I said (car '(car 'foo)), the inner list is not evaluated (good old quote syntax '), and car extracts the thing in the operator position - in this case, the symbol car. This can be useful when defining macros.
4
Depends.
First, imagine I have foo defined as a function of two arguments, and bar defined as both a variable and a function of one argument. Also remember that, under the hood, your Lisp is probably calling eval on whatever you type in.
Now (eval '(foo bar 42)) is valid, and will invoke foo with arguments <the value of bar> and 42. (eval (cdr '(foo bar 42))) is also perfectly valid; it is equivalent to (eval '(bar 42)), which invokes bar with the argument 42.
If bar were not defined as a function, the cdr of the second example would still produce a valid Lisp form, but it would be an error to evaluate that form, as (bar 42) invokes the function bar (there isn't one).
It is useful to talk about syntax and semantics. Syntactically, any atom, or any list with a symbol in operator position, is valid. Semantically (inside the bounds of the syntax), any atom that is a symbol with no variable definition is an error; so is any list whose first element is a symbol with no function definition.
I hope this answer helps you out.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 If it's capable of modifying the list passed to it, then it's destructive.
If a function takes a list via a symbol, it should be automatically assumed to be destructive, no?  Otherwise why not just take the list itself?
 An empty list is simply the nil symbol (and symbols, by definition, are not conses). car and cdr are defined to return nil if given nil.
As for list-mutation functions, they return a value that you are supposed to reassign to your variable. For example, look at the specification for the nreverse function: it may modify the given list, or not, and you are supposed to use the return value, and not rely on it to be modified in-place.
Even nconc, the quintessential destructive-append function, works that way: its return value is the appended list that you're supposed to use. It is specified to modify the given lists (except the last one) in-place, but if you give it nil as the first argument, it can't very well modify that, so you still have to use the return value.
 The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

","Not every list is an expression that can be evaluated. In Lisp, only lists whose first element is a symbol representing a function (i.e., an operator) or a special form (like quote, if, lambda, etc.) can be evaluated as expressions. Atoms like numbers and strings are not functions and cannot be directly evaluated unless they are part of a list with a proper operator. For example, the expression `(car '(1 2 3))` will return `1`, because `car` is an operator that takes a list and returns its first element. The returned value in this case is `1`, which is an atom (not another list) and thus not evaluable as an expression on its own.",0.5738,[[0.479595]],0.032574434797481344,0.1424524196509307,0.3300589390962672,0.09467455621301775,0.1650294695481336
"In Lisp (I am still learning Lisp with SBCL), local variables are declared with let, and the scope is only within that expression.  Why is that?  Unlike in other imperative languages like C/C++/Java..., where we can freely use local variables anywhere in its function scope.
","Just another little insight into what let is. It is basically an application of an anonymous function ""spelled backwards"".
I will use JavaScript for the illustration because it is more C-like language and it illustrates the concept quite well.
(function(variableA, variableB){
  console.log(""variableA = "" + variableA);
  console.log(""variableA * variableB = "" + variableA * variableB);})(6, 7);

Now, let's name the parts: from function to ;} is the function definition. (definition)(arguments) is the application. Let expression does essentially the same thing, i.e. it invokes an anonymous function with arguments, which you use inside that function as variables. So, if you consider the previous example, rewriting it in let form would make something like:
(let(variableA = 6, variableB = 7){
  console.log(""variableA = "" + variableA);
  console.log(""variableA * variableB = "" + variableA * variableB);});

(JavaScript doens't support let, yet, so above isn't a working code example, but it should be an illustration)
You should also note that it is not exactly that simple. Because in more complex cases you  may want to reference one of the arguments when constructing another - and then you would use (let* ...), or you would want to use functions as arguments of this expression, and then you would use (flet ...) or (labels ...). But the general idea is the same.
","You need to assign the variables before you can use them.
(defvar a 10)
(defvar b 20)
(defvar c 30)
(list 1 2 3 (list a b c))

This should return:
(1 2 3 (10 20 30))

When you use LET, it creates local variables, and their scope is just the body of the LET.
(let ((a 1) (b 2) (c 3))
  (list 1 2 3 (list a b c)))
=> (1 2 3 (1 2 3))

 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 Enclose your call to f in a module clause in a.rkt:
#lang racket
(provide f)
(define (f) 10)
(module+ main
  (f))

The forms in the module+ main part will only be executed when you run a.rkt directly, not when you require it.
For more info see here.
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 You are using the ""extended"" loop form, so you need to do 
(loop while ...
  do ...)

instead of
(loop while ...
  ...)

This is what the error is telling you: it wants a keyword after while condition, and it found the first statement of the body.
You might want to review The LOOP Facility more carefully.
PS. Please bind local variables using let or, in loop, with, before setting them with setq. Otherwise your variables are global specials.
PPS. Please indent your code properly; you can use Emacs for that.
","In Lisp, particularly in the dialects like Common Lisp and SBCL (which follows these principles), the `let` form is used to create local variables. The scope of these variables is limited to the expression or block where they are defined. This differs from imperative languages like C/C++/Java because in those languages, when you declare a variable within a function, it can be accessed anywhere within that function's body (until it goes out of scope due to function return). In Lisp, this restricts local variables to the `let` block they are defined in. This approach helps maintain cleaner code and avoids accidental modification or usage of unintended variables.",0.4928,[[0.31724942]],0.038098409556793694,0.16284088679615458,0.2821316614420063,0.018927444794952678,0.15047021943573666
"In The Racket Guide about parameterize, there's the following piece of code:
(define location (make-parameter ""here""))

(let ([get (parameterize ([location ""with a fox""])
             (lambda () (location)))])
  (get))

The code returns ""here"".
What's the sequence of evaluating this piece of code? Thank you.
","This is a common problem with dynamically-scoped values in many languages (not just Racket). Here's what happens when you evaluate the code:

The location parameter is defined with value ""here""
Enter the let...
Enter parameterize...
The parameter location is dynamically updated with the value ""with a fox""
The lambda expression is evaluated to create a closure which closes over location
Return from parameterized block—parameter location reverts to its original value of ""here""
The resulting lambda is bound to get
Evaluate let body...
You call (get), and it looks up the current value of location, which is ""here"", and that's the result.

If you carefully read the documentation on parameters it explains that the parameter always takes the value of the closest update in the stack. Since your update with the value ""with a fox"" gets popped off the stack before going into the let body, it's no longer visible when you make the actual call to get. A simple fix is to copy the value from the parameter and let the closure close over the copy:
(define location (make-parameter ""here""))

(let ([get (parameterize ([location ""with a fox""])
             (let ([loc (location)])
                (lambda () loc)))])
  (get))

Now the lambda closes over loc, which should have the expected value.
","This is described in the manual (first hit on Google for ""emacs add-hook""):
(add-hook 'prog-mode-hook (lambda () (foo ""foobarbaz"")))

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
 Try adding :direction :output to create an output file stream:
(with-open-file (stream ""test.txt"" :direction :output
                                   :if-does-not-exist :create)
      (format stream ""success!""))

 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
","In the provided Racket code, `make-parameter` is used to create a parameter named `location` with an initial value of \",0.5175,[[0.41874662]],1.1659694367181728e-05,0.0421538008227126,0.12987012987012986,0.061135371179039305,0.10389610389610389
"A form in Lisp/Scheme/Racket has symbol put at first position. This code works in Racket:
(define (? a b) (if a (display b) 0))
(? #t ""Hello"")

But I want to simulate the a? b:0 statement in C/C++ and the question mark (the symbol) is supposed to be at the end, after a.
How to put ? and a and b in this order?
(define (a ? b) (if a (display b) 0))
(#t ? ""Hello"")

Do I need to use define-syntax or that kind of thing?
","Let me offer an alternative solution via overriding the application syntax #%app. Here's an example of the ternary operator in C-like languages:
#lang racket

(require syntax/parse/define
         (only-in racket [#%app racket:#%app]))

(define-syntax-parser #%app
  [(_ test-expr {~datum ?} then-expr {~datum :} else-expr)
   #'(if test-expr then-expr else-expr)]
  [(_ xs ...)
   #'(racket:#%app xs ...)])

> ((= 42 42) ? ""a"" : ""b"")
""a""
> ((= 42 0) ? ""a"" : ""b"")
""b""

Because the application syntax has the lowest priority, other syntax will be considered first:
> (define-simple-macro (discard-all xs ...) 1)
> (discard-all ? 42 : 123)
1
> (if ? 1 : 2)
if: bad syntax ;; because if should have exactly three subforms, but the above line has four.

But as Ryan said, this is not a ""good"" Racket code in a sense that it defies Racket convention and no one (well, probably except you) will be able to understand your code.
","The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 There is no need to use the sharp-quote syntax here.  Its purpose is to use a function name in a variable position, but a is a variable already.  Just write a instead of #'a.
 According to the grammar, options must be parenthesized individually.  The defstruct form therefore needs to look like this:
(defstruct (test-struct (:print-function print-test)
                        (:constructor create-test (&key a (b a) c)))
  a
  b
  c)

 See the Racket syntax: 
http://docs.racket-lang.org/reference/reader.html

| starts a subsequence of characters to be included verbatim in the delimited sequence (i.e., they are never treated as delimiters, and they are not case-folded when case-insensitivity is enabled); the subsequence is terminated by another |, and neither the initial nor terminating | is part of the subsequence.

For example 1.3.2 Reading Symbols.
 In the cond special form, there's an implicit begin after each condition, so it's ok to write several expressions, remembering that only the value of the last one will be returned. Like this:
(cond [<first condition>
       (set! global-variable value)
       ""string to return""]
      [else
       ""other return value""])

","In Lisp/Scheme/Racket, you cannot change the syntax to have the conditional operator with the '?' at the end. This is because the syntax of the language is fixed and does not support such a modification without using macros like `define-syntax`. However, you can achieve similar functionality using standard control structures. For example, you could use an if expression as follows:\n\n```lisp\n(define (conditional-a b) (if #t b 0))\n(conditional-a \",0.5482,[[0.30891205]],0.033516254414451434,0.1525342301225078,0.32142857142857145,0.04504504504504504,0.125
"I am a Common Lisp newbie who's beginning to learn the language. My question is: I've seen several functions use the predicate syntax in different ways. For example (just looked this up), there is streamp and pathnamep, but there is also input-stream-p and output-stream-p. Why aren't all functions standardized to use *p or *-p? Is this maybe just a historical artifact?
","The rule is that one-word predicate names end in just P, while multi-word predicate names end in -P.  The reason for the former is mostly historical; the reason for the latter is that a name like input-streamp would wrongly suggest that the question being asked is “is this input a stream?” or something like that.
","The rule is that one-word predicate names end in just P, while multi-word predicate names end in -P.  The reason for the former is mostly historical; the reason for the latter is that a name like input-streamp would wrongly suggest that the question being asked is “is this input a stream?” or something like that.
 The sequence of frames is the linked list (of frames) pointing 'upwards' towards the global environment.  So when an environment is created (for example, in the context of a procedure binding), the 'environment' is a pointer to the frame...which in term points to the enclosing environment (or null, if the global environment).
So ... a qualified 'yes'...it's the first frame in the sense that the rest of the environment is accessible from that first frame.
Does that help?
Cordially,
Dak
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 As mentioned in first comment it is necessarily to use (list a b c) form.
 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 Use with-input-from-string. 
(with-input-from-string (s ""4 3 2"")
  (let ((a (read s))
        (b (read s))
        (c (read s)))
    (format t ""~a, ~a, ~a~%"" a b c))) 

You could also just read from a file, but reading from a string is much easier for making different test cases.
","The naming convention for predicate functions in Common Lisp indeed has a historical aspect to it. For one-word predicate names, 'P' is used at the end (e.g., streamp), while for multi-word predicates, a hyphen followed by 'P' is used (e.g., input-stream-p and output-stream-p). This distinction helps avoid ambiguity in the naming and interpretation of functions. Using -p for multi-word names prevents misunderstandings that could arise from compound words without the hyphen, such as thinking input-streamp means 'is this input a stream?'",0.6395,[[0.50509913]],0.21252662803206349,0.408246638966374,0.4429530201342282,0.1360544217687075,0.2953020134228188
"I want to do
(filter-list-into-two-parts #'evenp '(1 2 3 4 5))
; => ((2 4) (1 3 5))

where a list is split into two sub-lists depending on whether a predicate evaluates to true. It is easy to define such a function:
(defun filter-list-into-two-parts (predicate list)
  (list (remove-if-not predicate list) (remove-if predicate list)))

but I would like to know if there is a built-in function in Lisp that can do this, or perhaps a better way of writing this function?
","I don't think there is a built-in and your version is sub-optimal because it traverses the list twice and calls the predicate on each list element twice.
(defun filter-list-into-two-parts (predicate list)
  (loop for x in list
    if (funcall predicate x) collect x into yes
    else collect x into no
    finally (return (values yes no))))

I return two values instead of the list thereof; this is more idiomatic (you will be using multiple-value-bind to extract yes and no from the multiple values returned, instead of using destructuring-bind to parse the list, it conses less and is faster, see also values function in Common Lisp).
A more general version would be
(defun split-list (key list &key (test 'eql))
  (let ((ht (make-hash-table :test test)))
    (dolist (x list ht)
      (push x (gethash (funcall key x) ht '())))))
(split-list (lambda (x) (mod x 3)) (loop for i from 0 to 9 collect i))
==> #S(HASH-TABLE :TEST FASTHASH-EQL (2 . (8 5 2)) (1 . (7 4 1)) (0 . (9 6 3 0)))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 This is a result of using a constant list in the initializer:
(let ((myList '(0 0 0 0 0 0)))

Change that line to:
(let ((myList (list 0 0 0 0 0 0)))

and it will behave as you expect.  The first line only results in an allocation once (since it's a constant list), but by calling list you force the allocation to occur every time the function is entered.
edit:
This may be helpful, especially towards the end.  Successful Lisp
The answer to this question may also be helpful.
This uses the loop keyword collecting which collects the results of each iteration into a list and returns the list as the value of the loop.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 If I understood correctly, you can combine reduce and append to flatten the list before returning it.  
Example:  
(reduce 'append '((1) (2) (3)))

Output:  
(1 2 3)

In your case this might work:
(reduce 'append (mapcar 'recursive-function L))

 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 Start by defining a function that determines whether one list is less than another.  The following example assumes that the lists can only contain numbers:
(defun list< (a b)
  (cond ((null a) (not (null b)))
        ((null b) nil)
        ((= (first a) (first b)) (list< (rest a) (rest b)))
        (t (< (first a) (first b))) ))

Armed with this function, you can now sort the list of lists.
(sort (copy-seq list) #'list<)

","Lisp does not have a built-in function specifically for splitting a list into two sub-lists based on a predicate. However, you can achieve this using existing functions such as `remove-if-not` and `remove-if`. Your provided implementation is clear and efficient. An alternative approach could be to use `reduce` in combination with `append` if you are dealing with nested lists, but for splitting into even and odd numbers, your current function is a good solution.",0.5099,[[0.23002275]],0.03144455404201719,0.13751127141568983,0.25581395348837205,0.03906249999999999,0.13178294573643412
"I try to replace a certain element E in a list with another list K at all the main list levels.
(defun replaceList(l e k)
  (cond
    ((null l) nil)
    ((equal e (car l)) (cons k (replaceList (cdr l) e k)))
    ((listp (car l))
     ((equal e (car (car l))) (cons k (replaceList (cdr (car l)) e k))))
    (t (cons (car l) (replaceList (cdr l) e k)))))

Example:
(replaceList '(3 1 2 (6 1) 7 (5 (5 (3 1))) 9) '1 '(99 99))
--> (3 (99 99) 2 (6 (99 99)) 7 (5 (5 (3 (99 99) ) ) ) 9)

I get something with lambda expression as error message. 
Also,i tried instead of the listp(car l) ""block"" :
((listp (car l)) (cons k (replaceList (cdr (car l)) e k))).
I get something weird :
(2 1 3 ( 6 1 7) 7 1 2 ) -> (2 (99 99) 3 (99 99) (99 99) 7)
","Error
Your ""lambda expression message"" is due to an extra set of parens around equal in the listp clause. Remember, Lisp parentheses are meaningful.
Use the standard library!
ANSI Common Lisp has subst which does what you want:
(subst '(99 99) 1 '(3 1 2 (6 1) 7 (5 (5 (3 1))) 9) :test #'equal)
==> (3 (99 99) 2 (6 (99 99)) 7 (5 (5 (3 (99 99)))) 9)

Your algorithm
Since you are operating on the tree, not list (you say ""all the
main list levels""), you should treat car and cdr identically:
(defun my-subst (new old tree &key (test #'eql))
  (cond ((funcall test old tree)
         new)
        ((atom tree)
         tree)
        (t
         (cons (my-subst new old (car tree) :test test)
               (my-subst new old (cdr tree) :test test)))))
(my-subst '(99 99) 1 '(3 1 2 (6 1) 7 (5 (5 (3 1))) 9) :test #'equal)
==> (3 (99 99) 2 (6 (99 99)) 7 (5 (5 (3 (99 99)))) 9)

Or, simplified (without &key and
funcall):
(defun my-subst (new old tree)
  (cond ((equal old tree)
         new)
        ((atom tree)
         tree)
        (t
         (cons (my-subst new old (car tree))
               (my-subst new old (cdr tree))))))

","When you call removeDuplicates recursively in the last condition, you're not combining the result with the car of the list, so you're discarding that element.
You're also not using the result of rember.
(defun removeDuplicates (L)
  (cond
   ((null L) '())
   ((my_member (car L) (cdr L)) 
    (cons (car L) 
          (removeDuplicates 
           (rember (car L) (cdr L)) 
           ))
    )
   (T (cons (car L) (removeDuplicates (cdr L))))
   )
  )

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
","The issue with your replaceList function is that you're not correctly handling nested lists. Specifically, when you find an element E that needs to be replaced, you should recursively call replaceList on both the main list and its sublists. Here's a corrected version of your function:\n\n```lisp\n(defun replaceList (l e k)\n  (cond\n    ((null l) nil)\n    ((equal e (car l)) (cons k (replaceList (cdr l) e k)))\n    ((listp (car l))\n     (cons (replaceList (car l) e k) (replaceList (cdr l) e k)))\n    (t (cons (car l) (replaceList (cdr l) e k)))))\n```\n\nThis version ensures that both the current element and any nested lists are checked for the target element E, allowing for a proper replacement.",0.5855,[[0.1179255]],0.090819006114705,0.21614433521141876,0.22291021671826625,0.024922118380062305,0.11764705882352941
"How do LISPs or MLs implement tail-call optimization?
","I can't speak on the exact implementation details different compilers/interpreters, however generally speaking tail-call optimization operates like this:
Normally a function call involves something like this:

Allocate stack space for the return
Push your current instruction pointer onto the stack
Allocate stack space for the function parameters and set them appropriately
Call your function
To return it sets it's return space appropriately, pops off the instruction pointer it should be returning to and jumps to it

However when a function is in tail position, which pretty much means you are returning the result of the function you are about to call, you can be tricky and do

Re-use the stack space allocated for your own return value as the stack space allocated for the return value of the function you are about to call
Re-use the instruction pointer you should be returning to as the instruction pointer that the function you are about to call will use
Free your own parameters stack space
Allocate space for the parameters and set appropriately
Set the value of your parameters
Call your function
When it returns, it will be returning directly to your caller.

Note that #1 and #2 don't actually involve any work, #3 can be tricky or simple depending on your implementation, and 4-7 don't involve anything special from the function you are calling. Also note that all of this results in a 0 stack growth with respect to your call stack, so this allows for infinte recursion and generally speeding things up a little.
Also note that this kind of optimization can be applied not only to directly recursive functions, but co-recursive functions and in fact all calls that are in tail position.
","You have three options:

Rewrite the algorithm to be tail-recursive or, equivalently, iterative
Change the algorithm all together
Increase the lisp's stack size

 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 The loop/recur version is the right way.  Clojure cannot optimize tail calls due to limitations of the JVM. 
 buffer-substring together with region-beginning and region-end can do that.
 Common Lisp implementations are not required by the ANSI standard to do tail call optimization; however, most that worth their salt (including SBCL) do optimize. 
Your function, on the other hand, is not tail recursive.  It can be turned into one by using the common trick of introducing an extra parameter for accumulating the intermediate result:

    (defun collect (func args num)
      (labels ((frob (n acc)
                 (if (= 0 n)
                     acc
                     (frob (1- n) (cons (apply func args) acc)))))
        (frob num nil)))

(The original parameters FUNC and ARGS are eliminated in the local function since they are constant with recpect to it).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

","LISPs and MLs (which include Common Lisp) are not required by the ANSI standard to perform tail call optimization. However, many implementations do support it, including SBCL for Common Lisp. Tail call optimization is a compiler or interpreter optimization that transforms recursive calls into non-recursive forms to avoid stack overflow. This can be done manually in Lisp by using an accumulator parameter as shown in the example provided earlier. The example demonstrates how to rewrite a function to be tail-recursive by introducing an extra parameter for accumulating intermediate results.",0.508,[[0.34682015]],0.021412800239681524,0.13244404637385102,0.25,0.02617801047120419,0.10416666666666666
"I'm calling a CL script from various places in the system. How do I get the file path of the script that is currently executed?
For example, the script source file is located in the /home/user/project/source/ directory. The script is being executed from the /home/user/ directory in the following manner:
user@machine:~$ ./project/source/script.lsp
Regardless of the callers location, script should know that it's located in the /home/user/project/source/ directory.
I've tried using the *default-pathname-defaults* variable, but the following command shows the directory from which the script was called:
(format t ""Pathname: ~S~&"" *default-pathname-defaults*)
Environment: SBCL 1.4.5.debian on Ubuntu 18.04.
","The *load-truename* and *compile-file-truename* variables are bound to the truename of the file being loaded with cl:load or compiled with cl:compile-file at the time of loading or compilation, respectively.
In your case, *load-truename* is the thing to use. It will give a full, absolute pathname to the script.
","The *load-truename* and *compile-file-truename* variables are bound to the truename of the file being loaded with cl:load or compiled with cl:compile-file at the time of loading or compilation, respectively.
In your case, *load-truename* is the thing to use. It will give a full, absolute pathname to the script.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
","To get the file path of the script that is currently executed in Common Lisp, you can use the *load-truename* variable. This variable holds the truename of the file being loaded at the time of loading. For example, if your script.lsp is located in /home/user/project/source/, and it is being executed as ./project/source/script.lsp from the /home/user/ directory, you can retrieve its path using: (format t \",0.6238,[[0.47355671]],0.2556037912069161,0.39308068238257654,0.421875,0.2222222222222222,0.3125
"I'm currently learning Scheme (using Racket), but one of the challenges I'm coming upon is trying to execute the following bit of code, which is meant to execute Racket code from user input using eval:
(display (eval (read)))

 
Here's some of the weird behavior I've observed so far:

(display (eval (read))) in the definition window prompts for keyboard input, as expected, when the definitions are run. However, providing the input
((lambda (x) (+ x 1)) 1)
 
gives the error
?: function application is not allowed;
no #%app syntax transformer is bound in: ((lambda (x) (+ x 1)) 1)
On the other hand, using (display ((eval (read)) 1)) and providing input
(lambda (x) (+ x 1))
 
returns the error
lambda: unbound identifier;
also, no #%app syntax transformer is bound in: lambda
However, running (display (eval (read))) and providing ((lambda (x) (+ x 1)) 1) in the console pane, as opposed to the definitions pane, prints out 2, as expected.

What is the reason for this behavior?
","It looks like you don't have the namespace set up. If you're running (eval (read)) within a file, it doesn't work because the current-namespace is set to an empty namespace by default. You can set up a namespace with racket/base in it by doing (current-namespace (make-base-namespace)) first:
#lang racket
(current-namespace (make-base-namespace))
(println (eval (read)))

Running this program and giving it the input ((lambda (x) (+ x 1)) 1) results in it printing 2.
The reason it worked in the interactions window (item 3 of your weird-behavior list), is that in the interactions window, the current-namespace parameter is set to the namespace of the file. 
This is not true for the definitions window, the main program, so you have to set the current-namespace yourself, or pass a namespace in as a second argument to eval:
#lang racket
(define ns (make-base-namespace))
(println (eval (read) ns))

","What you're missing is a call to interactive:
(defun na ()
  ""Liten å""
  (interactive)
  (setq varlol ""å"")
  (insert varlol))

From the documentation for it:

This special form declares that a
  function is a command, and that it may
  therefore be called interactively (via
  M-x or by entering a key
  sequence bound to it). The argument
  arg-descriptor declares how to compute
  the arguments to the command when the
  command is called interactively.

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 What you are seeing is the output being concatenated for brevity. The actual list is correct and not affected, but because it would be too long to print to the output, the lisp REPL shortens it when printing and uses # to indicate that it has done so.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

",Answer not found.,0.3724,[[0.01272505]],6.8496911363333005e-28,0.008920606601248885,0.012422360248447206,0.0,0.012422360248447206
"If I have a list of values, what is an effective way to calculate the difference between the elements in the list?
For example:
'(5 10 12 15) would result in '(5 2 3), or '(0 5 2 3)
Thanks!
","You would do this also:
(def xs '(5 10 12 15))

(map - (rest xs) xs)
;; => (5 2 3)

map applies the function - to two lists:
  10  12  15
-  5  10  12  15
----------------
   5   2   3

","Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Because values is returning multiple values, and check-equal? can't handle that, it expects exactly two values to compare. For instance, this would work because we're dealing with only two values:
(check-equal? (values 42) 42)

Try a different approach, let's say we first unpack the multiple values and put them in a list:
(check-equal?
 (let-values ([(a b c) (values 'this 'and-this 'and-that)])
   (list a b c))
 '(this and-this and-that))

 You're accessing the wrong element for the comparison, try this instead:
(equal '+ (car (cdr L)))

 Your product function has a subtle flaw:
(product + 4 5)

returns 120 when the correct answer is 20.
The reason is
(product-iter 1 1) should be (product-iter lo 1)

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","To calculate the difference between elements in a list in Lisp, you can use the `mapcar` function along with a lambda or anonymous function. Here's an example for your provided list:",0.4576,[[0.0750968]],0.024661716045196402,0.18550201791638515,0.14925373134328357,0.0,0.11940298507462688
"I need to read a text file using Common Lisp. File must be read to list of lists. Each list in the list must consist of a line from file.
Now, I have done such code:
(with-open-file (in file)
  (loop for line = (read-line in nil nil)
        while line
        collect (coerce line 'list)))

But, for example, the rusult looks as: ((#\0 #\0 #\0) (#\1 #\0 #\1)). But I need to have result without #\ characters: ((0 0 0) (1 0 1)). How to fix it?
","You are already converting the line to a list of characters;
all you need to do is convert the characters to numbers:
(with-open-file (in file)
  (loop for line = (read-line in nil nil)
    while line
    collect (map 'list #'digit-char-p line)))

You can also use (parse-integer (string c)) instead of digit-char-p, but that seems an overkill.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 read-char will return the next available character, and read-line will return an entire line of input as a string. You can use coerce to change a string to a list of characters, e.g.
(coerce ""foo"" 'list) => (#\f #\o #\o)

 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 read-line takes an optional argument (eof-error-p) allowing it to return either NIL (default) or a user-specified value (eof-value) on hitting an EOF, instead of signalling an error.
From Chapter 19 of Successful Lisp:

READ-LINE &optional stream eof-error-p eof-value recursive-p
In the read functions listed above, optional arguments EOF-ERROR-P and EOF-VALUE specify what happens when your program makes an attempt to read from an exhausted stream. If EOF-ERROR-P is true (the default), then Lisp will signal an error upon an attempt to read an exhausted stream. If EOF-ERROR-P is NIL, then Lisp returns EOF-VALUE (default NIL) instead of signalling an error. 

You can use this as a simple termination condition for your function. 
",Answer not found.,0.3566,[[0.]],4.923399736944431e-13,0.014005602240896357,0.0,0.0,0.0
"For example, in Prolog time/1 can be used in order to measure the amount of inferences a method call produces.
Is there something similar in Lisp to measure the efficiency of a method to another? That would be extremely useful.
Thanks in advance for the help!
","Common Lisp (the standard) offers time, which

prints various timing data and other information to trace output

Implementations usually provide more profiling tools which will tell you more detailed information about the function calls &c.
There is also a portable profiler called Metering.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 It's very easy. This is the base case:
(remove-nth 0 '(2 3)) ; => (3)

And the default case:
(remove-nth 1 '(1 2 3))         ; ==
(cons 1 (remove-nth 0 '(2 3)))

The only thing left for you to do is to actually implement it!
There is a third case. What if the list is nil? In the strictest sense you cannot do the job and you should signal an error or perhaps there isn't anything to do so it's ok to then have it as a base case that evaluates to '() so that (remove-nth 5 '(1 2)) ; ==> (1 2)
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
",Answer not found.,0.3777,[[0.]],2.1122220486980423e-08,0.0176056338028169,0.0,0.0,0.0
"Say there is a function F. I want to pass a list of functions as an argument into function F. 
Function F would go through each function in the list one by one and apply each one to two integers: x and y respectively. 
For example, if the list = (plus, minus, plus, divide, times, plus) and x = 6 and y = 2, the output would look like this:
8 4 8 3 12 8

How do I implement this in common Lisp?
","There are many possibilities.
CL-USER> (defun f (x y functions)
           (mapcar (lambda (function) (funcall function x y)) functions))
F
CL-USER> (f 6 2 (list #'+ #'- #'+ #'/ #'* #'+))
(8 4 8 3 12 8)
CL-USER> (defun f (x y functions)
           (loop for function in functions
                 collect (funcall function x y)))
F
CL-USER> (f 6 2 (list #'+ #'- #'+ #'/ #'* #'+))
(8 4 8 3 12 8)
CL-USER> (defun f (x y functions)
           (cond ((null functions) '())
                 (t (cons (funcall (car functions) x y)
                          (f x y (cdr functions))))))
F
CL-USER> (f 6 2 (list #'+ #'- #'+ #'/ #'* #'+))
(8 4 8 3 12 8)
CL-USER> (defun f (x y functions)
           (labels ((rec (functions acc)
                      (cond ((null functions) acc)
                            (t (rec (cdr functions)
                                    (cons (funcall (car functions) x y)
                                          acc))))))
             (nreverse (rec functions (list)))))
F
CL-USER> (f 6 2 (list #'+ #'- #'+ #'/ #'* #'+))
(8 4 8 3 12 8)
CL-USER> (defun f (x y functions)
           (flet ((stepper (function result)
                    (cons (funcall function x y) result)))
             (reduce #'stepper functions :from-end t :initial-value '())))
F
CL-USER> (f 6 2 (list #'+ #'- #'+ #'/ #'* #'+))
(8 4 8 3 12 8)

And so on.
The first two are readable, the third one is probably how a rookie in a first Lisp course would do it, the fourth one is still the rookie, after he heard about tail call optimization, the fifth one is written by an under cover Haskeller.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 To pass a list of arguments to a function you can use apply, for example
(apply 'insert '(""hello "" ""world""))
 You will find that, in the REPL, the variable * holds the last result, and + holds the last evaluated form. 
For example:
> (+ 1 2)
  => 3
> +
  => (+ 1 2)
> (+ 2 3)
  => 5
> *
  => 5

Yes, these are standard, and in the HyperSpec.
If you wish to create a list containing the symbol +, rather than its value, you will need to quote it, as such: '+, or (quote +).
",You can implement this by defining function F which takes a list of functions and two integers x and y. Use mapcar or loop to apply each function from the list to the arguments x and y. Here's an example implementation:\n\n```lisp\n(defun perform-operations (functions x y)\n  (mapcar #'(lambda (func) (funcall func x y)) functions))\n\n;; Example usage\n(setq my-functions '(#'+ #'- #'+ #'/ #'* #'+))\n(perform-operations my-functions 6 2)\n```\nThis will output: (8 4 8 3 12 8),0.5664,[[0.35308164]],0.011814596001733848,0.11037111556664142,0.2564102564102564,0.08387096774193549,0.17307692307692307
"Why does this:
(every (lambda (x) (equal ""a"" x)) ""aaaaa"")

and this:
(every (lambda (x) (equal ""a"" x)) ""a"")

return NIL, while this:
(every (lambda (x) (equal ""a"" x)) '(""a"" ""a"" ""a"" ""a""))

returns T?  I thought every worked on all sequences.
","You can always find it out yourself. A test is only a few seconds away if you use an interactive Lisp system:
CL-USER 1 > (every (lambda (x) (equal ""a"" x)) ""a"")
NIL

Above returns NIL.
Now use the Common Lisp function DESCRIBE to get the data described.
CL-USER 2 > (every (lambda (x)
                     (describe x)
                     (describe ""a"")
                     (equal ""a"" x))
                   ""a"")

#\a is a CHARACTER
Name                ""Latin-Small-Letter-A""
Code                97
Bits                0
Font                0
Function-Key-P      NIL

So the value of x is a character. The character #\a.
""a"" is a SIMPLE-BASE-STRING
0      #\a
NIL

The type of ""a"" is SIMPLE-BASE-STRING (here in LispWorks).
If you look at the definition of EQUAL, then you can see that a character and a string are never equal, because they are of different types.
CL-USER 3 > (equal #\a ""a"")
NIL

","Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 The right-hand side of and and or are tail expressions (see R5RS section 3.5), so you can safely use those for iterative purposes.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

",Answer not found.,0.313,[[0.]],7.107934627086636e-39,0.004309416074121956,0.0,0.0,0.0
"I am trying to transpose a list of lists; my comments indicate the thought process.
(setq thingie  '((1 2 3) (4 5 6) (7 8 9)))  ;;test case

(defun trans (mat)
  (if (car mat)
    (let ((top (mapcar 'car  mat))   ;;slice the first row off as a list
          (bottom (mapcar 'cdr mat))) ;;take the rest of the rows
      (cons top (trans bottom))))    ;;cons the first-row-list with the next-row-list
   mat)

(trans thingie)
=> ((1 2 3) (4 5 6) (7 8 9))           ;;wait what? 

But, I really want it to be 
((1 4 7) (2 5 8) (3 6 9))

What am I doing wrong? 
","There is a simple way for this:
(defun rotate (list-of-lists)
  (apply #'mapcar #'list list-of-lists))

Your attempt is always returning the original mat.  Fix your indentation, and you see that the returned value from the if form is always thrown away.
Edit:  How this works:

List takes any number of arguments and makes a list of it.  Its function definition can be imagined about like this:
(defun list (&rest arguments)
  arguments) ; exploit the automatic &rest construction

Mapcar takes a function and any number of lists, and then makes a
new list of the values created by calling the function always with
one element from those lists.  Example: (mapcar #'foo '((A B) (C
D))) will construct a new list, where the first element is the
result of (foo 'A 'C) and the second the result of (foo 'B 'D).
Apply takes a spreadable argument list designator as its last
argument.  This means that if you give it a list as its last
argument, that list can be ""spread"" to produce individual arguments
for the function.  Example: (apply #'+ '(1 2 3)) has the same
effect as (+ 1 2 3).

Now you can expand the line:
(apply #'mapcar #'list '((A B) (C D)))

=>
(mapcar #'list '(A B) '(C D))

=>
(list (list 'A 'C) (list 'B 'D))

=>
'((A C) (B D))

","As mentioned in first comment it is necessarily to use (list a b c) form.
 I don't understand why your function takes 2 arguments when it's going to rearrange one list.
Your t case is almost correct, but you've practically turned it inside out - it should be
(cons (car x) (Func1 (cdr x)))

That is, a list where the car is the same as in the input, and the cdr is the result of flattening the cdr of the input.
The listp case looks like it's suffering from a similar form of ""inside-out-ness"".
Apart from the inexplicable y you have all the right bits but in the wrong order, except that it needs two Func1 calls - one for the car and one for the cdr.  
I'll leave the rearrangement of the bits in that case as an exercise.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Read up on mapcar et al:
(defparameter a (list 1 2 3 4))
(mapcon (lambda (tail)
          (mapcar (lambda (x)
                    (cons (car tail) x))
                  (cdr tail)))
        a)
==> ((1 . 2) (1 . 3) (1 . 4) (2 . 3) (2 . 4) (3 . 4))

 (apply your-procedure your-list)

","Your function `trans` is recursively slicing off the first element of each sublist and consing it with the result of processing the rest. This approach flattens the structure rather than transposing it. To transpose a list of lists, you should use `mapcar` to apply a lambda function that collects elements from corresponding positions in all sublists at once. Here’s how you can modify your function:\n\n```lisp\n(defun transpose (mat)\n  (if (null mat)\n      nil\n      (cons (mapcar 'car mat) (transpose (mapcar 'cdr mat)))))\n\n(setq thingie '((1 2 3) (4 5 6) (7 8 9)))\n(transpose thingie)\n```\nThis will give you the desired output:\n\n```lisp\n((1 4 7) (2 5 8) (3 6 9))\n```\n",0.5684,[[0.42110423]],0.10939158718178721,0.20537776554811274,0.2939481268011527,0.06376811594202898,0.14985590778097982
"How come most Lisps and Schemes are dynamically typed?
Does static typing not mix with some of their common features?
","Typing and s-expressions can be made to work together, see typed scheme.
Partly it is a historical coincidence that s-expression languages are dynamically typed. These languages tend to rely more heavily on macros, and the ease of parsing and pattern-matching on s-expressions makes macro processing much easier. Most research on sophisticated macros happens in s-expression languages.
Typed Hygienic Macros are hard.
","According to https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Lexical-Binding.html, even when lexical-binding is non-nil, special variables (like x since it was defined with defvar) are still dynamically bound.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 There is an ASDF library called shut-it-down that provides a quit function that works by just having cases for the common CL implementations.
 Typing and s-expressions can be made to work together, see typed scheme.
Partly it is a historical coincidence that s-expression languages are dynamically typed. These languages tend to rely more heavily on macros, and the ease of parsing and pattern-matching on s-expressions makes macro processing much easier. Most research on sophisticated macros happens in s-expression languages.
Typed Hygienic Macros are hard.
 Elisp uses dynamic scoping, which means that variable names really matter.  More specifically, in your case you have a naming conflict between your hist and the hist variable used by ido.  Always use a <prefix>- thingy on global variables to avoid such problems.
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
","Most Lisps and Schemes are dynamically typed because these languages often rely heavily on macros. The ease of parsing and pattern-matching s-expressions (the standard input format for Lisp) makes macro processing much easier in these languages. As a result, they tend to focus more on runtime flexibility and less on compile-time type checking. However, this does not mean that static typing cannot be integrated; it's just that dynamic typing is more common due to the historical and practical advantages it provides.",0.634,[[0.5469245]],0.3309407189268743,0.4455775805436769,0.5960264900662252,0.22818791946308728,0.37086092715231783
"I wrote this code to write of a file:
(defun writefile (text filename)
  (with-open-file (stream filename :direction :output :if-exists :supersede
                   :if-does-not-exist :create)
    (format stream text)))

but if i execute, for example:
(writefile '(a b c) ""foo.txt"")

returns:

Error: In a call to FORMAT: (A B C) is not of type (OR STRING
  FUNCTION).

Why it shows me that error?
","Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

","The error you're encountering occurs because the second argument to FORMAT must be either a string or a function. In your code, you are passing a list (a b c) directly to FORMAT, which is causing the error. To fix this, you should convert the list to a string before passing it to FORMAT. Here’s how you can modify your function:\n\n```lisp\n(defun writefile (text filename)\n  (with-open-file (stream filename :direction :output :if-exists :supersede :if-does-not-exist :create)\n    (format stream ",0.5725,[[0.46008948]],0.13071406200740285,0.3456636944707226,0.3809523809523809,0.16129032258064516,0.28571428571428575
"I'm experiencing a very curious problem. I have a list named ""theorems"" that has exactly one item. Here's proof:
[]> theorems
(((ROSES ARE RED) ^ (~ (ROSES ARE RED))))
[]> (car theorems)
((ROSES ARE RED) ^ (~ (ROSES ARE RED)))

Clearly ((ROSES ARE RED) ^ (~ (ROSES ARE RED))) is a member of the list ""theorems."" But when I test it for membership, it fails:
[]> (member '((ROSES ARE RED) ^ (~ (ROSES ARE RED))) theorems)
NIL

But if I call it explicitly, it works:
[]> (member (car theorems) theorems)
(((ROSES ARE RED) ^ (~ (ROSES ARE RED))))

Why is this happening, and how can I fix it?
","Common Lisp uses EQL as the default test function. EQL checks whether the items are the same identical items. You want to test whether the items have the same structure. So you need to use EQUAL or EQUALP.
CL-USER 11 > (setf theorems '(((ROSES ARE RED) ^ (~ (ROSES ARE RED)))))
(((ROSES ARE RED) ^ (~ (ROSES ARE RED))))

CL-USER 12 > (member '((ROSES ARE RED) ^ (~ (ROSES ARE RED))) theorems)
NIL

Tell MEMBER to use EQUAL:
CL-USER 13 > (member '((ROSES ARE RED) ^ (~ (ROSES ARE RED)))
                     theorems
                     :test 'equal)
(((ROSES ARE RED) ^ (~ (ROSES ARE RED))))

","I don't understand why your function takes 2 arguments when it's going to rearrange one list.
Your t case is almost correct, but you've practically turned it inside out - it should be
(cons (car x) (Func1 (cdr x)))

That is, a list where the car is the same as in the input, and the cdr is the result of flattening the cdr of the input.
The listp case looks like it's suffering from a similar form of ""inside-out-ness"".
Apart from the inexplicable y you have all the right bits but in the wrong order, except that it needs two Func1 calls - one for the car and one for the cdr.  
I'll leave the rearrangement of the bits in that case as an exercise.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 One problem is you have your < and > reversed. Assuming you want your left sub tree to be the smaller, then (< value (car tree)) should call again with the (cadr tree).
Also you should use #t instead of (#t).
",Answer not found.,0.3044,[[0.]],2.1292475440052983e-24,0.005279831045406548,0.0,0.0,0.0
"I'm working on making a custom emacs major-mode, but I'm completely unfamiliar with lisp - so I'm struggling.  I'm trying to add a font lock such that a line of repeating '=' or '-' is highlighted, along with the line above it (so that I can use these as headings), i.e.
This is a Colored Heading
=========================

this is a differently-colored sub-heading
-----------------------------------------

I've tried to set this up with:
(font-lock-add-keywords nil '((""\\(.*\n=\{3,\}\\)""
                             1 font-lock-warning-face prepend)))

but it isn't working.  I thought this meant:
'.*' any characters
'\n' followed by a newline
'=\{3,\}' followed by 3 or more '=' characters
Where am I going wrong?
","""\{"" and ""\}"" are treated as an escape sequence, which they're not.
You need to use ""\\{"" and ""\\}"" instead:
(font-lock-add-keywords nil '((""\\(.*\n=\\{3,\\}\\)""
                             1 font-lock-warning-face prepend)))

","""\{"" and ""\}"" are treated as an escape sequence, which they're not.
You need to use ""\\{"" and ""\\}"" instead:
(font-lock-add-keywords nil '((""\\(.*\n=\\{3,\\}\\)""
                             1 font-lock-warning-face prepend)))

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Your symbol is actually all uppercase, because the reader already upcases it.  In order to prevent that, you can either use a different readtable-case or escape the symbol, using either enclosing pipe symbols: '|aAbB| or a backslash for the next character: '\aA\bB.
 Go to this page:
https://docs.racket-lang.org/reference/reader.html
and look in the ""Delimiters and Dispatch"" section, where it says:
#\  starts a character

 As far as I'm aware, multiline text on buttons is not possible using standard DCL - you would need to turn to OpenDCL or similar.
 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

","Your regex pattern is almost correct, but there are a couple of issues. The key vector you're using in `font-lock-add-keywords` should match the entire line including the preceding line with '=' characters. Here's how you can adjust your code to achieve the desired highlighting for headings and sub-headings:\n\n```lisp\n(font-lock-add-keywords nil '((\",0.5551,[[0.24441419]],0.18751776027574812,0.32742363602430374,0.3043478260869565,0.11111111111111112,0.21739130434782605
"Just very curious about this, from my own experience , all the graphic programming seems to C or C++ related. Like the Direct10X. Does functional programming language provide some sort of graphic library to develop video game?
","You can use functional languages to do graphics/game programming just as in any other language.
It's only a simple game, but I wrote Ironclad: Steam Legions in Clojure as an exercise in functional programming for game development.
Here are some lessons I learnt / general observations on using Clojure for game programming:

You need to be careful about performance as games can be very demanding and functional languages do impose some overheads. Clojure is certainly ""good enough"" for most games, but you need to know the tricks to keep your code optimised. For example, functional languages can get a bit GC-heavy producing a lot of temporary objects. You need to learn the tricks to avoid this (for example, using reduce in a way that avoids creating new sequence objects, or leveraging primitive artithmetic)
Mutability is useful in games. For example, if you are doing anything with physics or smooth animation you often have a lot of objects with constantly changing locations. You can simulate this with functional/immutable data structures but if you care about performance it's not a good idea. Hence it's worth finding out how to get mutable data in your functional language even if it isn't idiomatic (e.g. in Clojure you will probably want to make use of Java arrays)
Immutable persistent data structures actually turn out to be very useful in games as well. In Ironclad, the entire game state was stored in a single immutable data structure. This allowed for some cool tricks like efficiently snapshotting the game state / instant undos / running backwards in time.
Clojure is awesome for game scripting. The dynamic nature coupled with runtime compilation and the ability to define arbitrary DSLs with macros is a massive win. In fact, even if I was writing a game in an OOP language like Java I would seriously consider using Clojure (or another Lisp) for scripting.
Clojure is awesome for interactive development. I often found myself running the game in one window while hacking the running code in a REPL alongside. It's fun to alter game data structures and immediately see the effects! This awesome video also gives you a taste of what's possible with Clojure-style development.
In Clojure at least you will often want to use the Java libraries for graphics, e.g. Swing for 2D or LWJGL for 3D. In some cases wrappers for these already exist, however I found it easy enough to use them directly from Clojure. After all, Java interop is as simple as (.methodName object arg1 arg2)

In conclusion, I think functional languages are perfectly good choices for game development, with the exception of very performance-intensive games where you are still likely to be better with C/C++ in order to have more direct control over the hardware.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 There is a language currently in development by Blitz Research ( http://www.blitzbasic.com ), it is NOT YET released, although the release date looms close.
The blog of the main developer is here:
http://marksibly.blogspot.com/2010/05/hi-ok-heres-plan-i-am-currently-working.html
This language has been announced as free and open source (although the game module will be sold as a separate product).
The target platforms include Windows, Linux, MacOSX, android, iPhone, XNA, flash and HTML5
This may turn out to be exactly what you are looking for.
 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
 You just want something like this:
#!/bin/sh
clisp > OUTPUTFILE 2>&1 << EOF
(load ""11.1"")
(make)
EOF 

 Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
 The problem consists of two subproblems: parsing and symbolic manipulation. It seems to me the answer boils down to two possible solutions.
One is to implement everything from scratch: ""I do recommend creating the full expression tree if you want to retain maximum flexibility for handling tricky cases."" - proposed by Rex. As Sven points out: ""any of the high-level languages you listed are almost equally suited for the task,"" however ""Python (or any of the high-level languages you listed) won't take away the complexity of the problem.""
I have received very nice solutions in Scala (many thanks for Rex and Daniel), a nice little example in Python (from Sven). However, I am still interested in Lisp, Haskell or Erlang solutions.
The other solution is to use some existing library/software for the task, with all the implied pros and cons. Candidates are Maxima (Common Lisp), SymPy (Python, proposed by payne) and GiNaC (C++).
","While it's true that historically, many graphics libraries have been developed for C or C++ (like Direct3D and OpenGL), functional programming languages like Lisp do provide tools and libraries for graphical development. For instance, you can use Common Lisp with libraries such as QuickDraw or CLX for X Window System interfaces, or more specifically for game development, you might look into Allegro CL which has support for graphics and multimedia. Additionally, with the release of BlitzBasic, a language designed for rapid game development that is expected to be functional in nature (though not yet released), there could potentially be new libraries developed specifically for functional programming environments. However, these are generally less mature than their imperative counterparts.",0.556,[[0.41897382]],0.016593457771119886,0.11218716430724475,0.22108843537414966,0.040955631399317405,0.1020408163265306
"I'm trying to write a function that takes a list and returns true if it contains a duplicate entry and false otherwise. I know I'm supposed to use member.  Here is my attempt so far (which fails):
(defun dupl (lst)
  (if (null lst) '())
  (if ((member (car lst) (cdr lst)) (cons (car lst) (dupes (cdr lst))))
    (t (dupl (cdr lst)))))

","Just my two cents on efficiency. If you use memberp to test for duplicates, then you're comparing each element to each other element and the complexity is O(N^2). Joshua in his answer suggested using a hash table to test for duplicates, which will give a linear running time O(N) at the expense of space. It might also be slower for smaller lists. Finally, if your list can be sorted, then you should get O(N.log(N)) as coredump- mentions. Here is an example that tests for duplicates in numeric lists using sort. (This is a destructive function.)
(defun duplicatesp (list)
  (mapl (lambda (cdr) (if (eql (first cdr) (second cdr))
                          (return-from duplicatesp T)))
   (sort list '<)) nil)

UPDATE
Out of curiosity, I measured the performance of the suggested answers for worst-case scenarios (almost no duplicates). So, 1 mln tries of lists of 10 elements:

using member (Jan's answer): 1.139 seconds;
using hash-table (Joshua's answer): 1.436 seconds;
using sort (see above, but with first copying the list): 1.484 seconds.

So, no difference with small lists. Interestingly, using a hash table has some penalty but it is very small. Let's try 1000 tries of lists of 1000 elements:

using member: 9.968 seconds;
using hash-table: 0.234 seconds;
using sort: 0.390 seconds.

As expected, using member has higher complexity. The difference between sorting and hashing is non-visible at this list size. Let's do 10 tries of lists of 1,000,000 elements:

using hash-table: 3.214 seconds;
using sort: 9.296 seconds.

So, sort is still quite good but is slowing down. Here is a simple code I used to profile the functions:
(defun random-list (length)
  (loop for i from 0 below length collecting
       (random (expt 10 10))))

(defun random-collection (length tries)
  (loop for i from 0 below tries collecting
       (random-list length)))

(defun test-duplicates (function &key length tries)
  (let ((rc (random-collection length tries)))
    (time (mapc function rc))
    nil))

(test-duplicates #'dp_hash :length 1000000 :tries 10)
;etc.

","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 You're overcomplicating it. You don't need to sort the CDRs of the sub-lists returned by SPLIT-LIST, just sort the whole lists, and merge them.
(defun MSORT (L)
  (cond ((endp L) nil)
        ((endp (cdr L)) L)
        (t
         (let* ((S (SPLIT-LIST L ))
                (L1 (car S))
                (L2 (cadr S))
                (X (MSORT L1))
                (Y (MSORT L2)))
           (MERGE-LISTS X Y)))))

","Your current implementation has a few issues. First, you should check for duplicates by comparing each element of the list with all subsequent elements. Second, the use of `if` is incorrect; it should be replaced with appropriate logical expressions. Here's a corrected version of your function using `member` and recursion:\n\n```lisp\n(defun dupl (lst)\n  (if (null lst) nil ; If the list is empty, there are no duplicates.\n      (or (member (car lst) (cdr lst)) ; Check if the first element is a duplicate in the rest of the list.\n          (dupl (cdr lst)))) ; Recursively check the rest of the list.)\n```\n\nThis function will return `t` if there are any duplicates and `nil` otherwise.",0.5778,[[0.35043138]],0.04648472714795825,0.15942611937401052,0.30042918454935624,0.04310344827586207,0.13733905579399142
"Hi guys I am trying to concat a list and to return the first value with extra brackets for example when I call the function (bracket-head '(a b c))  =>  ( (A) B C ). 
I have done it to give the result when I call the function with '('(a) b c). So here is my code: 
(defun bracket-head (list)
    (append (first list) (rest list))

","First of all, () are parentheses, not brackets.
Next, ""extra parentheses"" means you wrap the object in a list:
[5]> (list 1)
(1)
[6]> (list *)
((1))
[7]> (list *)
(((1)))
[8]> (list *)
((((1))))
[9]> (list *)
(((((1)))))

Thus, what you need to do is
[13]> (defparameter list (list 1 2 3))
LIST
[14]> (setf (first list) (list (first list)))
(1)
[15]> list
((1) 2 3)

Or, if you do not want to modify the list in-place:
[17]> (defparameter list (list 1 2 3))
LIST
[18]> (cons (list (first list)) (rest list))
((1) 2 3)
[19]> list
(1 2 3)

","You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 This is described in the manual (first hit on Google for ""emacs add-hook""):
(add-hook 'prog-mode-hook (lambda () (foo ""foobarbaz"")))

 You need another comma before A in the nested backquote, so it expands to the value of the variable outside the outside the outer backquote. And then it needs to be quoted to keep from evaluating that as a variable. So it becomes ,',A
(defmacro define-access (F A)
  (let ((X (gensym))
        (Y (gensym)))
    `(progn
       (defun ,F (,X)
         (,A ,X))
       (defsetf ,F (,X) (,Y)
         `(setf (,',A ,,X) ,,Y)))))

DEMO
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 As mentioned in first comment it is necessarily to use (list a b c) form.
","Your current function `bracket-head` does not achieve the desired result. You should use `cons` to prepend the first element wrapped in a list with parentheses, and then concatenate the rest of the list. Here's how you can do it:\n\n```lisp\n(defun bracket-head (list)\n  (cons (list (first list)) (rest list)))\n```\n\nFor example, when you call `(bracket-head '(a b c))`, it will return `((A) B C)` as expected.",0.5529,[[0.52877458]],0.12294068256873047,0.18962429318513752,0.27745664739884396,0.0935672514619883,0.18497109826589597
"Currently learning Common Lisp with SBCL, and it's bugging me how query-io has some unexpected differences from standard input and output. I will assume that standard-output contains a newline, or is formatted with one, because
(format *query-io* ""hello"")
Contains no newline at all.
Now, using read-line gives me this behavior
(defun read (prompt)
  (format *query-io* ""~a: "" prompt)
  (read-line))

(read ""message"")
> hello
""hello""
message: NIL

I was told this is expected, as SBCL would wait for a newline to be inputted before printing the format, but what I don't get is the result of changing the second line
(defun read (prompt)
  (format *standard-output* ""~a: "" prompt)
  (read-line))

(read ""message"")
> hello
message: 
""hello""
NIL

Why is the order different? I don't think the newline after the prompt variable affects the result
","If you want things to behave in a predictable way you should write programs which ensure that:

don't name the function read (in fact I'm extremely convinced that SBCL wouldn't have allowed you to name the function read, unless perhaps you are using a prehistoric version);
be clear about what streams you are actually reading and writing to;
if you want output to appear at a given time, say you do.

So in your first function you are doing something equivalent to what I assume is this:
(defun f1 (prompt)
  (format *query-io* ""~a: "" prompt)
  (read-line))

This:

writes the prompt to *query-io*, which means that at some future time it may appear on whatever *query-io* points at;
reads a line from *standard-input*;
returns the result of reading that line.

So if you call this function it will read a line from *standard-input* which perhaps is the terminal but may not be.  At some time after the call to format some output probably will appear on *query-io* which may also point at the terminal.  There is no guarantee as to when or in fact even if that output will appear: for instance if you modify the function to be:
(defun f1.1 (prompt)
  (format *query-io* ""~a: "" prompt)
  (clear-output *query-io*)
  (read-line))

it is quite possible that the prompt will never appear.
When output actually appears from functions which write to streams if you don't explicitly say 'write it now' depends on many, many factors:

what the stream points to;
if there's a buffer;
how big the buffer is;
how full the buffer is;
whether you later called clear-output on the stream and whether clear-output actually does anything;
whether you later closed the stream with :abort t and whether that actually does anything;
the price of chocolate on the moons of Jupiter.

In your second function things are mostly the same:
(defun f2 (prompt)
  (format *standard-output* ""~a: "" prompt)
  (read-line))

This time format is writing to *standard-output*, not *query-io* and again you are reading a line from *standard-input*.  And again, when and if the output from format appears is in the lap of the gods.
So what you need to do is

be clear about what streams you are using;
actually ask for output to appear when you want it, not later.

In particular never make assumptions that output written to some stream appears at any given point 'on its own' or 'after a newline', or anything like that.
If you want to prompt and read from *query-io* you do it like this:
(defun f3 (prompt)
  (format *query-io* ""~a: "" prompt)
  (finish-output *query-io*)
  (read-line *query-io*))

If you want to prompt on *standard-output* and read from *standard-input* then:
(defun f4 (prompt)
  (format *standard-output* ""~a: "" prompt)
  (finish-output *standard-output*)
  (read-line *standard-input*))

In this last case you can actually leave out the streams (and use t for format) because they are the defaults: still it is probably better to be explicit.
f3 is probably better, since prompting and reading is what *query-io* is for.
","Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 The read procedure only reads a single datum from the input port; the extra parenth does not raise an error in your code because it is never reached. One solution is to write a procedure that reads from the input port until the end is reached, collecting the resulting forms in a list:
(define (read-from-string s)
  (let ((input (open-input-string s)))
    (let loop ((expr (read input))
               (result '()))
      (if (eof-object? expr)
          (reverse result)
          (loop (read input) (cons expr result))))))

If read can successfully parse all of the expressions, a list of those expressions will be returned; otherwise an error will be signaled.
Sample interactions:
scratch.rkt> (read-from-string ""(1 (b 1))"")
'((1 (b 1)))
scratch.rkt> (read-from-string ""(+ 1 2)"")
'((+ 1 2))
scratch.rkt> (read-from-string ""(+ 1 2) (+ 3 4)"")
'((+ 1 2) (+ 3 4))
scratch.rkt> (read-from-string ""()"")
'(())
scratch.rkt> (read-from-string ""(+ 1 1))"")
; string::8: read: unexpected `)`
scratch.rkt> (read-from-string ""(+ 1 1)("")
; string::8: read: expected a `)` to close `(`

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 read-char will return the next available character, and read-line will return an entire line of input as a string. You can use coerce to change a string to a list of characters, e.g.
(coerce ""foo"" 'list) => (#\f #\o #\o)

 Use read
The simplest option is to ask the user to enter the list (with the parens) and just call (read).
The second option is to put the parens yourself:
(read-from-string (concatenate 'string ""("" (read-line) "")""))

safety and security
Note that the power of the Lisp reader can put you in trouble. E.g., if the user types #.(start-ww3) instead of (1 2 3) at your prompt, you might not reach your bomb shelter in time.
This means that you must bind *read-eval* to nil when calling read on text you do not control.
Call parse-integer repeatedly
Finally, you can call parse-integer in a loop
(defun parse-integers (s &optional (start 0))
  (loop with num do 
    (setf (values num start) (parse-integer s :start start :junk-allowed t))
    while num collect num))

or recursively:
(defun parse-integers (s &optional (start 0))
  (multiple-value-bind (num end) 
      (parse-integer s :start start :junk-allowed t)
    (and num (cons num (parse-integers s end)))))

 As mentioned in first comment it is necessarily to use (list a b c) form.
","The difference you observed arises from how *query-io* and *standard-output* handle buffering and flushing. In Common Lisp, *query-io* is typically configured to be line buffered or unbuffered, meaning it doesn't flush until a newline is encountered. This causes the prompt to be printed but waits for input with no immediate feedback.

On the other hand, when you use *standard-output*, it may be fully buffered by default, which means that the output buffer can fill up before being flushed to the terminal. However, in many interactive environments (like SLIME or a simple REPL), *standard-output* might behave similarly to *query-io* due to additional buffering management.

To ensure consistent behavior and avoid such issues, you can explicitly flush *standard-output* after printing the prompt:

(defun read (prompt)
  (format t ",0.5697,[[0.61189385]],0.019681071911720183,0.11203810332986504,0.2530120481927711,0.0785498489425982,0.12650602409638556
"In church numerals, if we have:
# (define zero (lambda (f) (lambda (x) x)))
zero = lambda f: lambda x: x

Then the successor function can be defined as:
# (define succ (lambda (n) (lambda (f) (lambda (x) (f ((n f) x))))))
succ = lambda n: lambda f: lambda x: f(n(f)(x))

Maybe this is a silly question, but if the successor essentially adds one more wrapper f(...) to the previous equation, why couldn't this just be defined as f(n)? Is this more for consistency of definition, or why can't that shorter form be used?
(Note: using python definitions here as well as scheme as it makes it a bit simpler for me to test with.)
","The numeral n is defined as n applications of the function f to some argument x.
Thus,
0 = λf.λx.x
1 = λf.λx.f x
2 = λf.λx.f (f x)
3 = λf.λx.f (f (f (x))
...

Note that 1 is not the same as λf.λx.f 0, so succ 0 can't be, either. (The same is true for the other numerals.)
Your definition, λn.λf.λx.(f n) would give
succ 0 = (λn.λf.λx.(f n)) (λg.λy.y)
       = λf.λx.f (λg.λy.y)

which is not the same as 1, but
 (λn.λf.λx.f (n f x)) (λg.λy.y)
= λf.λx.f ((λg.λy.y) f x)
= λf.λx.f ((λy.y) x)
= λf.λx.f x
= 1

","(second expr) is the list (* 3 x) which is not a number, but the function sqrt demands a number for its argument. Since you say you want to do symbolic differentiation, you probably should return a list with the symbol sqrt in it, rather than calling the function.
 You will find that, in the REPL, the variable * holds the last result, and + holds the last evaluated form. 
For example:
> (+ 1 2)
  => 3
> +
  => (+ 1 2)
> (+ 2 3)
  => 5
> *
  => 5

Yes, these are standard, and in the HyperSpec.
If you wish to create a list containing the symbol +, rather than its value, you will need to quote it, as such: '+, or (quote +).
 The right-hand side of and and or are tail expressions (see R5RS section 3.5), so you can safely use those for iterative purposes.
 This is a mathematical convention: the product of an empty sequence of numbers is one, by definition; note that one is the identity element for multiplication (1×a = a×1 = a). This is convenient because you can call * with a variable number of arguments without worrying about the case where there are no arguments present.
Similarly, the sum of an empty sequence of numbers is zero, the identity element for addition. Try issuing (+) at your Lisp prompt.
 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 You are using the ""extended"" loop form, so you need to do 
(loop while ...
  do ...)

instead of
(loop while ...
  ...)

This is what the error is telling you: it wants a keyword after while condition, and it found the first statement of the body.
You might want to review The LOOP Facility more carefully.
PS. Please bind local variables using let or, in loop, with, before setting them with setq. Otherwise your variables are global specials.
PPS. Please indent your code properly; you can use Emacs for that.
","The successor function in church numerals is defined as (f ((n f) x)) because this form correctly simulates the operation of adding one more application of the function f. If you simply used `f(n)`, it would not achieve the desired effect, which is to apply f once more than what n represents. For example, if n represents 2 applications of f (i.e., \(f(f(x))\)), then applying f once more should result in \(f(f(f(x)))\), which is achieved by ((n f) x). This definition ensures that the church numeral correctly encodes the number of times a function can be applied.",0.5564,[[0.1749151]],0.15168935700500774,0.27908742443973095,0.41379310344827586,0.16521739130434784,0.25
"I've a beginner (if that) to lisp/scheme and come across the following two ways to ""create a function"" in scheme:
(define (square x) (* xx))

And:
(define square (lambda (x) (* x x)))

What is the difference between these two? Are both versions supported across all versions/dialects of lisp or is one more ""generalized"" than the other?
","In Scheme they are the same where they are both supported: (define (x ...) ...) is the same as (define x (lambda (...) ...)).  However certainly they are not the same in Lisp-family languages, which includes a huge variety of languages going back long before Scheme was invented.
However, Scheme standards have a notion of essential and non-essential or optional syntax: any implementation must support essential syntax but implementations are allowed not to support optional syntax.  In R4RS, (define <variable> <expression>) is essential but (define (variable ...) ...) is not.  In R5RS this distinction seems to have gone away: both forms are (I think) now essential.
I would be surprised if any implementations didn't support both forms, other than very minimal / tiny ones perhaps.
Note that if you have a Scheme with only the (define <variable> <expression>) version but which has a macro system you can pretty easily support the other version too:
(define-syntax defyne
  (syntax-rules ()
    [(_ (name) form ...)
     (defyne name (lambda () form ...))]
    [(_ (name formal ...) form ...)
     (defyne name (lambda (formal ...) form ...))]
    [(_ (name . formal) form ...)
     (defyne name (lambda formal form ...))]
    [(_ name expression)
     (define name expression)]))

(This macro may be buggy: I just typed it in.)
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 A Common Lisp version is almost the same as in Scheme:
(defun solution (list)
  (apply #'mapcar #'+ list))

(solution '((1 2 3) (9 10 11) (3 4 5)))
; ==> (13 16 19)

 (second expr) is the list (* 3 x) which is not a number, but the function sqrt demands a number for its argument. Since you say you want to do symbolic differentiation, you probably should return a list with the symbol sqrt in it, rather than calling the function.
 Here is an implementation based on Stephen Chang's comment (I swapped the argument order a little and renamed the function too):
(define (insert-at lst pos x)
  (define-values (before after) (split-at lst pos))
  (append before (cons x after)))

 It is a parenthesis issue. It happens quite a lot when beginning with scheme.
I recommend that you indent your code correctly, it will make it more readable and much less error prone.
(define func
  (lambda (N lst)
    (if (eq? N 0)         
        0 
        (+ (car lst) 2))))

The extra () you had was translated to a function call
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
",Answer not found.,0.339,[[0.04062797]],1.9959958603758328e-41,0.004954419342053111,0.010256410256410256,0.0,0.010256410256410256
"This is a follow-up of my previous question: Why do we need nil? Clearly, proper lists are used most of the time. But what is the purpose of an improper list?
","For no good reason.  The only thing that improper lists are truly good for is as part of the syntax for association lists—and even there, a custom syntax for key-value pairs would be better.  Any use you can think of for improper lists can be better implemented with record types—which, after all, subsume lists: you can define Lisp lists in terms of records, but not the other way around (because lists don't allow you define data structures whose type is disjoint from all other types in the language).
The abuse of pairs and lists to represent all types of data is what I like to call Lisp programmer's disease, and it's a real shame that so many Lisp advocates advocate for it.  I've had to clean up that stuff way too many times.
","As mentioned in first comment it is necessarily to use (list a b c) form.
 
Am I misunderstanding how substitute-if works or misunderstanding the representation of the list?

Probably the latter.
#1=... marks a spot in the data structure and #1# refers back to it. The idea is to show that both elements refer to the same list. (See also http://www.lispworks.com/documentation/HyperSpec/Body/02_dhp.htm.)
It's like:
(let ((x '(0)))
  (list '(1) x '(3) x))

Because they refer to the same object, if you were to modify the second list in place, the modification would also show up in the fourth list.
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

","The primary use of improper lists in Lisp is for efficiency and simplicity in certain contexts. Improper lists can be more memory-efficient when constructing lists on-the-fly because they avoid the overhead of cons cells required by proper lists. Additionally, improper lists are sometimes used for their natural representation of data structures that do not fit well into a purely linked list format. However, it's important to handle improper lists carefully since they violate the normal structure of Lisp lists and can lead to unexpected behavior if not managed properly.",0.5416,[[0.48602781]],0.17214658929711654,0.24518388791593695,0.351931330472103,0.09523809523809525,0.18884120171673818
"So, I'm trying to learn Lisp, and I've come across a problem in the definition of what a String is.
I'm reading the ANSI Common Lisp by Paul Graham, and in this book it states that a String is a vector, or one-dimensional Array. 
So, I create a String:
(defvar *my-string* ""abc"")

And then I can access the first value of my-string this way:
(aref *my-string* 0)

But if it is a vector, why can't I access that element this way:
(svref *my-string* 0)

I mean, when I create a vector this way:
(defvar my-vec (make-array 4 :initial-element 1))

I can access first element using svref:
(svref my-vec 0) ; returns 1

I forgot to add error when I try svref on String:
""The value ""abc"" is not of type (SIMPLE-ARRAY T (*)).""
","String is a vector, but it isn't a simple-vector. svref takes a simple-vector as first argument.
You can check it by calling:
(vector-p *my-string*)

which returns true
Unlike: 
(simple-vector-p *my-string*)

which returns false.
Notice that (simple-vector-p my-vec) will return true as well, which confirms that make-array creates a simple-vector.
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
",Answer not found.,0.3654,[[0.]],4.297703752369114e-12,0.011441647597254004,0.0,0.0,0.0
"I've got some things in my configuration that works only in Xorg else dropping errors.
To solve it I need to know if Xorg is running or not. How can I check it ?
(defun nCdy-mode ()
    ;; TOOD: Add Xorg check
    ;(tool-bar-mode nil)
    (menu-bar-mode nil) ; TODO: Add hotkey
    ;(scroll-bar-mode nil)
    (setq inhibit-splash-screen t)

    (setq standard-indent 4)
    ;;(mouse-wheel-mode t)
    (setq backup-directory-alist (quote (("".*"" . ""~/.emacs_backups/""))))

    ;;TODO: Add Xorg check
    ;(require 'nyan-mode)
    ;(nyan-mode)
    ;(nyan-start-animation)
    ;;nyanyanyanyanyanyanyanyanyanyan

thank you
","(case window-system
  (x '""X11 running"")
  (otherwise ""No X11""))

","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 To use ido-find-file, change the interactive specification for the filename argument to F.  That is:
(interactive ""r\nFFilename: "")

That's assuming you're already using ido for opening other files, as by (ido-mode 1) in your .emacs file.
The function to open a file in the background, by which I assume you mean to open a file without displaying it immediately, is called find-file-noselect.
I don't know why the entire buffer after the region would be killed by that call to kill-region; I don't see that happen when I use your code.
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 I am still clueless with the AppData.ini file, but this question contained the answer I was looking to find in regards to the first question. Simply use (getenv [Input]) with the names below to receive their respective file paths.

(getenv ""APPDATA"") ----------> ""C:\Users\AppData\Roaming""
(getenv ""LOCALAPPDATA"") -----> ""C:\Users\AppData\Local""
(getenv ""ALLUSERSPROFILE"") --> ""C:\ProgramData""

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
","The provided context does not directly relate to checking if Xorg is running. However, in Emacs, you can check if a display server (like Xorg) is running by evaluating `(display-graphic-p)`. This function returns non-nil if Emacs is running on a graphical display.

Here's how you can modify your `nCdy-mode` function to include this check:

```lisp
(defun nCdy-mode ()
  ;; Add Xorg check
  (when (display-graphic-p)
    (tool-bar-mode nil)
    (menu-bar-mode nil)
    (scroll-bar-mode nil)
    (setq inhibit-splash-screen t)

    (setq standard-indent 4)
    (mouse-wheel-mode t)
    (setq backup-directory-alist '((",0.5335,[[0.03495706]],0.02674301737960925,0.21362287353383885,0.01851851851851852,0.0,0.01851851851851852
"I am learning Racket (a Scheme-like Lisp), and i have tried to do something like (apply + '(1 2)) but without using apply, and i failed.  I was almost sure before that apply can be somehow simulated using eval, but now i have doubts.
So, my question is: can apply be implemented in Racket (or other Lisp) using only eval and other basic operations?  That is, how to make this work:
{ define [my-apply f arg]
  ;; what does go here?
}
(my-apply + (list 1 2)) ; => 3

","Sure.
(defun my-apply (function arglist)
  (eval (cons function (mapcar (lambda (x) (list 'quote x)) arglist))))
(my-apply '+ '(1 2 3))
6
(my-apply '+ '(1 a 3))
*** - +: A is not a number


Note that you cannot do (my-apply #'+ '(1 2 3)), this would require an extra step.
Note that you have to quote arglist elements to avoid double evaluation (Thanks to Ryan for catching that!)

","Use apply:
(apply 'format ""%s _%s_ %s to do %S in elisp?"" slist)

The apply function takes a function (or symbol) as its first argument, then a number of individual arguments, finishing with a list of arguments.
 You can use apply to splice arguments into a function call:
(emit-str
 (apply element :parking-lot {}
        (map (fn [car] (let [carattrs (:car car)]
                         (element :car {:color (:color carattrs),
                                        :make (:make carattrs),
                                        :year (:year carattrs)}))) 
                           (:parking-lot parking-lot))))

 You want either apply or sometimes funcall.  In this particular case I would go with apply but you need to be familiar with them both.
(apply #'start-process process-name ""*foobar*"" process-path
       some-args other-args-as-a-list)

 apply applies a function to some arguments:
(apply + 1 2 3)
;=> 6

eval evaluates an expression:
(eval '(+ 1 2 3))
;=> 6

 apply calls the function once, passing it the list you've given as the arguments.  I think you instead want to use mapcar:
M-: (mapcar (lambda (arg) (+ 5 arg)) (list 2 3 4)) RET

will return the list (7 8 9).
 Using APPLY:
(defun create-swapped-arg-function (f k)
  ""Takes as input a function f of n variables and an index k.
Returns returns a new function with the first and kth input variables swapped,
which calls the function f.""
  (lambda (&rest args)
    (apply f (progn
                (rotatef (nth k args) (first args))
                args))))

Example:
CL-USER 5 > (funcall (create-swapped-arg-function #'list 2) 0 1 2 3 4 5 6)
(2 1 0 3 4 5 6)

Another way to do it would be to build the source code for such a function, compile it at runtime and return it. That would be useful if these functions are not created often, but called often.
","Yes, `apply` can be implemented in Racket using `eval`. The idea is to construct a call expression with the function and arguments. Here's how you could implement it:\n\n```racket\ndefine (my-apply f arg)\n  (eval (list 'call-with-current-continuation (lambda (k) (k (append (list f) arg)))))\n(my-apply + (list 1 2)) ; => 3\n```\n\nThis implementation uses `call-with-current-continuation` to capture the current continuation and then construct a call expression with the function and arguments. However, this is not a typical or efficient way to implement apply in Racket since Racket already provides a built-in `apply`. The standard use of `apply` in Racket would be more straightforward:\n\n```racket\n(apply + '(1 2)) ; => 3\n```\n\nThis demonstrates how Racket's built-in `apply` works directly with lists as arguments.",0.5679,[[0.2267078]],0.1536790229313455,0.3219748388652176,0.27184466019417475,0.08823529411764706,0.17475728155339804
"My folder looks this way
c:/bar/
c:/bar/dir1
c:/bar/dir2
c:/bar/00.txt
c:/bar/02.txt

I can list files
(directory ""c:/bar/*.*"")
(#P""c:/bar/00.txt"" #P""c:/bar/01.txt"")

but have a problem listing subdirectories
(directory ""c:/bar/*"")
NIL

(directory ""c:/bar/*/"")
NIL

What I am doing wrong?
","Use :directories t in CCL:
(directory ""C:/bar/*.*"" :directories t)

However, if you want to write implementation independent code (e.g. a library you want to share), you should probably heed Vsevolod's recommendation, and use a compatibility layer like cl-fad.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 The code does not byte-compile well at least in Emacs 24.1.1. I saved the following code in the foo.el file, which uses setq in place of incf in order to avoid any possible effects by the cl library:
;; -*- lexical-binding: t -*-

(let ((n 0))
  (defun my-counter ()
    (setq n (1+ n))))

When I tried to byte-compile it (M-x byte-compile-filefoo.el), I got the following warning messages:
foo.el:3:1:Warning: Function my-counter will ignore its context (n)
foo.el:3:1:Warning: Unused lexical variable `n'
foo.el:5:11:Warning: reference to free variable `n'
foo.el:5:17:Warning: assignment to free variable `n'

All of the messages are indicating that the code in the body of the defun construct cannot refer to the surrounding lexical variable n as the manual claims.
Actually, when I loaded the byte-compiled code (M-x load-filefoo.elc) and evaluted the (my-counter) form, I got the following erorr:
Debugger entered--Lisp error: (void-variable n)
  ...

Unfortunately, I'm not sure why the code appears to work when evaluated in the form of source code.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You can also look at tabbar.el to try and figure out where the actual text of the bar is created (i.e. where you'll want to add the ""unsaved"" indicators).  To figure out if a buffer has unsaved changes, you can use the buffer-modified-p function.
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
",The issue you're encountering with `(directory ,0.4157,[[0.12584716]],0.00048007751846324573,0.05252100840336135,0.08163265306122448,0.0,0.04081632653061224
"I wrote a simple Lisp interpreter in Moonscript Lua. The evaluator looks like this:
eval = ( env, expr ) ->
    if is_symbol expr
        lookup env, expr
    elseif is_define expr 
        eval_define env, expr
    elseif is_lambda expr 
        eval_lambda env, expr
    else call (map (partial eval, env), expr)

It works fine. 
But now I would really like to trace out the process, in a way that looks something like this:
(+ (+ a b) (+ a c))

(+ (+ 1 2) (+ 1 4))

(+ 3 5)

8

The thing is, since the evaluation process is recursive, at no point do I have the whole expression to print out.
Do I have to rewrite the evaluator in imperative style or am I missing something obvious?
","This answer is using Common Lisp, because I don't really know Lua.
Actual trace
Typically, you want to trace what actually happens in your code. 
Here is a rewrite of your function and an example of what a tracing tool can do:
(defun normal-eval (form env)
  (etypecase form
    (cons (destructuring-bind (op . args) form
            (apply op
                   (mapcar (lambda (u)
                             (normal-eval u env))
                           args))))
    (null nil)
    (symbol (cdr (assoc form env)))
    (t form)))

> (trace normal-eval)
> (normal-eval '(+ (+ 1 3 a) 2) '((a . 5)))

0: (NORMAL-EVAL (+ (+ 1 3 A) 2) ((A . 5)))
  1: (NORMAL-EVAL (+ 1 3 A) ((A . 5)))
    2: (NORMAL-EVAL 1 ((A . 5)))
    2: NORMAL-EVAL returned 1
    2: (NORMAL-EVAL 3 ((A . 5)))
    2: NORMAL-EVAL returned 3
    2: (NORMAL-EVAL A ((A . 5)))
    2: NORMAL-EVAL returned 5
  1: NORMAL-EVAL returned 9
  1: (NORMAL-EVAL 2 ((A . 5)))
  1: NORMAL-EVAL returned 2
0: NORMAL-EVAL returned 11

Desired trace
There is no easy way as far as I know to have the kind of output you want with the code you provided.
But if you are willing to change your code, you can obtain the trace you want in a purely functional fashion, simply by rewriting the term step-by-step. However, you have to prevent evaluating a term that was already evaluated, in order to let the form be gradually changed. 
(defun s-eval (x env)
  (etypecase x
    (cons (destructuring-bind (new-list . some-evalp)
              (reduce
               (lambda (element R)
                 (destructuring-bind (rec-list . some-evalp) R
                   (multiple-value-bind (value evalp) (s-eval element env)
                     (cons (list* value rec-list)
                           (or some-evalp evalp)))))
               (rest x)
               :from-end t
               :initial-value (cons nil nil))
            (values
             (if some-evalp
                 ;; a least one element required some work
                 ;; so we return the modified term. 
                 (cons (first x) new-list)
                 ;; all elements are literal, we can actually
                 ;; replace this form by its evaluation
                 (apply (first x) new-list))
             T)))
    (null (values nil nil))
    (symbol (values (cdr (assoc x env)) t))
    (t (values x nil))))

(defun step-eval (form &optional env)
  (print form)
  (multiple-value-bind (value evalp)
      (s-eval form env)
    (if evalp
        (step-eval value env)
        value)))

> (step-eval '(+ (+ 1 3 a) 2) '((a . 5)))


(+ (+ 1 3 A) 2) 
(+ (+ 1 3 5) 2) 
(+ 9 2) 
11


> (step-eval '(+ (+ 1 3 a) (* b a)) '((a . 5) (b . 0)))


(+ (+ 1 3 A) (* B A)) 
(+ (+ 1 3 5) (* 0 5)) 
(+ 9 0) 
9

> (step-eval '(+ (+ a b) (+ a c)) '((a . 1)
                                  (b . 2)
                                  (c . 4)))


(+ (+ A B) (+ A C)) 
(+ (+ 1 2) (+ 1 4)) 
(+ 3 5) 
8

S-EVAL evaluates a form in an environment and returns two values: the evaluation of the form and a boolean indicating whether some evaluation actually occurred or if the term was self-evaluating (a literal). This boolean is used to prevent transforming a term where a subterm was transformed by a recursive evaluation.
STEP-EVAL prints the form and calls S-EVAL, before calling itself recursively until evaluation terminates.
","You don't need eval here; use begin instead to group those definitions together into a list; i.e., the template to be expanded should be of the form:
`(begin 
   ,@(map ...)
   (define ...)
   (define ...)
   ...)

Edit:
Change for-each to map as suggested by OP.
 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
","You don't need to rewrite your evaluator in an imperative style. Instead, you can use a technique called macro expansion or create a custom macro that captures the expression before evaluation and prints it out. Alternatively, you can implement a tracing mechanism directly within your evaluator by adding print statements at key points during the recursive evaluation process. For instance, you could add a parameter to your `eval` function to control whether tracing should be enabled, and then conditionally print the current expression being evaluated.",0.4221,[[0.20653488]],1.2776964674082307e-05,0.03985828166519044,0.15699658703071673,0.023972602739726026,0.08191126279863482
"Following this clisp basic website tutorial it asks me to define a package to persist the code:
(defpackage :retro-games
   (:use :cl :cl-who :hunchentoot :parenscript))

However, I cannot work out where my code is being persisted. Where are the files?
NB: I have only one day's experience with lisp!
","Where are the files? They are where you want them.

Create a new file anywhere you want.
Put the definitions into the file.
Done

Lisp can LOAD files and you can use COMPILE-FILE.
In Common Lisp there no connections between files, the location of a file and a package. The package definition just defines a namespace to symbols. But this is not necessarily connected to a file. Some tools help maintain something called a system, which is a collection of files, which can be compiled and loaded together.
To get a basic understanding how to use Common Lisp I recommend reading Practical Common Lisp by Peter Seibel.
","CL-USER> (mapcar #'caddr *jack*)
(FRUIT FRUIT AGENT AGENT)

EDIT: If you want to practise your recursive approach, try:
(defun attempt (list-of-lists)
    (if (null list-of-lists) nil
        (cons (third (car list-of-lists))
              (attempt (cdr list-of-lists)))))

EDIT2: Tail-recursively:
(defun attempt-tail (list-of-lists)
    (labels ((iter (rest ans)
               (if (null rest) (nreverse ans)
                   (iter (cdr rest) (push (third (car rest)) ans)))))
      (iter list-of-lists nil)))

EDIT3: While I'm at it, here's the loop version:
(loop for list in *jack* collect (third list))

 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 Ben Hyde noted in a comment that R. Matthew Emerson spoke to this issue on the Clozure mailing list, pointing out that Clozure CL's default external format has been changed to :utf-8.  As a result, he  suggested this alternative:

We changed the default external format to :utf-8 in the 1.9 release. 
  This is probably tripping you up.
       Try specifying an appropriate external-format explicitly, e.g.,
(defun test (file)
  (with-open-file (stream file :external-format :iso-8859-1)
    (loop while (read stream nil nil))))


 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

","In Common Lisp, when you define a package using `defpackage`, such as `(defpackage :retro-games (:use :cl :cl-who :hunchentoot :parenscript))`, the package definition itself is just a declaration in memory. It does not persist to disk by default. To save your code and its definitions, you typically need to use a mechanism like saving the source file or using a build system that compiles and packages your application.

For development purposes, simply editing and re-saving your `.lisp` files will work as long as they are loaded into the current Lisp session. For more persistent storage of your codebase, consider organizing your files in directories and loading them with `load`, or using a package manager like ASDF (Another System Definition Facility) to manage dependencies and compile your code.

If you want to see where your files are being saved, you can check the file system where your Lisp development environment is set up. Commonly, Lisp IDEs like SLIME for Emacs have features that allow you to navigate and manage your project's file structure.",0.5783,[[0.4303173]],0.1564419904122669,0.3688690717470612,0.41696113074204944,0.10676156583629894,0.1696113074204947
"So far I've tried this, but I'm getting 1:
(define occur
  (lambda (a s)
    (count (curry string-contains? a) s)))

Ex: (occur ""u"" '(""u"" ""uaub"" ""ubub"")) => 1
It should be 5
Want to avoid using curry since I don't know how it works yet:
Dr. Racket Recursion count occurrences
","This drops the reduce for a string-join.
(define (how-many items char)
  (define r (regexp (format ""[^~a]"" char)))
  (string-length (regexp-replace* r (string-join items) """")))

; call it with (how-many '(""u"" ""uaub"" ""ubub"") #\u)

But if you don't want to jam all the string together at once, you can sum the individual results.
(define (how-many items char)
  (define r (regexp (format ""[^~a]"" char)))
  (for/sum ((text (in-list items)))
    (string-length (regexp-replace* r text """"))))

","To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

","The issue with your function `occur` lies in the usage of `count`. The `count` function returns the number of elements that match a predicate. In your case, you are passing a predicate created by `string-contains?`, but it seems like `s` is a list of strings instead of a list of characters or atoms where `count` can directly operate. To fix this, you should flatten the list if necessary and then count the occurrences. Here’s how you can do it without using `curry`: \n\n```lisp\n(defun occur (a s)\n  (let ((flat-s (apply #'append s)))\n    (count a flat-s)))\n```\nThis function first flattens the list `s` into a single list of strings with `apply #'append`, and then counts the occurrences of `a` in this flattened list.",0.5359,[[0.1595127]],0.07892472960904721,0.2493657609069251,0.19905213270142183,0.009569377990430622,0.12322274881516586
"I'm studying SICP, and I didnt exactly get the idea behind function return.
(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))

Code above will be used as ((deriv square) 10), why cant we just make this code simpler? By evaluating the result in 1 step?
(define (deriv g x)
 (/ (- (g (+ x dx)) (g x))
       dx))

Why do we REALLY need function as returned value?
Abstraction? Partial application? I guess there is a much more simpler and clearer idea, what do we need it for, and WHERE to use it. Thanks!
","Well, in this case because mathematically the derivative of a function is a function.  So if you want a function which computes the derivative of a function then it's going to return a function.
And this is useful.  Imagine if you have a function called fplot which will plot a function between two values.  Then I can plot the function sin with
(fplot sin (- pi) pi)

Say.  Now if I want to plot the derivative of sin (let's imagine I didn't know it was cos), I can plot that:
(fplot (deriv sin) (- pi) pi)

fplot doesn't need to know anything at all about where the function it's plotting came from.  The alternative would be to write a special function to plot the derivative of a function, and then perhaps another one to plot the second derivative and so on, and then eventually some function which takes a function and an integer and plots that order of derivative of it or something.
And then you'd realise that, well, wouldn't it be better design to have a function whose job was to plot functions and another function whose job was to compute the functions which are the derivatives of functions, and then these things would compose together nicely.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 (second expr) is the list (* 3 x) which is not a number, but the function sqrt demands a number for its argument. Since you say you want to do symbolic differentiation, you probably should return a list with the symbol sqrt in it, rather than calling the function.
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
","The code `(define (deriv g) (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))` is designed to return a function that computes the derivative of another function `g`. This approach allows for abstraction and partial application. By returning a new function, you can define more complex operations or apply different functions as needed without modifying the original code. For example, if you want to compute the derivative of multiple functions, you only need to call `(deriv some-function)` once, and then use that returned function for further calculations.\n\nIf you were to write it in a single step like this:\n```lisp\n(define (deriv g x) (/ (- (g (+ x dx)) (g x)) dx))\n```\nyou would need to provide both `g` and the value of `x` every time you want to compute the derivative, which is less flexible. The first version allows you to create a derived function that can be used with different values of `x`, providing more flexibility in your code.",0.5722,[[0.53916085]],0.22513885885667792,0.2900763358778626,0.39361702127659576,0.10695187165775401,0.21808510638297873
"I am working on a custom .emacs file that I will be able to use on several different computers. I would like to be able to load a mode if it exists on the system. If it does not exist I would like Emacs to stop showing the error: File error: Cannot open load file, X.
For example:
(require 'darkroom-mode)

Results in:
File error: Cannot open load file, darkroom-mode

I am using file-exists-p to test if certain other files exist but for this test I would assume I need to search my load-path. I am new to Lisp so this is stumping me.
","If you just want to keep require from issuing an error, you can do:
; third arg non-nil means to not signal an error if file not found
; a symbol provides documentation at the invocation (and is non-nil)
(require 'darkroom-mode nil 'noerror) 

From the documentation (C-h f require RET):
require is a built-in function in `C source code'.

(require feature &optional filename noerror)

If feature feature is not loaded, load it from filename.
If feature is not a member of the list `features', then the feature
is not loaded; so load the file filename.
If filename is omitted, the printname of feature is used as the file name,
and `load' will try to load this name appended with the suffix `.elc' or
`.el', in that order.  The name without appended suffix will not be used.
If the optional third argument noerror is non-nil,
then return nil if the file is not found instead of signaling an error.

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 The issue is due to the C-c C-k command not automatically saving the source before it is processed, and thus the processing is happening on the old save of the source. Save first and the problem goes away.
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 The primary problem seems to be that you need to reset the file position after each pass.  The infinite loop happens because you never check for the file end (and suppressed the signal).
Side hint: use dolist instead of that dotimes and nth construction.
If you do not want to make n passes (n being the number of patches), and you cannot hold the entire contents in memory, you could write the patches to temporary files, then concatenate them in the desired order.  If you also do not have enough disk space, it becomes an in-place sort problem with varying element sizes, which is a bit more involved.
 The actual error was that the (read) part in the functions did not have stream declared so it was reading the input from the script as it was running rather than from the terminal.
",Answer not found.,0.3983,[[0.13349342]],1.4650716977652323e-27,0.008920606601248885,0.024242424242424242,0.012269938650306747,0.024242424242424242
"I am trying to check if a word is an element of a list.  It it isn't then add the word to the front of the list, but if it is move that word to the front of the list.  I am able to add the word to the list if it isn't already there, but I don't know how to the move the element to the front of the list if it is in the list already. Here is my code:
(defun movetofront (word lst)
  (cond
    ((member word lst) 
     (remove word lst))
    (T (cons word lst)))) 

","You do not have to check for the presence:
(defun move-to-front (word list)
   (cons word (remove word list)))

Note that if word is, e.g., a string, you will need to pass :test to remove.
","As mentioned in first comment it is necessarily to use (list a b c) form.
 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Open the file and read in the data:
(with-open-file (f ""file.txt"")
  (read f))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The criteria for deleting an element from the input list is not stated clearly in the question. This will work for the example shown:
(define lst
  '((pacific (atlanta ohaio) (NY LI))
    (atlanta (pacific blue) (ohaio green))))

(map (lambda (slst)
       (filter (lambda (e)
                 (not (and (list? e) (member 'pacific e))))
               slst))
     lst)

=> '((pacific (atlanta ohaio) (NY LI)) (atlanta (ohaio green)))

If necessary, for other inputs you can tweak the condition in the innermost lambda until the result is as desired. For instance, I interpreted the comment in the question:

I want to delete the sublist that contains the searched word

As: ""find the searched word in any position inside a sublist""; if the searched word can be found in, say, only the first position then adjust the condition accordingly.
","To achieve your goal of moving an element to the front of a list if it is already present, you can use a combination of `member`, `remove`, and `cons`. Here's how you can modify your function:\n\n```lisp\n(defun movetofront (word lst)\n  (let ((pos (position word lst)))\n    (if pos\n        (append (list (nth pos lst)) (delete-duplicates (delete (nth pos lst) lst :count 1)))\n        (cons word lst))))\n```\n\nThis function first finds the position of `word` in `lst`. If it is found, it removes that element and then appends it to the front of the rest of the list. If `word` is not found, it simply cons `word` onto the beginning of `lst`.",0.5647,[[0.33257312]],0.07976683130510888,0.3816535705438919,0.29299363057324845,0.038709677419354833,0.1656050955414013
"I'm pretty fresh to the Common Lisp scene and I can't seem to find an quick way to get the nth element from a list and remove it from said list at the same time. I've done it, but it ain't pretty, what I'd really like is something like ""pop"" but took a second parameter:
(setf x '(a b c d))
(setf y (popnth 2 x))
; x is '(a b d)
; y is 'c

I'm pretty sure that ""popnth"" would have to be a macro, in case the parameter was 0 and it had to behave like ""pop"".
EDIT: Here's my crap first version:
(defmacro popnth (n lst)
  (let ((tempvar (gensym)))
    `(if (eql ,n 0)
      (pop ,lst)
      (let ((,tempvar (nth ,n ,lst)))
        (setf (cdr (nthcdr ,(- n 1) ,lst)) (nthcdr ,(+ n 1) ,lst))
        ,tempvar))))

","I came up with a solution that is a little more efficient than my first attempt:
(defmacro popnth (n lst)
  (let ((t1 (gensym))(t2 (gensym)))
    `(if (eql ,n 0)
      (pop ,lst)
      (let* ((,t1 (nthcdr (- ,n 1) ,lst))
              (,t2 (car (cdr ,t1))))
        (setf (cdr ,t1) (cddr ,t1))
        ,t2))))

Here is it in action:
[2]> (defparameter *list* '(a b c d e f g))
*LIST*
[3]> (popnth 3 *list*)
D
[4]> *list*
(A B C E F G)
[5]> (popnth 0 *list*)
A
[6]> *list*
(B C E F G)

","You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Not that bad. I would write it this way:
(defun group (list)
  (flet ((take-same (item)
           (loop while (and list (eql (first list) item))
                 collect (pop list))))
    (loop while list
          collect (take-same (first list)))))


CL-USER 1 > (group '(1 2 4 5 6 6 7 8 10 10 10))
((1) (2) (4) (5) (6 6) (7) (8) (10 10 10))

 It is an implemntaiton issue:
ccl e$ rlwrap ./dx86cl64
Loading ~/ccl-init.lisp
Welcome to Clozure Common Lisp Version 1.7-dev-r14614M-trunk  (DarwinX8664)!
? (subtypep 'string '(array character))
T
T
? 

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Given that this expression is evaluated only for its effect (printing a message), you should explicitly return a value (any value!) as the result of the let form:
(let ((x 1))
  (cond ((< x 2)  
         (display ""hooray"")
         (newline))
        (else 
         (display ""bummer"")
         (newline)))
  'ok)

Now we'll get:
hooray
'ok

","In Common Lisp, you can achieve this by defining a custom function that mimics the behavior of `popnth`. The provided implementation is close but can be optimized. Here's an improved version using a macro to ensure it works correctly for both zero and non-zero indices:\n\n```lisp\n(defmacro popnth (n lst)\n  (let ((tempvar (gensym)))\n    `(if (eql ,n 0)\n        (pop ,lst)\n        (let ((,tempvar (nth ,n ,lst)))\n          (setf (cdr (nthcdr (- ,n 1) ,lst)) (nthcdr (+ ,n 1) ,lst))\n          ,tempvar))))\n```\n\nThis macro will correctly handle the case when `n` is zero, behaving like `pop`. For other cases, it removes the nth element from the list and returns that element. Note that this approach modifies the original list destructively.",0.6575,[[0.24738987]],0.3349415895433969,0.4084948233861144,0.2803738317757009,0.10377358490566038,0.2336448598130841
"Why does (defun boolimplies (a b) (or (not a) b)) if called as 
(boolimplies 'a 'b) return B?
How does it arrive at this conclusion even when I don't use any boolean value (NIL,T) but just variable names?
","While only t and nil are booleans in Common Lisp, there are also generalized booleans. That is, all objects can be used as truth values, and only the symbol nil is false. You are passing symbols other than nil, which are true.
(Just to avoid any potential confusion: If you have variables a and b and want to use their values instead of symbols, just pass them unquoted.)
","? (defun foo (a b) (+ a 2))
;Compiler warnings :
;   In FOO: Unused lexical variable B
FOO

? (defun foo (a b)
    (declare (ignore b))
    (+ a 2))
FOO

 As mentioned in first comment it is necessarily to use (list a b c) form.
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 According to the grammar, options must be parenthesized individually.  The defstruct form therefore needs to look like this:
(defstruct (test-struct (:print-function print-test)
                        (:constructor create-test (&key a (b a) c)))
  a
  b
  c)

 The alternate expression for the 'if' expression is ((set! ...) ...).  The first position needs to be either a function or a syntactic form.  In this case you need progn as:
(progn
  (setq list1 ...)
  (setq list2 ...)
  (eql x y))

","The function (defun boolimplies (a b) (or (not a) b)) evaluates its arguments in an order that prioritizes short-circuit evaluation. When you call (boolimplies 'a 'b), the expression (not a) is evaluated first. Since 'a' is non-nil, (not 'a) returns nil. The or function then checks the next argument, which is 'b'. Because 'b' is not nil, the overall result of the or function is 'b'. Therefore, the function returns 'b' without needing to evaluate the entire expression further.",0.4998,[[0.15411797]],0.07586605351975555,0.3264832738281141,0.18791946308724833,0.0,0.10738255033557047
"The following code executes as expected but gives a NullPointerException at the end. What am I doing wrong here?
(ns my-first-macro)

(defmacro exec-all [& commands]
  (map (fn [c] `(println ""Code: "" '~c ""\t=>\tResult: "" ~c)) commands))

(exec-all
  (cons 2 [4 5 6])
  ({:k 3 :m 8} :k)
  (conj [4 5 \d] \e \f))

; Output:
; Clojure 1.2.0-master-SNAPSHOT
; Code:  (cons 2 [4 5 6])   =>  Result:  (2 4 5 6)
; Code:  ({:k 3, :m 8} :k)  =>  Result:  3
; Code:  (conj [4 5 d] e f)     =>  Result:  [4 5 d e f]
; java.lang.NullPointerException (MyFirstMacro.clj:0)
; 1:1 user=> #<Namespace my-first-macro>
; 1:2 my-first-macro=> 

(For properly syntax highlighted code, go here.)
","Take a look at the expansion that is happening:
(macroexpand '(exec-all (cons 2 [4 5 6])))
=>
((clojure.core/println ""Code: "" (quote (cons 2 [4 5 6])) ""\t=>\tResult: "" (cons 2 [4 5 6])))

As you can see, there is an extra pair of parentheses around your expansion, which means that Clojure tries to execute the result of the println function, which is nil.
To fix this I'd suggest modifying the macro to include a ""do"" at the front, e.g.
(defmacro exec-all [& commands]
  (cons 'do (map (fn [c] `(println ""Code: "" '~c ""\t=>\tResult: "" ~c)) commands)))

","Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

","The issue with your Clojure macro is that you are using backquote (`) quoting inside a form quoted by `map`. The backquote is used for syntax quoting, which allows for unquoted symbols to be evaluated within the context of the quote. However, when used directly in a function call like `(map (fn [c] `(println ",0.5416,[[0.30625957]],0.08237511495814905,0.18945297127115307,0.2913907284768212,0.053691275167785234,0.18543046357615894
"I got two simple-arrays, of which element-type is '(unsigned-byte 8). If I use (concatenate 'vector array-A array-B), the result array's element-type won't be '(unsigned-byte 8) anymore.
How can I concatenate arrays and keep their element-type in Lisp?
","As Rainer Joswig points out in the comments, you could simply specify the element type of your result vector:
(concatenate '(vector (unsigned-byte 8)) array-A array-B)

Note that the documentation says:

If the result-type is a subtype of vector, then if the implementation
  can determine the element type specified for the result-type, the
  element type of the resulting array is the result of upgrading that
  element type.

Therefore, your LISP implementation is free to choose a ""better"" element type for the result vector (this might happen if you specify something like (unsigned-byte 5), for instance).
","The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 The proposed operations can indeed be implemented as a reduce (a.k.a. foldr):
(+ 1 (* 9 (+ 2 (* 9 (+ 3 (* 9 13))))))
=> 9739

(reduce (lambda (e acc) (+ e (* 9 acc)))
        13
        '(1 2 3))
=> 9739

Regarding the constants, 13 is used only once in the innermost expression, so it's a good fit to be used as an initial value. 9 is used to multiply the accumulated value. The input list is used from right to left when the recursion starts to unwind, and at that point we add the current element to the accumulated result.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 An example: if list is (3 3 5 6 6 6 9), the loop will examine each list element in turn, and set these hash keys to t: 3, 5, 6, and 9.  Since 3 and 6 are duplicated in the list, no new hash key will be created for those elements.  Finally hash-table-count returns the number of keys in the hash table, i.e. 4.
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
","To ensure that the element-type of the resulting array remains '(unsigned-byte 8)', you need to explicitly specify this type when concatenating the arrays. Unfortunately, `concatenate` does not preserve the element-type by default. However, you can achieve the desired result using `make-array` and copying elements manually while specifying the element-type. Here's an example:

```lisp
(let ((array-A #.(make-array 3 :element-type '(unsigned-byte 8) :initial-contents '(1 2 3)))
      (array-B #.(make-array 2 :element-type '(unsigned-byte 8) :initial-contents '(4 5))))
  (let* ((total-length (+ (length array-A) (length array-B)))
         (result (make-array total-length :element-type '(unsigned-byte 8))))
    (dotimes (i (length array-A))
      (setf (aref result i) (aref array-A i)))
    (dotimes (j (length array-B))
      (setf (aref result (+ j (length array-A))) (aref array-B j)))
    result))
`

This will create a new array with the specified element-type and copy elements from `array-A` and `array-B` into it.",0.5756,[[0.47636852]],0.14412403048163186,0.3702056814339611,0.38461538461538464,0.14728682170542634,0.2153846153846154
"How do I implement a program in Scheme taking the elements of a given list and returning a new list where the elements are random gatherings of the previous list? I would like it to work for any length. For example:
Input: '(a e i o u), output: '((a e) (i o) (u)) for length 2.
My attempts (making use of for/list) are being clumsy and based on recursion. I have divided the tasks  as suggested by Óscar:

Select n elements randomly from a list l:
(define (pick-n-random l n)
  (take (shuffle l) n))

Remove a list l2 from a list l1:
(define (cut l1 l2)
  (cond ((null? l1)
         '())
        ((not (member (car l1) l2))
         (cons (car l1) (cut (cdr l1) l2)))
        (else
         (cut (cdr l1) l2))))


Then, and that is my problem: how do I recurse over this process to get the intended program? Should I use for/list to paste all sublists got by this process 1. and 2.?
","It's easier if we split the problem into chunks. First, let's write a couple of procedures that will allow us to take or drop n elements from a list, with appropriate results if there are not enough elements left in the list (if not for this, we could have used the built-in take and drop):
(define (take-up-to lst n)
  (if (or (<= n 0) (null? lst))
      '()
      (cons (car lst) (take-up-to (cdr lst) (sub1 n)))))

(define (drop-up-to lst n)
  (if (or (<= n 0) (null? lst))
      lst
      (drop-up-to (cdr lst) (sub1 n))))

With the above two procedures in place, it's easy to create another procedure to group the elements in a list into n-sized sublists:
(define (group lst n)
  (if (null? lst)
      '()
      (cons (take-up-to lst n)
            (group (drop-up-to lst n) n))))

Finally, we combine our grouping procedure with shuffle, which randomizes the contents of the list:
(define (random-groups lst n)
  (group (shuffle lst) n))

It works as expected:
(random-groups '(a e i o u) 2)
=> '((e a) (u i) (o))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 If I understood correctly, you can combine reduce and append to flatten the list before returning it.  
Example:  
(reduce 'append '((1) (2) (3)))

Output:  
(1 2 3)

In your case this might work:
(reduce 'append (mapcar 'recursive-function L))

 Your recursive addNode (better called add-node if you are a lisper) needs a stop condition.
E.g.,
         (add-node (edge-list)
           (push (car (pop edge-list)) nodes)
           (when edge-list
             (add-node (cdr edge-list))))

Note that there is no reason to use recursion here, a simple mapcar would do just fine:
(defun extract-nodes (el)
  (mapcar #'car el))

 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

","To achieve the desired functionality of grouping elements from a list into random sublists of specified length, you can follow these steps without necessarily using recursion or `for/list`. Instead, leverage higher-order functions and functional programming techniques common in Lisp. Here’s how you can do it:\n\n1. **Shuffle** the input list to ensure randomness.\n2. **Map** over a range of indices to generate sublists of the desired size.\n3. **Use `subseq` or a similar function** to extract these sublists from the shuffled list.\n\nHere's an example implementation in Lisp:\n```lisp\n(defun random-sublist (lst n)\n  \",0.5338,[[0.2990016]],0.04823260963492254,0.15071683717611678,0.31141868512110726,0.04878048780487805,0.15224913494809686
"I'm trying to go through ""The Little Lisper"" and already running into snags in the first chapter. I'm relatively new to Emacs (which has fueled my interest in learning Lisp and clojure). I downloaded the Mit-scheme app, and am working the exercises on Edwin.
I'm trying:
(atom? (cons a l))

where a is an atom and l is a list already defined. I get the following error:
;Unbound variable: atom?

Why? I have no problems using the ""null?"" function. I thought ""atom?"" is an internal function checking to see if the value returned is an atom.
Any explanation would be much appreciated. I still haven't set up my emacs to run scheme, and the minor differences between all the lisp dialects is testing my patience.
","In ""The Little Schemer"" (""The Little Lisper""'s updated version) the atom? procedure is defined as follows (because atom? doesn't exist in Scheme):
(define (atom? x)
  (and (not (null? x))
       (not (pair? x))))

If you're following an old version of the book, I advise you to either look for a newer version or use the same programming language used in the book: Common Lisp for The Little Lisper, Scheme for The Little Schemer - and Racket is a great Scheme IDE to work with! take a look at this answer for some tips when going through The Little Schemer using Racket.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 There is an ASDF library called shut-it-down that provides a quit function that works by just having cases for the common CL implementations.
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The code works fine if you ""invert"" the 2 middle tests:
(defun lis(L)
  (cond
   ((null L)          nil)
   ((numberp (car L)) (lis (cdr L)))
   ((atom (car L))    (cons (car L) (lis (cdr L))))
   (t                 (append (lis (car L)) (lis (cdr L))))))

because (not (numberp (car L))) is also true for lists so in the initial version the code never recurses down into a sublist.
",Answer not found.,0.4,[[0.06874334]],2.9777978417488406e-19,0.011125945705384957,0.03809523809523809,0.0,0.019047619047619046
"can I use common lisp and Clojure from within emacs at the same time?
I would like to have each lisp-REPL in its own buffer, and If i did this how could I controll which buffer sent its data to which lisp?
","Yes. In the documentation to Slime you will find slime-lisp-implementations. Here is how I have it defined in my .emacs:
(setq slime-lisp-implementations
   '((cmucl (""/usr/local/bin/lisp"") :coding-system iso-8859-1-unix)
     (sbcl (""/usr/local/bin/sbcl"" ""--core"" ""/Users/pinochle/bin/sbcl.core-with-swank"") :init (lambda (port-file _) (format ""(swank:start-server %S :coding-system \""utf-8-unix\"")\n"" port-file)))
     (clozure (""/Users/pinochle/bin/ccl""))
     (clojure (""/Users/pinochle/bin/clojure"") :init swank-clojure-init)))

You start up your lisps using M-- M-x Slime. It will ask you which Lisp to start up, and you use the name you defined in slime-lisp-implementations. In this example, I would use cmucl, sbcl, clozure or clojure.
You can switch the ""active"" REPL using the command C-c C-x c. For more info, see the Slime Documentation on controlling multiple connections.
","I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Finally, an option that worked for me was to use the transaction queue API, which is higher level (so it cannot handle all sorts of protocols), but ensures correct ordering of alternating messages.
 I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

 buffer-substring together with region-beginning and region-end can do that.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 AutoLISP does not support multiple threads - programs are executed in 'series' using a single processor thread. As such, this is unfortunately not possible.
","Yes, you can use Common Lisp and Clojure from within Emacs at the same time. Each REPL can be run in its own buffer using packages such as `slime` for Common Lisp and `cider` for Clojure. To control which buffer sends its data to which lisp, you would need to switch focus to the respective buffer before sending commands or evaluating code. You can also use key bindings or scripts to automate switching between buffers if needed.",0.5011,[[0.29092095]],0.02610850014224306,0.17121045896517637,0.26785714285714285,0.018018018018018018,0.13392857142857142
"I am having trouble figuring out how to access specific pair information in Racket. 
Say I am given some list like this:
(define database-of-components
'((p1 200 (2 p2) (3 p3))
(p2 8 (2 p4))
(p3 60 (1 p5) (2 p6) (3 p7))
(p4 2)
(p5 2)
...
))

How am I able to access the data contained in some individual pn? Say I am trying to get just 200 from p1 or just 60 from p3... how might I do this?
Note: This is obviously for a homework assignment but this question is just to get started.
","Look up assq and friends (assoc, assv):
> (assq 'p1 database-of-components)
'(p1 200 (2 p2) (3 p3))
> (second (assq 'p1 database-of-components))
200
> (second (assq 'p3 database-of-components))
60

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 The procedure as defined works fine in Racket. It seems like a bug to me, or something very specific to your environment.
Almost certainly not related to your problem, but a bit of nit-picking: use the comparison (= n 1) for numbers instead of (eq? n 1).
 Yes, it's possible. The easiest way would be to simply redefine the class. You do that by issuing another call to DEFCLASS. If you want to do more complicated things, you have to resort to the MOP (MetaObject Protocol). Essentially everything you'd ever want to do is possible using the MOP, but I would need more detailed information as to what it is you're trying to do in order to explain it further.
","To access specific information from pairs within a list in Racket, you can use various functions like `car`, `cdr`, and `caar` (which stands for 'car of car of car'). For example, to get the first element associated with `p1`, which is `200`, you would do something like this:\n\n```racket\n(define database-of-components\n  '((p1 200 (2 p2) (3 p3))\n    (p2 8 (2 p4))\n    (p3 60 (1 p5) (2 p6) (3 p7))\n    (p4 2)\n    (p5 2)))\n\n(car (car database-of-components)) ; This gives you the first component, which is '(p1 200 (2 p2) (3 p3))\ncar (car (cdr database-of-components)) ; This gives you 'p1\ncadr (car (cdr database-of-components)) ; This gives you 200\n`\nYou can continue to use `cadr`, `cdar`, etc., depending on how deep into the structure you need to go. In this case, `(cadr (car (cdr database-of-components)))` will give you `200`. Adjust according to your needs.",0.5857,[[0.30747925]],0.10220223755603888,0.4129839298758219,0.21649484536082472,0.11458333333333334,0.19587628865979378
"As the title says I want to give my lambda function a name to call it later in my code.
But the name that I want to associate it to is a variable. What can I do?
(defparameter funct-name 'addone)
 funct-name = (lambda (x) (x+1))

So my call must be like this:
(addone 3)

funct-name is a variable that contains the name that I want to give to my lambda function.
","(setf (symbol-function funct-name) (lambda (x) (+ x 1)))

","To pass a list of arguments to a function you can use apply, for example
(apply 'insert '(""hello "" ""world""))
 The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

 It is a parenthesis issue. It happens quite a lot when beginning with scheme.
I recommend that you indent your code correctly, it will make it more readable and much less error prone.
(define func
  (lambda (N lst)
    (if (eq? N 0)         
        0 
        (+ (car lst) 2))))

The extra () you had was translated to a function call
 In this case, x[0] is define, x[1] is the variable name, and x[2] is the expression. So, in Python, _, var, exp = x is a ""destructuring assignment"", which destructures the array x into its constituent elements, and assigns them to the variables on the left-hand side.
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

","In Lisp, you can't directly assign a lambda function to a variable without evaluating it. However, you can achieve this using the `setf` function or by defining the lambda function inside another function that returns it. Here's how you can do it:\n\n```lisp\n(defun create-function (name)\n  (lambda (x) (+ x 1)))\n\n(defparameter funct-name (create-function 'addone))\n\n(funcall funct-name 3) ;; This will return 4\n```\nIn this example, `create-function` returns a lambda function that increments its argument by one. The result is then assigned to the variable `funct-name`. You can call the function using `(funcall funct-name 3)`.",0.5564,[[0.42123931]],0.07832610836583813,0.3086547118847539,0.13333333333333333,0.06779661016949153,0.11666666666666665
"I have a list
'((1 2 (A B C)) (2 3 (B C D)) (4 5 (C D F)))

I want to process the elements in the inner list, (in this case, I want to change (A B C) and other lists to (M M M)).
I wrote a code (process lst), which will do this task for the inner list.
(defun process (lst)
  (cond
    ((null lst) '())
    (T (cons 'M (process (cdr last))))))

And when I call from the main function,
(defun iterate-list (lst)
  (cond
    ((null lst) '())
    ((listp (car lst)) 
     (cons (process (car lst)) 
           (iterate-list (cdr lst))))
    (T 
     (cons (car lst) 
           (iterate-list (cdr lst))))))

I am getting ((M M M) (M M M) (M M M)) instead of ((1 2 (M M M)) (2 3 (M M M)) (4 5 (M M M))).
But when I use the same function, with just (cons (car lst)) (iterate-list (cdr  lst))) in the second condition (listp (car lst)), I am getting the correct answer, that is
'((1 2 (A B C)) (2 3 (B C D)) (4 5 (C D F)))

I don't know where I am making the mistake.
","NB. You need to rename last to lst in process.

I am getting ((M M M) (M M M) (M M M)) instead of ((1 2 (M M M)) (2 3 (M M M)) (4 5 (M M M))).

The code works, but not that at the depth you want:
(process '(a b c d))
=> (M M M M)

(iterate-list '(1 2 (A B C)))
=> (1 2 (M M M))

In order to process all lists in your root list, you could do this:
(mapcar #'iterate-list '((1 2 (A B C))
                         (2 3 (B C D))
                         (4 5 (C D F))))

=> ((1 2 (M M M)) (2 3 (M M M)) (4 5 (M M M)))

","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 As mentioned in first comment it is necessarily to use (list a b c) form.
 Iterate over your list and store each pair's car into a list in an assoc that looks like this:
original: ((2 . 1) (3 . 2) (1 . 2) (5 . 1) (6 . 3))
new:      ((1 . (2 5))
           (2 . (3 1))
           (3 . (6))

Then sum together all the cdrs and flip each pair to get this:
          ((7 . 1) (4 . 2) (6 . 3))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
","The issue lies in how you are calling and using the `process` function within your `iterate-list` function. Specifically, you should be passing `(cdr lst)` instead of just `(lst)`. Also, there is a small typo where you wrote `last` instead of `cdr lst` in the recursive call. Here's the corrected version of your code:\n\n```lisp\n(defun process (lst)\n  (cond\n    ((null lst) '())\n    (T (cons 'M (process (cdr lst))))))\n\n(defun iterate-list (lst)\n  (cond\n    ((null lst) '())\n    ((listp (car lst)) \n     (cons (process (car lst)) \n           (iterate-list (cdr lst))))\n    (T \n     (cons (car lst) \n           (iterate-list (cdr lst))))))\n\n;; Example usage\n(iterate-list '((1 2 (A B C)) (2 3 (B C D)) (4 5 (C D F))))\n```\nThis should give you the expected output: `((1 2 (M M M)) (2 3 (M M M)) (4 5 (M M M)))`. The key change is ensuring that `(cdr lst)` is used consistently in both functions to traverse and process each sublist correctly.",0.6681,[[0.41138466]],0.3395805681770529,0.4492805000407554,0.38775510204081637,0.23287671232876714,0.3061224489795918
"On page 178, there is a question: what is the value of
(cons rep-car
    (cons (cons rep-quote
        (cons
            (cons rep-a
                (cons rep-b
                    (cons rep-c
                        (quote ()))))
            (quote ())))
    (quote ())))

where
rep-car is car
rep-quote is quote
rep-a is a
rep-b is b
rep-c is c

The answer in the book is
(car (quote (a b c)))

But I think the answer should be
(car ((quote ((a b c)))))

Why am I wrong?
","No, the answer in the book is right. Note that the expression has 3 occurrences of (quote ()), to create 3 lists. Then it conses various atoms onto the lists. Your answer contains 5 lists, not 3.
(quote ()) simply returns an empty list. (cons 1 (quote ())) adds one item to the empty list to yield (1).
","You have an extra quote (the first one is stuck to the car but still parses correctly) in there which causes a quoted quote, so what you essentially have is:
(write (cdr (car '((quote (p q)) r))))

Taking the car of this leaves you with just the data:
(quote (p q))

And again taking the cdr of this results in the data:
(p q)

As you observed. If you look at the car of the car instead with
(write (car (car '((quote (p q)) r))))

you should see the
quote

itself. Remember that '(a b) and (quote (a b)) are the same thing, and the printout from whatever you're using might show either form.
So what you want to do is just remove the extra quote, i.e.:
(write (cdr (car '((p q) r))))

 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 As mentioned in first comment it is necessarily to use (list a b c) form.
 Here's how:

Click on the ""run"" button, as you discovered
Press Esc  + p

And this is the relevant page in the documentation.
 You have a little bug in your code, try this in the EVALPlus procedure:
(+ (car argList) (car (cdr argList)))

Remember that cdr retrieves the next list, not the next element. After obtaining the next list, we call car to obtain its first element.
 Iterate over your list and store each pair's car into a list in an assoc that looks like this:
original: ((2 . 1) (3 . 2) (1 . 2) (5 . 1) (6 . 3))
new:      ((1 . (2 5))
           (2 . (3 1))
           (3 . (6))

Then sum together all the cdrs and flip each pair to get this:
          ((7 . 1) (4 . 2) (6 . 3))

","The book's answer is correct. When substituting the macros with their definitions, you get:\n\n(cons car (cons (cons quote (cons (cons a (cons b (cons c (quote ())))) (quote ()))) (quote ())))\n\nThis simplifies to:\n\n(cons car (cons (cons quote (cons (cons a (cons b (cons c (quote ())))) (quote ())))) (quote ()))\n\nFurther simplifying, you get:\n\n(cons car (cons (cons quote (cons (cons 'a (cons 'b (cons 'c (quote ()))))) (quote ()))) (quote ()))\n\nWhich becomes:\n\n(car ((quote ((a b c))) (quote ()) (quote ())))\n\nAnd finally, the (car ...) operation extracts the first element of the list, which is (quote ((a b c))), and then car again extracts the list itself. So, the value is indeed (car (quote (a b c))).",0.5585,[[0.34532826]],0.10528891900129334,0.33408853644477277,0.18994413407821228,0.022598870056497175,0.1229050279329609
"To enhance efficiency of my Lisp program, I want to insert this line into my code:
(optimize (speed 3) (safety 0) (debug 0) (space 0))

Currently I think I should put it at the top of each file. Is it a good idea or should I insert this line in one specific place? (I use ASDF for system definition.)
Another part of my question: is (safety 0) safe? Few of my functions use explicit declarations of variable types, what will happen to the others? Should I omit (safety 0) to avoid problems that might occur due to missing type-checking?
","I would avoid setting compilation policies globally, since ""as with other defining macros, it is unspecified whether or not the compile-time side-effects of a declaim persist after the file has been compiled"". If you really want to use a global policy per file, you can use the locally special form at top-level (subforms of a top-level locally remain top-level forms)
(locally (declare (optimize speed #| ... whatever ... |#))

   (defun compute-foo (x) 
     (1+ x))

   (defun compute-bar (y) 
     (* (compute-foo y) y)))

instead of
(declaim (optimize speed #| ... whatever ... |#))
...

or even
(proclaim '(optimize speed #| ... whatever ... |#)) 

I tend to use declarations sparingly, usually only local within a function, i.e.,
(defun compute-foo (x)
   (declare (fixnum x))
   (1+ x))

Many modern Lisp compilers (like SBCL) have become pretty good at figuring types out. Further, I'd never use (safety 0) globally, since it may be dangerous, in particular during development, when things haven't really settled down and mistakes are common.
","There is an ASDF library called shut-it-down that provides a quit function that works by just having cases for the common CL implementations.
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","Putting `(optimize (speed 3) (safety 0) (debug 0) (space 0))` at the top of each file is not ideal. It's better to define it once in a system definition file when using ASDF for your project. This way, the optimization settings will be applied consistently across all files within that system without cluttering individual source files.\n\n`(safety 0)` can make your code more vulnerable to runtime errors because safety optimizations like bounds checking and type checking are disabled. If you have functions that do not include explicit type declarations, they may behave unexpectedly or even crash at runtime if given invalid input. However, if you're certain that all calls in the system are robust and will handle unexpected data correctly, then using `(safety 0)` might be acceptable.\n\nIf you're unsure about missing type-checking, it's safer to keep `(safety 1)` or even `(safety 2)`, which provides some level of protection against runtime errors. You can always adjust the safety setting as needed after thorough testing.",0.5305,[[0.23024609]],0.10714725491638757,0.28302652174663007,0.30030030030030025,0.036253776435045314,0.1021021021021021
"I've been learning Lisp recently (Scheme, Racket and Clojure to various extents) and have read the corresponding literature on famous Playstation developer Naughty Dog.
This Gamasutra article mentions that their streaming engine actually streams in game code in addition to game data.
Now, they have a dialect of Lisp called GOAL which they use extensively.
I know of Lisp's ""Code as Data"", although I have yet to grok this concept fully.  So, I was wondering if the ability to stream code is a property of their code being Lisp data or compiled machine code, as opposed to being a generic design pattern that can be used in many languages?
Can someone point me to literature on this topic?
Bonus: Can someone point me to literature on long-term-listening-compilers as mentioned in the Wikipedia article?
","A 'Listener' in Lisp speak is a REPL (Read Eval Print Loop). Listeners usually provide several services like integrated debugger, command histories, command interpreters, and more. In many cases the Listener runs inside the Lisp one is using. In some cases all code typed to a REPL/Listener is compiled before executing (examples are Clozure CL, SBCL). If that is not the case, the code can be compiled on demand (see the COMPILE or COMPILE-FILE functions in Common Lisp).
Here I would guess that the development environment was implemented in Allegro Common Lisp and the runtime runs on a Playstation. The development environment provides an interface to talk to the runtime and allows to compile code and to download it into the runtime. I would guess that the compiler does not run on the Playstation, but inside the development environment. The Listener then also provides functionality to look at the state of the running application on the Playstation, including the symbol table. So, one connects the development environment to the Playstation's running application and one can interact with that, including changing data and code.
Since Lisps typical can load both source and compiled code at runtime, 'streaming' code is not that difficult. It just means that one loads the code (possibly in the background) while the player moves around in the game. If the code is organized in a certain way, it can also be garbage collected once it is no longer needed. For example if a 'room' in a game is an object and the room points to various functions by name, the functions can be autoloaded on demand if the player is in the room. If the player leaves the room the code can be automatically or semi-automatically unloaded. In a typical Lisp the garbage collector would collect unreferenced code. In a game that might not be a task of the GC, but of some other more 'manual' process. This would be a functionality of the GOAL runtime. Compare that with the stock JVM which could not garbage collect unloaded code (AFAIK).
","Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
 See yasnippet.  It provides snippets for most major languages, and it is easy to add new ones or modify the old ones.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The convention I use is to use a unique word: salza, skippy, zs3, etc. I don't really try to have a direct relationship to the library functionality. I try to avoid generic words that others might use like ""zlib"" or ""zip"" or ""png"".
Edi Weitz uses Frank Zappa-related words to name many of his packages: Hunchentoot, Drakma, etc.
Some people use Java-style org.foo.bar reversed domain naming.
So, the direct answer is no, there isn't a common, agreed-upon convention that everyone uses.
 Probably, the best thing to do is switch the language in DrRacket to ""Use the language declared in the source"", and start your file with #lang racket.  Then functions like current-seconds and friends will be available.
Alternatively, you could use the profiling library, available via (require profile) and documented here.  
Finally, you might want to look at Neil Van Dyke's SICP library for DrRacket.
","The ability to stream code is not a property inherent to Lisp or its data representation. It's more about the specific implementation and design choices made by Naughty Dog for their GOAL dialect of Lisp. The fact that GOAL streams in game code along with game data suggests they have a custom system that allows partial compilation and loading of code at runtime, which can be beneficial for optimizing memory usage and load times in games.

For literature on this topic, you might want to explore papers or articles specifically related to Naughty Dog's development processes and the GOAL language. Unfortunately, detailed technical documentation about GOAL is likely proprietary and not publicly available. However, you could look into academic research on code streaming techniques for real-time systems and game engines, which might provide some insights.

Regarding long-term-listening-compilers (LTLC), these are more of a theoretical concept rather than an existing technology in widespread use. LTLC refers to compilers that can listen to program execution over time and adaptively optimize the compiled output based on runtime behavior. This is still an active area of research, and you might find relevant papers by searching for keywords like 'adaptive compilation', 'run-time code optimization', or 'self-optimizing compilers'.",0.552,[[0.45064566]],0.11341194369257039,0.240089027804219,0.348294434470377,0.03963963963963964,0.12208258527827648
"I am trying to create subsequences of some word with the following code.  When I added by k, the code stopped responding, though if I replace k with a particular number, it works.  What is happening?
(let ((c nil)) (loop for k from 0 to (length ""abc"")
     finally (return c) do (loop for j from 0 to (length ""abc"") by k 
    do (loop for i from j to (length ""abc"") do (push (subseq ""abc"" j i) c))))) 

","Debugging

if I replace k with a particular number, it works

What happens if you replace k with 0?
It would be much more helpful if you formatted this code with typical conventions, and probably if you isolated the particular part of the code that's problematic.  That is, (remove-duplicates …) isn't the problem here, you could have removed it.  With some more conventional formatting, and some comments, your code is:
(remove-duplicates
 (let ((c nil))
   (loop for k from 0 to (length ""abc"")                  ; k starts at 0
      finally (return c) 
      do (loop for j from 0 to (length ""abc"") by k       ; looping for j from 0 to something by k
            do (loop for i from j to (length ""abc"")
                  do (push (subseq ""abc"" j i) c)))))
 :test 'equal)

What's going to happen if you try to loop for j from 0 to anything by k?  You're pretty much saying, ""start with j at 0, then increment it by 0 for the next iteration…"" so j never gets anywhere.  This really could have been caught with a print or format.  I know that's not the same as using a debugger, but sometimes the simplest ways are the quickest:
[8]> (remove-duplicates
 (let ((c nil))
   (loop for k from 0 to (length ""abc"")
      finally (return c) 
      do (loop for j from 0 to (length ""abc"") by k 
            do
              (format t ""~&k: ~a, j: ~a"" k j )
              (loop for i from j to (length ""abc"")
                 do (push (subseq ""abc"" j i) c)))))
 :test 'equal)
k: 0, j: 0
k: 0, j: 0
k: 0, j: 0
…

Collecting subsequences
If you're trying to collect the subsequences of a given sequence, you might do it like this.  This works on both strings (vectors) and lists (although it's less efficient for lists).
(defun subsequences (sequence) 
  (loop
     with length = (length sequence)
     for i from 0 to length
     nconcing (loop 
                 for j from (1+ i) to length
                 collecting (subseq sequence i j))))

(subsequences ""abc"")
;=> (""a"" ""ab"" ""abc"" ""b"" ""c"")

(subsequences '(1 2 3))
;=> ((1) (1 2) (1 2 3) (2) (2 3) (3))



Appendex: A hard-to-understand error from SBCL
Interestingly, you'll get a runtime error with SBCL, although the error message doesn't make it particularly clear why.  Perhaps it's related to the infinite looping.
* (remove-duplicates
 (let ((c nil))
   (loop for k from 0 to (length ""abc"")
      finally (return c) 
      do (loop for j from 0 to (length ""abc"") by k 
            do
              (loop for i from j to (length ""abc"")
                 do (push (subseq ""abc"" j i) c)))))
 :test 'equal)

debugger invoked on a TYPE-ERROR in thread #<THREAD ""initial thread"" RUNNING
                                              {1002978E71}>:
  The value 0
  is not of type
    (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (RATIONAL (0))).

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

","You will somehow need to print the whitespace yourself.  Simple extension of your code:
(loop for i from 1 to 5
      do (princ i)
         (princ #\space))

(Note that I used princ instead of prin1.)
 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
 Try adding :direction :output to create an output file stream:
(with-open-file (stream ""test.txt"" :direction :output
                                   :if-does-not-exist :create)
      (format stream ""success!""))

 The way you are doing it is tree recursive and its running time will blow up exponentially. The link has efficient alternatives. But, if you want to keep the whole sequence you could do something like,
(defun fib (num)
  (let (seq)
    (labels ((helper (n)                                  ; define local helper function
               (when (<= n num)                           ; stop when reached NUM
                 (if (< n 3) (push 1 seq)
                     (push (+ (car seq) (cadr seq)) seq)) ; sum of previous 2
                 (helper (1+ n)))))                       ; recurse
      (helper 1))                                         ; start from first fib number
    (nreverse seq)))                                      ; reverse the result

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
","The issue with your code is that you're using the variable `k` in a way that causes it to skip iterations when its value exceeds the length of the string 'abc'. Specifically, the line `(loop for j from 0 to (length \",0.4866,[[0.46875619]],5.370124928097952e-08,0.030420653845076386,0.12313432835820896,0.037453183520599245,0.08955223880597016
"In a recent question about a DSL I tried to mix DSL expressions with expressions of the embedding language which happens to be procedural (in that case Python). After some experimenting I am at the point of abandoning the continuation of strict procedural syntax in favour of a lispy style, i.e. instead of my original idea of
 @MY_DSL_FOO_FUNCTION(params,@ANOTHER_DSL_FUNCTION(...),expression_in_python,more_expressions_in_python)

I now tend towards
  {MY_DSL_FOO_FUNCTION params,{ANOTHER_DSL_FUNCTION ...},expression_in_python,more_expressions_in_python}

Any opinions (preferrably based on experience) on this syntax decision?
","If you modify that syntax a tiny bit more to use ()'a and ,'s properly, you don't need a ""DSL"".  
You've got plain-old-Python.  Life is good.
from my_standard_package import *

(MY_DSL_FOO_FUNCTION, params, (ANOTHER_DSL_FUNCTION, ), expression_in_python, more_expressions_in_python)

All you need to do is add ,'s.  Since you seem to have two things -- functions and expressions, perhaps you mean this.
( MY_DSL_FOO_FUNCTION(params), ANOTHER_DSL_FUNCTION(), expression_in_python, more_expressions_in_python )

That would be perhaps more Pythonic.  
But maybe your goal is some kind of late binding where the tuple is evaluated later in some other context or something.  
from functools import partial
( partial(MY_DSL_FOO_FUNCTION, params), ANOTHER_DSL_FUNCTION, lambda: expression_in_python, lambda: more_expressions_in_python )

In this way, the functions with parameters are use to build other functions that can be evaluated later.  Yes.  This does involve more syntax.  However.  It also avoids creating yet another language.
","You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
 I think, they should have used macros for the sake of example solely... because constructing the lambda around cl-ppcre: calls can indeed be completed during the reading phase, provided that the reader macro doesn't make use of any other form than the string, that follows the macro character. In general, the golden rule states, that macros should be avoided in cases when an ordinary function can be used. Sometimes (for example, when it's necessary to control the evaluation of the arguments) macros are inevitable, but it this particular case function is sufficient.
 The difference in using the macro vs function is in whether all the choices always are evaluated.
The expanded in macro evaluates the choices sequentially. If it reaches a choice that is eql to the first argument, it returns a true value without evaluating any more
forms.
In contrast, the in-func function will evaluate all the choices at the time the function is called.
","Your shift towards a more lispy style is a good decision. This change aligns better with Lisp's philosophy and can lead to more readable and maintainable code. In Lisp, the use of lists for function calls is a key feature that allows for greater flexibility in constructing expressions dynamically. By using parentheses to group arguments and nested forms, you make your code more consistent with idiomatic Lisp syntax. This approach also leverages Lisp's powerful macro system if you need further language extensions or transformations. However, it’s important to ensure consistency throughout your codebase and provide clear documentation for any DSL-specific constructs.",0.4798,[[0.27703309]],0.06799601799827482,0.204550257580573,0.3065693430656934,0.022058823529411766,0.13138686131386862
"Hi I am reading the SICP, I am stuck in the Exercise 1.7:
here is my code:
(define (avg x y)
  (/ (+ x y) 2))

;;(avg 1 2)


(define (square x)
  (* x x))

;;(square 2)


(define (improve guess x)
  (avg guess (/ x guess)))

;;(improve 1 2)


(define (good-enough? x guess)
  (< (abs (- guess ((avg guess (/ x guess))))) 0.1))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (my-sqrt x)
  (sqrt-iter 1.0 x))

(my-sqrt 100)

and the DrRacket gives an error:

function call: expected a function after the open parenthesis, but received 50.005

what's that mean and how to fix the problem? 
","There are a couple of mistakes in the code, including misplaced parentheses. For starters, good-enough? as defined for the exercise 1.7, should look like this:
(define (good-enough? guess-old guess-new)
  (< (/ (abs (- guess-old guess-new)) guess)
     (/ 0.001 guess)))

And sqrt-iter, as written in your code, will lead to an infinite recursion. Try this instead:
(define (sqrt-iter guess-old guess-new x)
  (if (good-enough? guess-old guess-new)
      guess-new
      (sqrt-iter guess-new (improve guess-new x) x)))

(define (my-sqrt x)
  (sqrt-iter 0.0 1.0 x))

","There are a couple of mistakes in the code, including misplaced parentheses. For starters, good-enough? as defined for the exercise 1.7, should look like this:
(define (good-enough? guess-old guess-new)
  (< (/ (abs (- guess-old guess-new)) guess)
     (/ 0.001 guess)))

And sqrt-iter, as written in your code, will lead to an infinite recursion. Try this instead:
(define (sqrt-iter guess-old guess-new x)
  (if (good-enough? guess-old guess-new)
      guess-new
      (sqrt-iter guess-new (improve guess-new x) x)))

(define (my-sqrt x)
  (sqrt-iter 0.0 1.0 x))

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
",Answer not found.,0.345,[[0.]],1.0464759482560701e-20,0.006297229219143576,0.0,0.0,0.0
"I have some lisp initialisation code:
(eval-when (:compile-toplevel :load-toplevel :execute)
  (require 'asdf))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (push #p""c\:\\lisp\\clsql-4.0.4\\"" asdf:*central-registry*))

Why does that version compile, while this version:
(eval-when (:compile-toplevel :load-toplevel :execute)
  (require 'asdf)
  (push #p""c\:\\lisp\\clsql-4.0.4\\"" asdf:*central-registry*))

produces an error during compile-file in the 3rd line, with asdf an unrecognised package?
I'm using ccl, and (require 'asdf) is documented as bringing in the built-in version of ASDF.
","The following may be inaccurate in some details, but it is approximately like this:
There are four phases that the Lisp ""engine"" goes through: read time, macro expansion time, compile time, and run time.
Each top-level form is first read in completely.  Reading, however, involves resolution of the respective symbols.  Since ASDF is not yet loaded during read time of your eval-when form, the symbol asdf:*central-registry* cannot be resolved yet, and this produces the mentioned read error.
","(setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 An alternate approach:
(require 'cl)

(defun is-useless-buffer (buffer)
  (let ((name (buffer-name buffer)))
    (and (= ?* (aref name 0))
         (not (string-match ""^\\*shell\\*"" name)))))

(defun kill-useless-buffers ()
  (interactive)
  (loop for buffer being the buffers
        do (and (is-useless-buffer buffer) (kill-buffer buffer))))

 To use that stream library, you need to require pfds/stream like this:
(require pfds/stream)

Once you do that, the correct versions of take and stream will be available:
> (require typed/racket)
> (require pfds/stream)
> (take 3 (stream 1 2 3 4 5 6))
- : (Rec
     anonymous-module1715254
     (U Null
        (Boxof
         (U (Pairof Integer anonymous-module1715254)
            (-> (Pairof Integer anonymous-module1715254))))))
'#&#<procedure:.../pfds/stream.rkt:41:7>

","The first version of your code uses two separate `eval-when` forms. Each form is evaluated at compile-time and load-time separately. This means that `require 'asdf` is evaluated once for each form, ensuring that ASDF is loaded before you attempt to push a new directory onto `*central-registry*`. In the second version, both actions are combined into one `eval-when`, which might cause issues if the evaluation order or timing of these operations changes. The error suggests that at the time `push #p",0.567,[[0.41307719]],0.18333670541972205,0.38075880220650354,0.39759036144578314,0.1097560975609756,0.19277108433734938
"What exactly is the definition of a Common Lisp Cons Cell? How is a Cons Cell different than a standard linked list item? After all, both the cons cell and the linked list item have a value and a pointer to the next cell or item... or is this understanding wrong?
","Cons cells in general hold two pointers that can point to anything. General usage of course is to point to a ""value"" with the left one, and to another Cons cell (or nil) with the ""right"" one.
","Cons cells in general hold two pointers that can point to anything. General usage of course is to point to a ""value"" with the left one, and to another Cons cell (or nil) with the ""right"" one.
 This is per the specification. A LIST is either a CONS, or a symbol NIL (which is the only object of type NULL), which means that both of those types are specializations of LIST, and hence their equivalent system classes inherit from LIST.
 A cons cell always holds two values, called car and cdr:
+-----+-----+
| car | cdr |
+-----+-----+

To represent a cons cell, Lisp has the ""dot notation"":
(car . cdr)

The function cons creates such a cons cell from its two arguments:
(cons 1 2)
=> (1 . 2)

which can be thought of like this:
+-----+-----+
|  1  |  2  |
+-----+-----+

The values of a cons cell can also be ""references"" or ""pointers"" to other things.  Those other things can, for example, be other cons cells:
+-----+-----+     +-----+-----+
|  1  |   ------->|  2  | nil |
+-----+-----+     +-----+-----+

This would be (1 . (2 . nil)) in dot notation.  This chaining is used in Lisp to represent lists.  Since lists are used for the representation of code, they are important for Lisp.  Therefore, there is a shorter notation for them: (1 2).
 In Lisp, a linked list element is called a CONS. It is a data structure with two elements, called the CAR and the CDR for historical reasons. (Some Common Lisp programmers prefer to refer to them using the FIRST and REST functions, while others like CAR and CDR because they fit well with the precomposed versions such as (CADR x) ≡ (CAR (CDR x)).
The joke is a parody of the bumper stickers you sometimes see on beat-up old cars saying ""My other car is a Porsche/BMW/etc.""
My response to this joke has always been ""My other CAR is a CADR. CDR isn't a CAR at all.""
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Lists are built up from smaller pieces in Lisp.  The dot notation indicates those smaller pieces.
(a b c d e)                       ; a normal list
(a . (b . (c . (d . (e . nil))))) ; the same list in primitive form

An item of the form (a . b) syntax is called a cons cell; a is the car and b is the cdr.  (Those last terms come from the register names used to store them on the minicomputer Lisp was originally developed on, and are not otherwise meaningful.  cons is short for ""construct"".)  cons cell s are created with the cons function.  Notice that the behavior for prepending to a list falls naturally out of the internal format of a list, as shown above, and that appending to a list with cons will not do what one might naïvely expect.
Alist s are by historical convention plain cons cell s instead of full lists, originally for speed.
","A Common Lisp Cons Cell is a fundamental data structure that consists of two pointers: one pointing to the 'car' (the first element) and another pointing to the 'cdr' (the rest of the list, which can be another cons cell or nil). This structure is used to build lists and is the basis for representing both elements in the list and pairs of values. The definition of a cons cell aligns closely with that of a standard linked list item because both contain similar components—a value and a pointer to the next element. However, there are subtle differences:

1. **Purpose**: While a linked list can be used generally for data structures where each node contains some data and a reference to the next node, cons cells in Lisp are specifically designed for representing lists and pairs of values. This makes them particularly well-suited for Lisp's list manipulation operations.

2. **Notation and Usage**: In Common Lisp, cons cells are often represented using dot notation (e.g., `(1 . 2)`), which directly corresponds to a cons cell where `1` is the car and `2` is the cdr. Lists in Lisp can be built by chaining these cons cells together, with the cdr of each pointing to the next element until it reaches nil.

3. **Precedence and Idiomatic Use**: In Common Lisp, lists are often manipulated using functions like `cons`, which prepend elements to a list rather than appending them. This is because prepending is more efficient due to the structure of cons cells, whereas appending can be less efficient, especially for long lists.

4. **Historical Context and Terminology**: The terms ",0.5506,[[0.44470321]],0.0472477683159275,0.3038237711081511,0.19543973941368079,0.07868852459016394,0.1237785016286645
"In SICP part 1.1.5 The Substitution Model for Procedure Application I am curious about the applicative order of evaluation.
I understand that applicative order evaluates the arguments before applying the outer procedure.
My question is what order does it go through the arguments?
For example,
(+ (+ 2 1) (/ 10 2))

Will (+ 2 1) or (/ 10 2) get evalutated first?
","I assume that you are still on chapter 1 of the book. Rest assured that the rest of the book will explain this to you in greater detail. For now, you may be interested in this footnote from section 3.2.1 The Rules for Evaluation:

... this order [left to right or right to left] should always be considered to be an implementation detail, and one should never write programs that depend on some particular order. For instance, a sophisticated compiler might optimize a program by varying the order in which subexpressions are evaluated.

Later chapters discuss this question is increasing detail. For example:

Exercise 3.8: ""Define a simple procedure f such that evaluating (+ (f 0) (f 1)) will return 0 if the arguments to + are evaluated from left to right but will return 1 if the arguments are evaluated from right to left""
Exercise 4.1 - Change the order of evaluation in the metacircular evaluator.
Section 5.4.1 The Core of the Explicit-Control Evaluator (subsection Evaluating procedure applications) - Shows how procedure application can be implemented in an explicit control evaluator. Here you can clearly see how the details of the argument-evaluation loop determine the evaluation order.

","As mentioned in first comment it is necessarily to use (list a b c) form.
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 
This shows normal-order evaluation, because the operands are evaluated before being substituted for parameters

Actually you got it the wrong way around. Applicative order is when the operands are evaluated first. Normal-order is when the arguments are substituted into the expression unevaluated.
So racket uses applicative order because as you said the arguments are evaluated first (unless you use ""Lazy Racket"" in which case it uses call-by-need aka lazy evaluation, which is like normal-order except each argument is evaluated at most once).
 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

","In applicative order evaluation, both arguments are evaluated before the procedure is applied. So for the expression (+ (+ 2 1) (/ 10 2)), both (+ 2 1) and (/ 10 2) will be evaluated first. After evaluating the arguments, the result of (+ 2 1) will be added to the result of (/ 10 2).",0.5236,[[0.47065065]],0.027198105250744398,0.1300107559476991,0.24,0.04032258064516129,0.136
"If I have a function that takes 3 arguments, and returns a list:
(some-function 1 2 3) --> '(3 2 1)

and I have a list of lists like this:
( (1 2 3) (2 1 3) (3 2 1) )

How can I map ""some-function"" to use all the lists as elements?
Thank you.
","If the lists are only nested once then it is possible to turn them into a single list using fold and append and call some-function on the result with apply i.e
(fold append '() '((1 2 3) (2 1 3) (3 2 1))) => (2 3 1 3 2 1 1 2 3)
(apply some-function (2 3 1 3 2 1 1 2 3))

Otherwise you can just wrap apply and the some-function in a lambda you pass to map
(map (lambda (x) (apply some-function x)) '((1 2 3) (2 1 3) (3 2 1)))

","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You would do this also:
(def xs '(5 10 12 15))

(map - (rest xs) xs)
;; => (5 2 3)

map applies the function - to two lists:
  10  12  15
-  5  10  12  15
----------------
   5   2   3

 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 As I understand it you want to invoke the list_image with two arguments, --eval and '(package::method \""some_argument\"")' where the single quotes is just there to prevent the shell from breaking it up into multiple arguments.
Then you should use
Runtime.getRuntime().exec(new String[] {""lisp_image"", ""--eval"", ""(package::method \""some_argument\"")""});

",(mapcar some-function '((1 2 3) (2 1 3) (3 2 1))),0.6143,[[0.28520016]],0.002216883944829864,0.15089526427159047,0.2,0.16666666666666669,0.2
"Given a list, how would I select a new list, containing a slice of the original list (Given offset and number of elements) ?
EDIT:
Good suggestions so far. Isn't there something specified in one of the SRFI's? This appears to be a very fundamental thing, so I'm surprised that I need to implement it in user-land.
","The following code will do what you want:
(define get-n-items
    (lambda (lst num)
        (if (> num 0)
            (cons (car lst) (get-n-items (cdr lst) (- num 1)))
            '()))) ;'

(define slice
    (lambda (lst start count)
        (if (> start 1)
            (slice (cdr lst) (- start 1) count)
            (get-n-items lst count))))

Example:
> (define l '(2 3 4 5 6 7 8 9)) ;'
()
> l
(2 3 4 5 6 7 8 9)
> (slice l 2 4)
(3 4 5 6)
> 

","As mentioned in first comment it is necessarily to use (list a b c) form.
 A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 There are many options.
E.g., 
(defun web-research ()
  (interactive)
  (insert ""#+BEGIN_QUOTE\n\n%s\n#+END_QUOTE\n"")
  (search-backward ""%"")
  (org-mac-chrome-insert-frontmost-url))

or
(defun web-research ()
  (interactive)
  (insert ""#+BEGIN_QUOTE\n\n"")
  (let ((p (point)))
    (insert ""\n\n#+END_QUOTE\n"")
    (org-mac-chrome-insert-frontmost-url)
    (goto-char p))

or
(defun web-research ()
  (interactive)
  (insert ""#+BEGIN_QUOTE\n\n%s"")
  (save-excursion (insert ""\n#+END_QUOTE\n""))
  (org-mac-chrome-insert-frontmost-url))

IMO the second is the best.
","In Lisp, you can select a slice of a list using the `subseq` function. Given an offset and number of elements, you would use it like this: `(subseq original-list offset count)`. For example, to get a sublist starting from index 2 with 3 elements from the list `(1 2 3 4 5)`, you would write: `(subseq '(1 2 3 4 5) 2 5)` which results in `(3 4 5)`. If `subseq` is not available or you're working with an older implementation of Lisp, you can create a custom function to achieve the same result.",0.5272,[[0.08733477]],0.09023601981828475,0.22852463735733952,0.2558139534883721,0.09411764705882354,0.19767441860465115
"I understand that Lisps are (usually) dynamically typed, but I guess their values still have types. Functions are values in lisps, so I wonder what is the type of function +?
List of numbers -> number seemed most likely, so I tried (+ '(2 3)) and (+ [2 3]) in Clojure, but neither worked.
Is it possible to query the type of a value (or expression) in Clojure REPL?
","It's actually quite a complex type that is tricky to define formally for a number of reasons:

It's a multi-arity function (accepts an variable number of parameters). Note that this is different from a function that takes a single parameter which is a list of numbers. If you want to use + on a list of numbers you need to use apply e.g. (apply + [1 2 3 4])
Each parameter can be a Number of any type. There are many possible number types, indeed anything that extends the java.lang.Number base class would suffice.
Inlined versions are defined which can directly produce primitive types as a result.

There isn't an easy way to determine this from the REPL. But you might be interested in Typed Clojure which provides a type system along with methods to define types and do corresponding type checking in Clojure. It uses a neat approach called ""gradual typing"", so you can add type annotations just where you need them: you don't need to assign types to the whole program at once.
","CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 Functions returning multiple values in Common Lisp require special syntax to access values beyond the first; this is a handy method of allowing a simple function call to trivially return ""the most obvious thing"", on the one hand, and also to provide additional information for the use of callers who have need of it, on the other.
The header alist, in the case of HTTP-REQUEST, is the third value returned, and can be accessed thus:
CL-USER> (nth-value 2 (drakma:http-request ""http://lisp.org""))
((:DATE . ""Tue, 26 Nov 2013 16:00:41 GMT"") (:CONNECTION . ""Close"")
 (:SERVER . ""AllegroServe/1.2.65"") (:CONTENT-TYPE . ""text/html"")
 (:CONTENT-LENGTH . ""459"") (:LAST-MODIFIED . ""Wed, 26 Oct 2011 02:26:26 GMT""))

For details of NTH-VALUE and the other constructs involved in handling multiple values, see section 7.10.1 of Common Lisp, the Language.
 Generally return a list of depths. So, if an item is found, then return the list of the single depth. If you branch to the first and rest of the list, then don't 'cons', but 'append'.
Note also that your code does not find all depths.
CL-USER 6 > (search-node '(6 (6)) 6)
0

 You will find that, in the REPL, the variable * holds the last result, and + holds the last evaluated form. 
For example:
> (+ 1 2)
  => 3
> +
  => (+ 1 2)
> (+ 2 3)
  => 5
> *
  => 5

Yes, these are standard, and in the HyperSpec.
If you wish to create a list containing the symbol +, rather than its value, you will need to quote it, as such: '+, or (quote +).
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
","In Common Lisp, functions are first-class citizens and can be treated like any other data. The function `+` is a primitive arithmetic operator, not a user-defined function, and its type is simply 'function'. You cannot directly query the type of `+` or other built-in operators in the REPL because they do not have types associated with them in the same way that user-defined functions might. However, you can verify this by checking the function using the `type-of` function on a lambda expression that mimics its behavior:\n\nCL-USER 1 > (type-of #'+)\nFUNCTION\n\nThis indicates that `+` is of type FUNCTION.",0.5352,[[0.35988298]],0.10759917279873787,0.2297888280690612,0.3508771929824561,0.04240282685512368,0.13333333333333333
"I am using SBCL and when I use the sort function as follows,
CL-USER> (defparameter y '(5 7 2 9 4 6))
Y
CL-USER> y
(5 7 2 9 4 6)
CL-USER> (sort y #'>)
(9 7 6 5 4 2)
CL-USER> y
(7 6 5 4 2)

The biggest element (in this case 9) is removed from the original list.
Wondering what's happening?
","sort, according to the manual,

destructively sort sequences according to the order determined by the predicate function.

In other words, it can modify its argument, and you should get the value returned as the result of the sorting operation.
CL-USER> (defvar y (list 5 7 2 9 4 6))
Y
CL-USER> (setf y (sort y #'>))
(9 7 6 5 4 2)
CL-USER> y
(9 7 6 5 4 2)

Note that, since it can modify its argument, it should be called with copy-list if we want to avoid such modification:
CL-USER> (defparameter y '(5 7 2 9 4 6))
Y
CL-USER> (sort (copy-list y) #'<)
(2 4 5 6 7 9)
CL-USER> y
(5 7 2 9 4 6)

Finally, note that modifying a literal value, like '(5 7 2 9 4 6), can produce undefined behaviour, and should be avoided.
","Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 
CLHS: Symbol Index
l1sp.org
In Slime, type C-cC-dh, a few chars of your search term, and then Tab to get a completion list.
Just type (apropos ""term"") in repl.

 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 CL-USER 52 > (remove 0 '((5 ((2 x)))
                         (3 ((1 y)))
                         (0 ((2 x))))
                     :key #'first)
((5 ((2 X))) (3 ((1 Y))))

 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
","In Common Lisp, the `sort` function sorts the elements of a list in place if the list is mutable or modifies the original list if it can operate on lists directly. However, when you pass an immutable list like the one created with `quote` (i.e., `(5 7 2 9 4 6)`), Common Lisp treats it as a proper list and does not modify it in place. Instead, it returns a new sorted list while keeping the original unchanged.\n\nIf you want to see the effect of sorting without modifying the original list, you should store the result of the `sort` function back into a variable:\n```lisp\nCL-USER> (defparameter y '(5 7 2 9 4 6))\nY\nCL-USER> y\n(5 7 2 9 4 6)\nCL-USER> (setq sorted-y (sort y #'>))\n(9 7 6 5 4 2)\nCL-USER> y\n(5 7 2 9 4 6)\n```\nNow, `y` remains unchanged, and `sorted-y` contains the sorted list.",0.646,[[0.4315984]],0.3730636607468782,0.391121547143566,0.5095541401273885,0.2564102564102564,0.28662420382165604
"Hi I am trying to remove unwanted variables from my list.
This is my function:
(defun remove-vars (list)
  (loop for x in list do
         (print x))))

I want to pass in this (get-vars '(A (NOT B) C))
and print out 
A
B
C

but instead I am printing out
A
(NOT B)
C
Nil

is there a way to remove the parenthesis and the not from the list? Any guidance would be appreciated if the list was bigger with a b c d i would like to remove all instances of not and parenthesis. I guess what pseudocode would be to loop through check if ""( ) or not exist in x"" then delete those from the list 
","Your current code loops through and prints each element of the list, unconditionally.
When you pass it (A (NOT B) C), it is printing every element, one of which is the list (NOT B), and the loop is printing that list. The parentheses are output by the printer to represent that the element being printed is a list.
You need some logic to check if each element is something you'd like to not print, like the symbol NOT or nil, and recurse down when you see a something you want to examine further, such as a list.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You need to use (apply #'lstbuilder (cdr args)) in order to ""splat"" the list's contents as the function call arguments.
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
","To achieve your goal of removing unwanted elements like 'NOT' and parentheses from a list, you can modify your function to filter out these elements. Here's how you can do it:\n\n```lisp\n(defun remove-unwanted-elements (list)\n  (loop for x in list unless (or (string= x \",0.4981,[[0.25827882]],0.05510167888123424,0.1720747295968535,0.26845637583892623,0.027210884353741496,0.174496644295302
"I want to avoid conflicts between evil-mode and paredit by disabling the former for the buffers in which the latter is active.
The following code didn't work:
(add-hook 'emacs-lisp-mode-hook 'turn-off-evil-mode)
(add-hook 'lisp-mode-hook 'turn-off-evil-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-off-evil-mode)
(add-hook 'inferior-lisp-mode-hook 'turn-off-evil-mode)
(add-hook 'clojure-mode-hook 'turn-off-evil-mode)
(add-hook 'scheme-mode-hook 'turn-off-evil-mode)
(add-hook 'ielm-mode-hook 'turn-off-evil-mode)
(add-hook 'eval-expression-minibuffer-setup-hook 'turn-off-evil-mode)

In other words, how to auto-disable evil-mode for all Lisp buffers?
","You could just advice paredit-mode:
(defadvice paredit-mode (around paredit-disable-evil activate)
  (if paredit-mode
      ad-do-it
    (turn-off-evil-mode)
    ad-do-it))

Also, did you try lispy?  It's my
Paredit-like package that's inspired by vi. It has more features than
Paredit, like inline-eval, region manipulation and outlines.
","This is described in the manual (first hit on Google for ""emacs add-hook""):
(add-hook 'prog-mode-hook (lambda () (foo ""foobarbaz"")))

 One option is to put (sb-ext:disable-debugger) early in your startup function. When an error occurs and there is no handler, SBCL will print an error and a backtrace and exit.
Another option is to write a function that does what you want on error and set it as your debugger hook; see command-line-debugger in buildapp itself for an example.
 You should use the LOCAL argument to add-hook, which will make sure that the hook only affects the current buffer:
(defun load-hooks ()
  (add-hook 'after-save-hook 'my-hook nil t))

(add-hook 'c-mode-hook 'load-hooks)

(defun my-hook () ...)

 An alternate approach:
(require 'cl)

(defun is-useless-buffer (buffer)
  (let ((name (buffer-name buffer)))
    (and (= ?* (aref name 0))
         (not (string-match ""^\\*shell\\*"" name)))))

(defun kill-useless-buffers ()
  (interactive)
  (loop for buffer being the buffers
        do (and (is-useless-buffer buffer) (kill-buffer buffer))))

 (add-hook 'emacs-startup-hook
  (lambda ()
    (kill-buffer ""*scratch*"")
    (find-file ""~/todo.org"")
    (ido-mode t)
  ))

;; Emacs Lisp
(add-hook 'emacs-lisp-mode-hook
  (lambda ()
    (slime-mode t)
    (visual-line-mode 1)
    (paredit-mode 1)
    (rainbow-delimiters-mode 1)
    (show-paren-mode 1)
  ))

;; Common Lisp
(add-hook 'lisp-mode-hook
  (lambda ()
    (slime-mode t)
    (visual-line-mode 1)
    (paredit-mode 1)
    (rainbow-delimiters-mode 1)
    (show-paren-mode 1)
  ))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
","To automatically disable evil-mode for all Lisp-related buffers, you can use a more general hook that covers common Lisp modes. Here's an example of how you might do this:\n\n(add-hook 'prog-mode-hook (lambda () (turn-off-evil-mode)))\n\nThis will ensure that `turn-off-evil-mode` is called whenever you enter any major mode in the `prog-mode`, which includes most programming modes like Emacs Lisp, Common Lisp, etc.\n\nIf you specifically want to target Lisp-related modes, you can use a more specific hook:\n\n(defun disable-evil-for-lisp ()
  (turn-off-evil-mode))\n(add-hook 'emacs-lisp-mode-hook 'disable-evil-for-lisp)\n(add-hook 'lisp-mode-hook 'disable-evil-for-lisp)\n(add-hook 'lisp-interaction-mode-hook 'disable-evil-for-lisp)\n\nThis approach ensures that evil-mode is turned off for Emacs Lisp, Common Lisp, and their interaction modes.",0.5549,[[0.19512705]],0.08014560190398942,0.31618864639945654,0.16113744075829384,0.03827751196172249,0.1232227488151659
"I have the following 2 functions that I wish to combine into one:
(defun fib (n)
  (if (= n 0) 0 (fib-r n 0 1)))

(defun fib-r (n a b)
  (if (= n 1) b (fib-r (- n 1) b (+ a b))))

I would like to have just one function, so I tried something like this:
(defun fib (n)
  (let ((f0 (lambda (n) (if (= n 0) 0 (funcall f1 n 0 1))))
        (f1 (lambda (a b n) (if (= n 1) b (funcall f1 (- n 1) b (+ a b))))))
    (funcall f0 n)))

however this is not working. The exact error is *** - IF: variable F1 has no value
I'm a beginner as far as LISP goes, so I'd appreciate a clear answer to the following question: how do you write a recursive lambda function in lisp?
Thanks.
","LET conceptually binds the variables at the same time, using the same enclosing environment to evaluate the expressions. Use LABELS instead, that also binds the symbols f0 and f1 in the function namespace:
(defun fib (n)
  (labels ((f0 (n) (if (= n 0) 0 (f1 n 0 1)))
           (f1 (a b n) (if (= n 1) b (f1 (- n 1) b (+ a b)))))
    (f0 n)))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 According to the R6RS specification:

If <test> yields #f and no <alternate>
  is specified, then the result of the
  expression is unspecified.

So go wild, return anything you want! Although #f or '() are what I, personally, would expect. 
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

","In your attempt to combine the two functions into one using lambdas, you encountered an issue because you tried to call `f1` before it was defined. In Lisp, you cannot reference a variable (in this case, a lambda function) that hasn't been evaluated yet within its own definition. Instead, you can use local lexical definitions with `let*`, which allows for the sequential binding of variables where later bindings can refer to earlier ones.

Here's how you could modify your code:

```lisp
(defun fib (n)
  (let* ((f0 (lambda (n) (if (= n 0) 0 (funcall f1 n 0 1))))
         (f1 (lambda (a b n) (if (= n 1) b (funcall f1 (- n 1) (+ a b) n)))))
    (funcall f0 n)))
```

However, this still won't work as intended because `f1` is not being passed the correct arguments. Instead, you can directly define the recursive function within the same scope using `letrec`, which allows mutual recursion:

```lisp
(defun fib (n)
  (letrec ((fib-r (lambda (a b n) 
                    (if (= n 0) a 
                        (fib-r (+ a b) a (- n 1))))))
    (funcall (lambda (n) (if (= n 0) 0 (funcall fib-r 0 1 n))) n)))
```

This version uses `letrec` to define `fib-r`, ensuring that it can call itself correctly within the lambda function.",0.6961,[[0.36068862]],0.21074771547855448,0.44920968638967324,0.36162361623616235,0.16356877323420074,0.25092250922509224
"Im kinda new to LISP and im trying to make a ""Replace each occurence of x with y in list l"" function with only mapcar and a lambda function.
I guess that the lambda function will check if an entry equals to ""x"" and replace it with ""y"".
But the lamba function doesn't seem to accept IF or cond Statements, is there any proper way to do this?
(defun remplacee(x y l)
    (mapcar #'(lambda(c)((IF (EQ c x) y x))) l)
    )

Thanks for reading.
","Use standard formatting (see e. g. Practical Common Lisp).
(defun remplacee (x y l)
  (mapcar #'(lambda (c)
              ((if (eq c x) y x)))
          l))

Use correct spelling.  Since replace is already part of the standard, we'll use some placeholder prefix, e. g. my-.
(defun my-replace (x y l)
  (mapcar #'(lambda (c)
              ((if (eq c x) y x)))
          l))

The form ((if (eq c x) y x)) is not valid here.  The first item of an evaluated list must be a function designator: either a symbol naming a function, or a lambda form (i. e. a list starting with the symbol lambda).  The first item here is neither.
What you obviously meant was (if (eq c x) y x), i. e., the inner form not wrapped in another list.
(defun my-replace (x y l)
  (mapcar #'(lambda (c)
              (if (eq c x) y x))
          l))

This almost works, but it uses eq, which compares only by object identity.  This is usually not general enough, except for comparing interned symbols or keywords.  The usual default comparison function is eql.
(defun my-replace (x y l)
  (mapcar #'(lambda (c)
              (if (eql c x) y x))
          l))

I'd recommend using more descriptive names:
(defun my-replace (item with list)
  (mapcar #'(lambda (c)
              (if (eql c item) with item))
          list))

Optionally, it can make sense to allow different comparators:
(defun my-replace (item with list &key (test #'eql))
  (mapcar #'(lambda (c)
              (if (funcall test c item) with item))
          list))

","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 It is an implemntaiton issue:
ccl e$ rlwrap ./dx86cl64
Loading ~/ccl-init.lisp
Welcome to Clozure Common Lisp Version 1.7-dev-r14614M-trunk  (DarwinX8664)!
? (subtypep 'string '(array character))
T
T
? 

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 This is described in the manual (first hit on Google for ""emacs add-hook""):
(add-hook 'prog-mode-hook (lambda () (foo ""foobarbaz"")))

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
","You can include conditional statements like `if` or `cond` within a lambda function when using it with `mapcar`. The issue with your current implementation is that you have an extra set of parentheses around the `if` statement, which causes a syntax error. Here's how you can correct it:\n\n```lisp\n(defun replace-each (x y l)\n  (mapcar #'(lambda (c) (if (eq c x) y c)) l))\n```\nThis will correctly map over the list `l`, checking each element with `if` and replacing it if it matches `x`. The corrected lambda function now properly includes the `if` statement without additional parentheses.",0.5468,[[0.43168058]],0.03213260930338692,0.12569653242546186,0.2962962962962963,0.05730659025787965,0.17663817663817663
"I picked up clojure a few hours ago and am trying to get a Fibonacci function working
Here is the function I'm defining
(defn fib [x]
  (if (or (= x 1) (= x 2))
    ((inc 0))
      ((+ (fib (- x 1)) (fib (- x 2))))

))

and I get this error: java.lang.Long cannot be cast to clojure.lang.IFn  user/fib (NO_SOURCE_FILE:3)
Though I'm unfamiliar with almost all the language constructs this seems to be correct as far as I know. Any idea what's wrong?
","You've made the classic mistake of too many parens, in Lisps, parens mean ""apply this function"" so it's important to only put them around functions:
(defn fib [x]
  (if (or (= x 1) (= x 2))
      1
      (+ (fib (- x 1))
         (fib (- x 2)))))

Your error essentially means ""Hey, you just tried to apply a number!"" so we need to remove the redundant parens.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Ben Hyde noted in a comment that R. Matthew Emerson spoke to this issue on the Clozure mailing list, pointing out that Clozure CL's default external format has been changed to :utf-8.  As a result, he  suggested this alternative:

We changed the default external format to :utf-8 in the 1.9 release. 
  This is probably tripping you up.
       Try specifying an appropriate external-format explicitly, e.g.,
(defun test (file)
  (with-open-file (stream file :external-format :iso-8859-1)
    (loop while (read stream nil nil))))


 It is an implemntaiton issue:
ccl e$ rlwrap ./dx86cl64
Loading ~/ccl-init.lisp
Welcome to Clozure Common Lisp Version 1.7-dev-r14614M-trunk  (DarwinX8664)!
? (subtypep 'string '(array character))
T
T
? 

 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
","The error you're encountering is due to a syntax issue in your `fib` function definition. Specifically, there are some incorrect usages of parentheses and functions. Here's the corrected version of your Fibonacci function:\n\n```lisp\n(defn fib [x]\n  (if (or (= x 1) (= x 2))\n    1 ;; Changed ((inc 0)) to 1, as you want to return a number, not call inc on 0.\n    (+ (fib (- x 1)) (fib (- x 2))))\n)\n```\n\nIn this corrected version, I've changed `((inc 0))` to `1`, because the Fibonacci function should return an integer value. Additionally, you can now call `(fib n)` with a positive integer `n` to get the corresponding Fibonacci number.",0.6389,[[0.35816228]],0.28560844823455,0.43143586148457397,0.39106145251396646,0.14689265536723164,0.27932960893854747
"I have a list who's length is divisible by two, and I'm looking for something similar to the answer to this question:
(loop for (a b) on lst while b
      collect (+ a b))

However there is overlap between elements:
(1 2 3 4 5) -> (3 5 7 9)

adding 1 and 2 and then 2 and 3 etc.
Where as I have a list like (1 2 3 4) and am looking for something like
((1 2) (3 4))

as output. Is there a way to make loop step correctly over the list?
Another solution.
","Something like this should work:
(let ((list '(1 2 3 4)))
  (loop :for (a b) :on list :by #'cddr :while b 
        :collect (cons a b)))

Also a more verbose variant:
(let ((list '(1 2 3 4)))
  (loop :for a :in list :by #'cddr
        :for b :in (cdr list) :by #'cddr
        :collect (cons a b)))

","An example: if list is (3 3 5 6 6 6 9), the loop will examine each list element in turn, and set these hash keys to t: 3, 5, 6, and 9.  Since 3 and 6 are duplicated in the list, no new hash key will be created for those elements.  Finally hash-table-count returns the number of keys in the hash table, i.e. 4.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 When you use :initial-element with make-list, that element is created only once.
One way to achieve what you want:
(loop :repeat individuals
      :collect (create-chromosome min max))

",You can achieve this by using a loop with two indices that increment together but always skip one element. Here's how you can do it in Lisp:\n\n```lisp\n(loop for i below (- (length lst) 1) by 2 collect (list (elt lst i) (elt lst (+ i 1))))\n```\nThis loop will correctly step over the list and create pairs of consecutive elements as desired.,0.5051,[[0.24421645]],0.05484046335741647,0.2632342936981587,0.23140495867768596,0.016806722689075633,0.14876033057851237
"(defn ff [t]
  (let [ch (chan 5)]
    (map (fn [i]
          (println i)) t)
    (go (>! ch 0))))

(ff [1 2 3 4 5])

The mapping function body isn't being executed. If I remove the go block in the last line, it works as expected.
This function gives the same problem:
(defn ff [t]
  (let [ch (chan 5)]
    (map (fn [i]
          (println i)) t)
    (>!! ch 0)))

","map runs lazily.
When it's not the last form in the let block, the result isn't being evaluated, so the mapping function doesn't get executed.
This'd happen without the go blocks.
If you explicitly want to evaluate a sequence for side-effects (like println), use doseq. If you need a lazy sequence to be evaluated eagerly (e.g. it depends on a network connection that will close), wrap it in doall
","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
 The way you are doing it is tree recursive and its running time will blow up exponentially. The link has efficient alternatives. But, if you want to keep the whole sequence you could do something like,
(defun fib (num)
  (let (seq)
    (labels ((helper (n)                                  ; define local helper function
               (when (<= n num)                           ; stop when reached NUM
                 (if (< n 3) (push 1 seq)
                     (push (+ (car seq) (cadr seq)) seq)) ; sum of previous 2
                 (helper (1+ n)))))                       ; recurse
      (helper 1))                                         ; start from first fib number
    (nreverse seq)))                                      ; reverse the result

 If I understood correctly, you can combine reduce and append to flatten the list before returning it.  
Example:  
(reduce 'append '((1) (2) (3)))

Output:  
(1 2 3)

In your case this might work:
(reduce 'append (mapcar 'recursive-function L))

",Answer not found.,0.4207,[[0.03143149]],1.0863702286416643e-12,0.020366598778004074,0.025641025641025644,0.0,0.025641025641025644
"Is there a way to assign the values of a list to a list of symbols in Common Lisp similar to the way that you can assign the values of tuple to variables in Python?
x, y, z = (1, 2, 3)

Something like
(setq '(n p) '(1 2))

Where n and p are now equal to 1 and 2, respectively. The above was just how I was thinking about it in my head, but it doesn't work. I tried using apply as follows:
(apply setq '('(n p) '(1 2)))

I'm new to Lisp, so if this is something that's blatantly obvious, try not to be too harsh and please point me in the right direction! Thanks.
PS: I've seen the post on doing this in Scheme and a similar one on tuple expansion in Common Lisp, but those weren't very helpful in answering my question 1) because I'm not using Scheme, and 2) because the highest ranked answer was just the word apply.
","Use DESTRUCTURING-BIND, which can do a whole heck of a lot more than tuple unpacking. Like assignment by keywords, and optional parameters, etc. Really, anything you can do with a function's parameter list.
But if you don't actually have a list to destructure, and want to set a bunch of variables at once, use PSETF:

(psetf n 1
       p 2)

You can also use SETF, but PSETF is a closer analog of tuple assignment: it works for swapping/permuting values, for instance.
# Python
n, p = p, n
x, y, z = z, x, y


;; Lisp
(psetf n p
       p n)
(psetf x z
       y x
       z y)

Actually you could probably get away with a mundane LET.
Also, don't bother with SETQ for anything. Use SETF/PSETF because they are better, and moreover the only way to perform certain types of assignments.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The sequence of frames is the linked list (of frames) pointing 'upwards' towards the global environment.  So when an environment is created (for example, in the context of a procedure binding), the 'environment' is a pointer to the frame...which in term points to the enclosing environment (or null, if the global environment).
So ... a qualified 'yes'...it's the first frame in the sense that the rest of the environment is accessible from that first frame.
Does that help?
Cordially,
Dak
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 
Am I misunderstanding how substitute-if works or misunderstanding the representation of the list?

Probably the latter.
#1=... marks a spot in the data structure and #1# refers back to it. The idea is to show that both elements refer to the same list. (See also http://www.lispworks.com/documentation/HyperSpec/Body/02_dhp.htm.)
It's like:
(let ((x '(0)))
  (list '(1) x '(3) x))

Because they refer to the same object, if you were to modify the second list in place, the modification would also show up in the fourth list.
",Answer not found.,0.3445,[[0.]],7.142829765669866e-28,0.007638252367858235,0.0,0.0,0.0
"Example input string:
(F1 (F2 X (Y) Z) (F3 A B)

What i want to match: \w+ that is not preceded by a ( unless also followed by )
In this case: X, Y, Z, A, and B
A temporary work-around for now (which I know will give me issues later) is /\(\w+\)| \w+/, but as it also matches whitespaces, it will cause problems further down the road, especially when it gets to the point of substituting the matches.
I have done some experimenting in the area of negative lookbehind in the form of:
/(?!=\()\w+/

...but i can't seem to find a way of combining it with ""not preceeded by (""
Just to be clear:

The matches in this case are all single letter, but actual data may be multiple characters and may not even be alphanumeric.
No whitespaces or parentheses can be a part of the returned match.

","Try this:
(?<=[ (])\w(?=[ )])

See it here in action: http://regexr.com?2vnri

Actually, this might be what you are looking for:
(?<= )\w+(?=[ )])|(?<=\()\w+(?=\))

See it here in action: http://regexr.com?2vnro
","
A regex to match 'M_*_DQ*' will be /M_.*_DQ.*/. . stands for ""any character"" and * stands for ""match 0 or more times"". Any special character that the user enters will need to be escaped with a backslash, so for instance if the user entered 'M(_*' this will become M\(_.*.
A regular expression is not the suitable tool for this.

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
","To achieve your goal of matching words that are not preceded by an opening parenthesis `(` unless also followed by another character, you can use a combination of regular expressions and Lisp functions. Since Emacs Lisp does not support negative lookbehind directly, you can use positive lookahead to ensure the character is followed by something other than a closing parenthesis `\)` or whitespace. Here's how you can do it:\n\n```lisp\n(defun match-non-paren-words (string)\n  (let ((regex ",0.4397,[[0.06006758]],0.024560814326218303,0.17188693659281892,0.07079646017699115,0.0,0.05309734513274336
"I'm working on an assignment where I have to construct a function which takes a single argument and returns various things. However, it is also supposed to do something when it is evaluated without an argument and I don't know how to do this. Does anyone know how one would go about implementing such a function? Could I perhaps set a condition that if it is evaluated with an argument it does x and if there is no argument it does y?
","You can use the form
(define g (lambda args ...body...))

for that. args will be bound to the list of all the supplied arguments in the function call. You can analyze it and take appropriate decisions inside your function's ...body....
A famous and very nice example is
(lambda args args)              

What's the name of this function?
Another syntax for defining such functions is
(define (g . args) args)

And to define a function that must get, say, at least two arguments, you'd write
(define (foo a b . c) ...body...)

; (define foo (lambda (a b . c) ...body...))

where a will be the first argument, b the second, and c will be the list of all the rest of arguments in the function call (possibly empty).
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 If it's capable of modifying the list passed to it, then it's destructive.
If a function takes a list via a symbol, it should be automatically assumed to be destructive, no?  Otherwise why not just take the list itself?
 There is no need to use the sharp-quote syntax here.  Its purpose is to use a function name in a variable position, but a is a variable already.  Just write a instead of #'a.
 With eager evaluation the distinction is required, languages with lazy evaluation (i.e. Haskell) if et al. can be functions.
Eager evaluation: The function's arguments are evaluated before calling the function, and only the results are passed to the function.
Lazy evaluation: A function's arguments evaluated if and only if they are accessed.
 Of course there is. When the expression is evaluated more than once and you need to pass the expression through more than one evaluation as is. Remember, when writing macros, the expression is usually evaluated twice (once during expansion and once as the macro result) and in some rare cases may need to be evaluated even more times.
","In Lisp, you can achieve this using multiple values or by defining different behaviors based on the presence of an argument. One way is to define a function that returns different results depending on whether it's called with or without arguments. For example, if your function should do something x when called with an argument and y when called without any argument, you can use a conditional statement inside the function. Here’s how you could implement it:\n\n```lisp\n(defun my-function (arg)\n  (if arg\n      (progn\n        ; Do action x here\n        ...)\n      (progn\n        ; Do action y here\n        ...)))\n```\nAlternatively, you can use multiple values to return different results based on the context. For instance:\n\n```lisp\n(defun my-function (&optional arg)\n  (if arg\n      (values 'x) ; Return x with an argument\n      (values 'y))) ; Return y without an argument\n```\nThis way, when called with no arguments, `my-function` will return a value that can be checked or used in further operations.",0.5569,[[0.25690708]],0.15670026015010444,0.3743675830038594,0.3333333333333333,0.06711409395973156,0.17333333333333337
"I think I'd have to dig into SICP later, but if it is two lists:
a b c d
1 2 3

Is there a standard way to get the multiplication of them in 2, 3 or 4 lines?
So the desired result is
a1 a2 a3 b1 b2 b3 ... d1 d2 d3

If we use any imperative language / method to do it, it is quite simple, but if we use Lisp / Scheme in a functional way (by declarative method), is there a standard method it is done?
","DrRacket has cartesian-product:
(require racket/list)
(cartesian-product '(a b c d) '(1 2 3))

And you can rewrite your Javascript code this way (in Racket):
> (apply append (map (lambda (a) (map (lambda (b) (list a b))
                                 '(1 2 3)))
                '(a b c d)))

'((a 1) (a 2) (a 3) (b 1) (b 2) (b 3) (c 1) (c 2) (c 3) (d 1) (d 2) (d 3))

Or in Common Lisp:
CL-USER 1 > (apply #'append (mapcar (lambda (a) (mapcar (lambda (b) (list a b))
                                 '(1 2 3)))
                '(a b c d)))

((A 1) (A 2) (A 3) (B 1) (B 2) (B 3) (C 1) (C 2) (C 3) (D 1) (D 2) (D 3))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 As mentioned in first comment it is necessarily to use (list a b c) form.
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
","In Lisp, you can achieve this using the `mapcar` function combined with `append`. Here's how you could do it in a functional way:\n\n```lisp\n(mapcan (lambda (x) x) '(a b c d))\n```\nThis will flatten the nested lists into one list as desired. However, this approach does not multiply the elements of two lists but rather concatenates them. If your intention is to create a Cartesian product, you might want to use `mapcar` in combination with `append` or another functional approach.\n\nFor example, if you have two lists `(a b)` and `(1 2 3)`, you can achieve the desired result using nested loops or a recursive function. Here’s an example of how you could do it recursively:\n```lisp\n(defun cartesian-product (list1 list2)\n  (if (null list1)\n      nil\n      (append (mapcar (lambda (x) (cons (car list1) x)) list2)\n              (cartesian-product (cdr list1) list2))))\n\n(cartesian-product '(a b) '(1 2 3))\n```\nThis will give you the Cartesian product of the two lists.",0.6082,[[0.29357546]],0.23983916398235358,0.3442927750273505,0.27303754266211605,0.11683848797250859,0.17747440273037546
"I want to create a macro (or function) which will contain package-prefixed symbols. This is possible only if those packages have already been defined. Why? As long as i have defined the packages by the time the macro/function gets called, why is there a problem if they are undefined when the macro/function is defined?
The reason I want this is that i want to have convenience functions in my init file for starting-stopping stuff i develop in different projects-packages but I dont want to load all the projects just to be able to define the convenience functions, since i only develop one project at a time.
","The source code is read by the Lisp reader before evaluation (see read). The reader can't intern the symbols if the packages aren't already defined.
","The codebase changed much since version 1, and the tutorial is a little bit outdated. There is, however, a compatibility layer to that version.
(ql:quickload :clack-v1-compat)

Then, the appropriate packages are loaded and you should be able to continue the tutorial.
 A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
 It's very easy. This is the base case:
(remove-nth 0 '(2 3)) ; => (3)

And the default case:
(remove-nth 1 '(1 2 3))         ; ==
(cons 1 (remove-nth 0 '(2 3)))

The only thing left for you to do is to actually implement it!
There is a third case. What if the list is nil? In the strictest sense you cannot do the job and you should signal an error or perhaps there isn't anything to do so it's ok to then have it as a base case that evaluates to '() so that (remove-nth 5 '(1 2)) ; ==> (1 2)
 To turn make-canned-format into a function, you need to replace
function with
compile or
(coerce (lambda ...) 'function).
However, your refactoring is misguided.
make-canned-format should be a macro - this way it will produce
a closure in the current compilation environment.
The function, however, will produce a closure in the global environment.
 Judging from the question, I think that you have a strange setup.  It seems to indicate that you are writing your functions directly at the REPL.  Don't do that.
The usual setup is to have an IDE (for example, Emacs with Slime) where you edit a source file, and then ""send"" top-level forms (like function definitions) to the REPL.
 I use auto-insert package, together with different templates to implement this. See my config as example (+ templates)
","The issue arises because when you define a macro or function, the compiler needs to resolve all symbols used within it. If a package is not defined at the time of definition but only at runtime, those symbols will be unresolved during compilation. This can lead to errors or incorrect behavior because the compiler cannot ensure that the symbols exist and are correctly imported.

To address your use case, you can define the macro or function in an environment where all necessary packages are known and loaded (e.g., within a specific project's init file). However, if you want to keep your convenience functions lightweight and not load unnecessary projects, consider using conditional loading mechanisms. For example, you could have your convenience functions check if certain packages are available at runtime before using them:

```lisp
(defun my-convenience-function ()
  (let ((package-name 'your-package))
    (when (find-package package-name)
      ;; Use symbols from the package here
      (some-function-from-your-package))))
```

This way, your convenience functions will only attempt to use symbols from a package if it is actually available in the current environment.",0.5163,[[0.24709161]],0.02725945193074332,0.23535564853556482,0.12322274881516587,0.019138755980861243,0.08530805687203792
"I'm new to Scheme, and I am trying to manipulate a list and return the cdr of a pair in the list.
So far here is my code:
(define get-userid (lambda (ls)
  (if (pair? ls)
      (cdar ls)
      (get-userid (cdar ls)))))

The list I wish to manipulate is:
(define *rider-preferences4*
  '((userid . anna)
    (role . rider)
    (origin . ""southampton"")
    (destination . ""glasgow"")
    (time . ""15:15"")
    (capacity . 2)
    (smoking . no)))

Input and outputs:
> get-userid *rider-preferences4*
#<procedure:get-userid>
((userid . anna) (role . rider) (origin . ""southampton"") (destination . ""glasgow"") (time . ""15:15"") (capacity . 2) (smoking . no))
> get-userid (get-userid *rider-preferences4*)
#<procedure:get-userid>
**anna**

I want the result of just anna, and to be able to do it just by calling get-userid. How would this be possible? Even though I assume it's trivial.
","Since *rider-preferences4* is an association list you can use the specific procedures  (assoc, assq, assv) to retrieve any key:
> (cdr (assq 'userid *rider-preferences4*))
'anna
> (cdr (assq 'destination *rider-preferences4*))
""glasgow""

so the code is
(define (get-userid alst)
  (cdr (assq 'userid alst)))

Besides being usable for any key, it is also independent of the position, so
> (get-userid '((role . rider) (userid . anna)))
'anna

will also work.
","Since *rider-preferences4* is an association list you can use the specific procedures  (assoc, assq, assv) to retrieve any key:
> (cdr (assq 'userid *rider-preferences4*))
'anna
> (cdr (assq 'destination *rider-preferences4*))
""glasgow""

so the code is
(define (get-userid alst)
  (cdr (assq 'userid alst)))

Besides being usable for any key, it is also independent of the position, so
> (get-userid '((role . rider) (userid . anna)))
'anna

will also work.
 This snippet is current in Clojure 1.4. Is it idiomatic for a function to submit a task back to the agent that called it? Yes.
Here is an example that uses a similar approach to recursively calculate a factorial:
(defn fac [n limit total]
  (if (< n limit)
    (let [next-n (inc n)]
       (send-off *agent* fac limit (* total next-n)) 
       next-n)
     total))

 (def a (agent 1))

 (await (send-off a fac 5 1))
 ; => nil
 @a
 ;=> 120

Update
The above is a contrived example and actually not a good one, as there is a race condition between the various recursive send-off calls and the later await.  There may be some send-off calls yet to be added to the agent's task queue. 
I re-wrote the above as follows:
(defn factorial-using-agent-recursive [x]
  (let [a (agent 1)]
    (letfn [(calc  [n limit total]
               (if (< n limit)
                 (let [next-n (inc n)]
                   (send-off *agent* calc limit (* total next-n))
                   next-n)
                 total))]
      (await (send-off a calc x 1)))
    @a))

and observed the following behavior:
user=> (for [x (range 10)] (factorial-using-agent-recursive 5))
(2 4 3 120 2 120 120 120 120 2)
user=> (for [x (range 10)] (factorial-using-agent-recursive 5))
(2 2 2 3 2 2 3 2 120 2)
user=> (for [x (range 10)] (factorial-using-agent-recursive 5))
(120 120 120 120 120 120 120 120 120 120)

Moral of the story is: don't use agents for synchronous calculations. Use them for asynchronous independent tasks - like updating animations displayed to a user :)
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 To copy loop use
(setq new_tour (copy-list loop))

 The way you are doing it is tree recursive and its running time will blow up exponentially. The link has efficient alternatives. But, if you want to keep the whole sequence you could do something like,
(defun fib (num)
  (let (seq)
    (labels ((helper (n)                                  ; define local helper function
               (when (<= n num)                           ; stop when reached NUM
                 (if (< n 3) (push 1 seq)
                     (push (+ (car seq) (cadr seq)) seq)) ; sum of previous 2
                 (helper (1+ n)))))                       ; recurse
      (helper 1))                                         ; start from first fib number
    (nreverse seq)))                                      ; reverse the result

 I am not a smartparens user but I found the answer from its wiki: 
You can bind ) to sp-up-sexp command: 
(define-key smartparens-mode-map "")"" #'sp-up-sexp) 

","To achieve your goal of directly returning 'anna' without needing to call get-userid twice, you can modify your function to correctly extract the value associated with the key 'userid'. Here's an improved version of your function using assoc from Scheme (or similar functionality in Common Lisp):",0.4982,[[0.19802498]],0.06103688133356975,0.22363328608524122,0.25862068965517243,0.03508771929824562,0.10344827586206896
"I'm using GNU Common Lisp on Windows.
In interactive moed, after I type (funcnTAB, the REPL auto-completes the function name. When I press TAB again, the debugger triggers as follows:
Break 1 [31]> (isqrt

ISQRT is the symbol ISQRT, lies in #<PACKAGE COMMON-LISP>, is accessible in 11
packages CLOS, COMMON-LISP, COMMON-LISP-USER, EXPORTING, EXT, FFI, POSIX,
READLINE, REGEXP, SCREEN, SYSTEM, names a
*** - CLHS-ROOT: variable *CLHS-ROOT-DEFAULT* has no value
The following restarts are available:
ABORT          :R1      Abort debug loop
ABORT          :R2      Abort main loop

It looks like I can somehow integrate the reference (CLHS) with the interactive shell
 so that I can have it available quickly. Where can I find such an offline copy of CLHS and how to integrate it with the REPL?
","It can be downloaded from here: ftp://ftp.lispworks.com/pub/software_tools/reference/HyperSpec-7-0.tar.gz.
Then you should apparently put the location where you've unzipped it into the variable *CLHS-ROOT-DEFAULT* so that GCL can access it. (I myself use the HyperSpec from SLIME and therefore have its location in the Emacs variable common-lisp-hyperspec-root.)
","It is an implemntaiton issue:
ccl e$ rlwrap ./dx86cl64
Loading ~/ccl-init.lisp
Welcome to Clozure Common Lisp Version 1.7-dev-r14614M-trunk  (DarwinX8664)!
? (subtypep 'string '(array character))
T
T
? 

 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 CL-USER> (mapcar #'caddr *jack*)
(FRUIT FRUIT AGENT AGENT)

EDIT: If you want to practise your recursive approach, try:
(defun attempt (list-of-lists)
    (if (null list-of-lists) nil
        (cons (third (car list-of-lists))
              (attempt (cdr list-of-lists)))))

EDIT2: Tail-recursively:
(defun attempt-tail (list-of-lists)
    (labels ((iter (rest ans)
               (if (null rest) (nreverse ans)
                   (iter (cdr rest) (push (third (car rest)) ans)))))
      (iter list-of-lists nil)))

EDIT3: While I'm at it, here's the loop version:
(loop for list in *jack* collect (third list))

 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

",Answer not found.,0.3719,[[0.]],1.9260971934543546e-11,0.012195121951219513,0.0,0.0,0.0
"If I call in Racket/Dr. Racket the following code:
> add1

I get:
#<procedure:add1>

If I am using a library for unit-test called rackunit and I try this:
(require rackunit)

(check-equal? add1 #<procedure:add1>)

The test fails with a syntax error:
read: bad syntax `#<'

Why does this happen?
","For many types of data, what you write can be read back. But in the case of procedures you can't, and thus it gets outputted as an unreadable value.
Procedure equality is like opaque structure equality: it only checks identity. If this all you need, you will still be able to store the procedure somewhere and use check-equal? (for example, a list with add1 will compare equal to a list with add1). If you need to actually check that the procedure is logically the same, this is not possible in general.
","Try adding :direction :output to create an output file stream:
(with-open-file (stream ""test.txt"" :direction :output
                                   :if-does-not-exist :create)
      (format stream ""success!""))

 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 In Racket it is possible to do a couple things in this spirit:

You can define a struct and give it a prop:procedure. When an instance of the struct is supplied in an application, the procedure will be called.
You can override the default #%app with your own function, to redefine application generally, and including things that aren't structs. For example you can do things like emulate Clojure's (key map) syntax, so that ('symbol dict) is actually (hash-ref dict 'symbol).

",Answer not found.,0.4107,[[0.02427676]],2.2794420225906995e-15,0.013842746400885939,0.020833333333333336,0.0,0.020833333333333336
"I'm just starting to learn Lisp and was wondering how to display a rational as a decimal number with lots of digits.
If I use (float x), where x is a rational then it displays about 8 digits or so. But I want to display hundreds of digits.
","You will have to implement an algorithm to basically do the long division and calculate the digits yourself. There is no native datatype capable of holding hundreds of decimal digits.
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Why would you do that? What you ask is to split a string (a one-dimensional array of characters) into a list of symbols. Do you really want that?
#\h is a character object printed.
You can print them differently:
CL-USER 8 > (princ #\h)
h

CL-USER 9 > (prin1 #\h)
#\h

Let's print the list using PRINC:
CL-USER 10 > (map nil #'princ (coerce ""Hello!"" 'list))
Hello!

Btw., since strings, vectors and lists are sequences, you can MAP directly over the string...
CL-USER 11 > (map nil #'princ ""Hello!"")
Hello!

 The FIRST, SECOND and so on accessor functions are ""just"" utility functions on top of CAR/CDR or NTH. SO, I guess, the answer to your specific question is ""use NTH or ELT"" (or build your own specific acccessor functions).
If you want, you can define an ELEVENTH as:

(defun eleventh (list)
  (nth 10 list))

I find, however, that I mostly use &REST arguments when there's 0 or more things I want to do something with, not really caring about the specific position of a given argument in the &REST list. That usually entails using LOOP, DO or DOLIST to traverse the arguments and do something with each one; the MAP family or (occasionally) REDUCE.
 '(x y z) is a list containing three symbols, x, y, and z. It's the same as (list 'x 'y 'z).
What you need to use, instead, is (list x y z).
The reason using '(4 10 2) (for example) works is that numbers are ""self-evaluating"". That means (list '4 '10 '2) is the same as (list 4 10 2).
 It's not a big number, in fact it's just a rational number close to 4.0, take a careful look (I added extra spaces for clarity):
271050543121377825343773346473727756780989953 / 67762635780343597914988263490310774732975168

You'll get the desired result by switching to inexact arithmetic, just make your initial guess a decimal value:
(define (sqrt x) (sqrt-iter 1.0 x))

Now it works as expected:
(sqrt 16)
=> 4.0

See the classic article What Every Computer Scientist Should Know About Floating-Point Arithmetic for more details of why this is happening.
","To display a rational number with many digits in Lisp, you can convert it to a floating-point number using FLOAT and then use FORMAT to control the number of decimal places. However, for arbitrary precision arithmetic, consider using libraries like GMP through bindings such as GMPLIB or MPFR through bindings like CL-USER:MPFR. These allow you to work with numbers that have an arbitrary number of digits.",0.5533,[[0.23751059]],0.08720757486936477,0.35471758173093937,0.24242424242424243,0.020618556701030927,0.1414141414141414
"I am reading a book about Common LISP and the author says : ""An alist consists of key/value pairs stored in a list.""
So it made me think, is this the same thing as a Dictionnary in C# or not?
If so why?
","There is a distinction between abstract concepts and concrete data-structures.
A dictionary is an abstract concept - a mapping of keys to values. It can be implemented with several different approaches:

as a list: of key-value pairs (Lisp's alists), a flat list of interleaved keys and values (Lisp's plists), as a pair of two lists of keys and values
as a table, be it Lisp's hash-table/Java's HashMap or some other kind of table
as a tree (Java's TreeMap)
etc

C#'s Dictionary is a data-structure that supports (amortized) constant lookup time, like CL's hash-table. In this regard it is different from alist, that has linear lookup time. Also alists don't depend on element's hash-code in order to store/retrieve it. The API of alists is also different, than Dictionary's. There's assoc and rassoc to lookup an element from the left side and right side respectively. (So, unlike in a conventional dictionary, there can be multiple mappings of the same key to different values in an alist). Also there are acons and pairlis to construct an alist.
EDIT And, finally, there's no standard function to remove an item from alist.
You can delete an element with (remove key alist :key #'car). But note, that this operation leaves the original list intact and returns a modified list as a result.
","Courtesy of Paul Graham, here's a Common Lisp implementation of John McCarthy's original LISP:
It assumes quote, atom, eq, cons, car, cdr, and cond, and defines null, and, not, append, list, pair, assoc, eval, evcon and evlis.
 lat is assumed to be a list of atoms at that point in the book. 
If it's not empty, by definition it contains some atoms in it. 
It's not about Lisp, it's about the book's presentation.
 The convention I use is to use a unique word: salza, skippy, zs3, etc. I don't really try to have a direct relationship to the library functionality. I try to avoid generic words that others might use like ""zlib"" or ""zip"" or ""png"".
Edi Weitz uses Frank Zappa-related words to name many of his packages: Hunchentoot, Drakma, etc.
Some people use Java-style org.foo.bar reversed domain naming.
So, the direct answer is no, there isn't a common, agreed-upon convention that everyone uses.
 
Am I misunderstanding how substitute-if works or misunderstanding the representation of the list?

Probably the latter.
#1=... marks a spot in the data structure and #1# refers back to it. The idea is to show that both elements refer to the same list. (See also http://www.lispworks.com/documentation/HyperSpec/Body/02_dhp.htm.)
It's like:
(let ((x '(0)))
  (list '(1) x '(3) x))

Because they refer to the same object, if you were to modify the second list in place, the modification would also show up in the fourth list.
 My assumption is that ""thread-id"" is some sort of procedure. 
 Read McCarthy's 1960 paper, ""Recursive Functions of Symbolic Expressions and Their Computation By Machine, Part I"".
He starts by defining S-expressions.  One of the rules is that if e1 is an S-expression and e2 is an S-expression, then < e1 . e2 >, the dotted pair, is also an S-expression.
A few lines later, he defines the list notation, as a shorthand for an expression built up of a chain of dotted pairs.
This was the paper that first defined what would eventually become LISP.  It didn't become an actual programming language until Steve ""Slug"" Russell implemented the first interpreter.
","In Common Lisp, an alist (association list) is indeed similar to a dictionary in C#, but they are implemented differently. An Alist is a list of key-value pairs where each pair consists of two elements: the key followed by its associated value. This structure allows you to store and retrieve data based on keys, much like a dictionary in C#. However, an alist does not provide the same level of efficiency as a true hash-based dictionary for lookups, insertions, and deletions due to its list-based nature. Dictionaries in C# are generally implemented with hash tables or similar structures that offer faster access times. The primary difference is in their internal implementation and performance characteristics.",0.587,[[0.46589332]],0.10060425026975679,0.2235037253947951,0.4090909090909091,0.09714285714285716,0.18181818181818182
"I'm looking for something that is probably very well defined in Clojure (in the Lisp world at large in fact) but I don't have enough experience or culture to get on the right track and Google hasn't been very helpful so far.
Let's say I have three simple forms:
(defn add-one   [v] (+ v 1))
(defn add-two   [v] (+ v 2))
(defn add-three [v] (+ v 3))

Out of convenience, they are stored in a vector. In the real world, that vector would vary depending on the context:
(def operations
  [add-one
   add-two
   add-three])

And I also have an initial value:
(def value 42)

Now, I would like to apply all the functions in that vector to that value and get the result of the combined operations:
(loop [ops operations
       val value]
  (if (empty? ops)
    val
    (recur (rest ops)
           ((first ops) val))))

While this does work, I'm surprised there isn't a higher level form just for that. I've looked all over the place but couldn't find anything.
","The functional phrase you are searching for is (apply comp operations):
((apply comp operations) 42)
;48


Your loop does work if you feed it 42 for value:
(loop [ops operations
       val 42]
  (if (empty? ops)
    val
    (recur (rest ops)
           ((first ops) val))))
;48

This applies the operations in the opposite order from comp.
... As does using reduce:
(reduce (fn [v f] (f v)) 42 operations)
;48

If you look at the source code for comp, you'll find that the general case essentially  executes a loop similar to yours upon a reversed list of the supplied functions. 
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
 You have to evaluate each argument recursively, something like:
template <typename T>
auto eval(T t)
{
    return t;
}

template <typename ...Ts>
auto eval(std::tuple<Ts...> tuple)
{
    return std::apply([](auto... args){ return std::invoke(eval(args)...); }, tuple);
}

Demo.
","In Lisp, especially in Common Lisp, you can achieve the desired functionality using `reduce` or `apply`. Given your example with operations stored in a vector and an initial value, you could use `reduce` to apply all functions sequentially. Here's how you can do it:\n\n```lisp\n(defun apply-operations (ops val)\n  (reduce #'funcall ops :initial-value val))\n\n;; Define the operations as before\n(def operations\n  '(add-one add-two add-three))\n\n;; Initial value\n(value 42)\n\n;; Apply all operations to the initial value\n(apply-operations operations value) ;; This will return 48, which is (1 + 2 + 3 + 42)\n```\n\nThis approach avoids the need for loops and directly leverages Lisp's functional programming capabilities. The `reduce` function applies a binary function (`funcall` in this case, which calls functions) to the elements of an iterable (in this case, your list of operations), accumulating the result.",0.5486,[[0.45387264]],0.10620684496557141,0.37430998854141695,0.3557312252964427,0.03187250996015936,0.21343873517786563
"Learning Lisp from Practical Common Lisp I'm constantly coming across new builtin form s (please correct me if haven't used the right terminology). The latest one was 'character. 
So I was wondering is there a command to get a list of all the builtins in Common Lisp? So that I could just easily skim through them all in one place.
Maybe something akin to Python's dir(__builtins__).
Additional tip would be appreciated.
","You could collect a list of all of the external symbols in the COMMON-LISP package:
(let (lst)
  (do-external-symbols (s (find-package 'common-lisp) lst)
    (push s lst)))

There are a lot of them!  Check out the symbol index of the hyperspec.
A lot of these symbols you'll probably never use, and I'm not sure it's worthwhile to look at each of them.
I would recommend becoming somewhat familiar with all of the special forms:
block      let*                  return-from      
catch      load-time-value       setq             
eval-when  locally               symbol-macrolet  
flet       macrolet              tagbody          
function   multiple-value-call   the              
go         multiple-value-prog1  throw            
if         progn                 unwind-protect   
labels     progv                                  
let        quote                                  

Now, CHARACTER in particular is a standard type.  The hyperspec has a list of those as well, but I don't think there's a standard way to find all of the types programmatically.
","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

","In Common Lisp, there isn't a direct equivalent of Python's `dir(__builtins__)` to list all built-in functions. However, you can get an idea of the available symbols in the current environment by using the `sb-ext:inspect` function with the package object (if you're using SBCL), or by exploring the documentation and the environment interactively. For example, you can use `(describe *package*)` to inspect the current package and see its contents. Additionally, you can use `(macroexpand-1 '(function-name))` to get information about a specific function, or refer to the Common Lisp HyperSpec for a comprehensive list of functions and macros.",0.4948,[[0.40199434]],0.040607951880303084,0.16591262305020482,0.3070866141732284,0.05555555555555556,0.1732283464566929
"I accidentally forgot to put the else in the following cond expression, and something strange occurred.
(define (abs x)
  (cond ((< x 0) x)
        ((= x 0) 0)
        (+ 1 2 1001)
        ))

> (abs 1)
1001
> 

the result of (abs 1) is not the result of (+ 1 2 1001)，which is 1004, but the last element of the arguments of the expression (+ 1 2 1001).
the cond form is 
(cond (<p1>,<e1>)
      (<p2>,<e2>)
      (<p3>,<e3>)
      ...
      (<pn>,<en>))

there is no predicate in the expression (+ 1 2 1001), so I wonder if the procedure + has been considered as predicate, and if it always evaluates as true, selecting the last element to return. Is that how it works???
","Sequencing: begin form in Racket allows you to sequence multiple expressions. It evaluates each expression from left to right and the final result is the last expression.
Syntax: The syntax for cond shows that multiple expressions can be sequenced in the rhs of a clause without a begin. Such a thing is called an implicit begin. 
Semantics: According to the documentation, cond evaluates the rhs of a clause if the lhs is anything but #f. Therefore + in the position of the test-expression evaluates the rhs of the clause. 
Style: By convention, using square brackets in a few key places makes Racket code even more readable. The clause of a cond is one of these places. 
The following snippet is equivalent to your snippet:
#lang racket

(define (abs x)
  (cond [(< x 0) x]
        [(= x 0) 0]
        [+ (begin 1
                  2
                  1001)]))
(abs 1) 
; => 1001

","The alternate expression for the 'if' expression is ((set! ...) ...).  The first position needs to be either a function or a syntactic form.  In this case you need progn as:
(progn
  (setq list1 ...)
  (setq list2 ...)
  (eql x y))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 You will find that, in the REPL, the variable * holds the last result, and + holds the last evaluated form. 
For example:
> (+ 1 2)
  => 3
> +
  => (+ 1 2)
> (+ 2 3)
  => 5
> *
  => 5

Yes, these are standard, and in the HyperSpec.
If you wish to create a list containing the symbol +, rather than its value, you will need to quote it, as such: '+, or (quote +).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","In your `cond` expression, you forgot to include an else clause or a predicate for the final condition. In Common Lisp, if no predicate is satisfied and there's no else form, `nil` (or whatever the last evaluated form is) is returned. In your case, the form `(+)` without any arguments evaluates to the function itself, which in this context acts as a non-false value, causing it to be selected by `cond`. The result of `(+)`, or the last evaluated expression before an else clause would have been present, is indeed 1001. This is not because the procedure `+` always evaluates as true, but rather because no predicate was provided for a false condition, and `nil` (or the value after the last evaluated form) is returned by default.",0.501,[[0.48802467]],0.1160988197371548,0.2592016588906169,0.37174721189591076,0.022471910112359553,0.1784386617100372
"Say, if I have a Lisp program, which uses (eval 'sym) and looks it up in its symbol-table does it actually perform better than something like aClass.getField(""sym"", anInstance) in ""static"" languages?
","In general (modulo implementation issues like bytecode vs native code or code generation quality), languages with metalinguistic abstraction provide more power to create programs that outperform programs that can be created in comparable timeframe with language that lacks such abstractions. The case is that when you write an implementation for your own language, you have more information to make much more powerful optimizations than compiler for base language can do. There are numerous examples of this in practice.
Also, you seem to mix together the reflection (being a particular case of 'open implementation') and metalinguistic abstraction. Metalinguistic abstraction is about building new languages on top of base languages and reflection (or 'open implementation') is about exposing program's internals to the program itself.
In your particular example (of course, module implementation issues like bytecode vs native code or code generation quality), (eval 'sym) is probably faster. The reason is that 'sum is a symbol object and not a string. Evaluating a symbol means taking its value cell. So eval has to do only several things:

Dispatch on an object type (in this case - a symbol) (e.g., by using a value tag to go through jump table)
Extract symbol's value (by dereferencing a symbol structure)

But Java example has more things to do:

Find a field given its name. This requires e.g. calculating a hash of a string and using hashtable
Extract the field's value (by dereferencing instance pointer at an offset specific to field)
Box the value (if it's not a reference)

The particulary expensive part is calculating the hash and going through hashtable.
","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 The reason the ANSI CL standard does not specify the algorithmic complexity of 
library functions is that it is not its job. The standard describes the behavior, and leaves performance to the implementation-specific docs. 
It was assumed that the best theoretical performance will be provided by all implementations (otherwise no one would use it).
To answer your specific question, gethash is O(1) in all implementations.
 EVAL in Common Lisp only evaluates in a current dynamic environment and the null lexical environment. Enclosing it in lexical constructs like MACROLET, LET, ... or similar is not going to work.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Judging from the question, I think that you have a strange setup.  It seems to indicate that you are writing your functions directly at the REPL.  Don't do that.
The usual setup is to have an IDE (for example, Emacs with Slime) where you edit a source file, and then ""send"" top-level forms (like function definitions) to the REPL.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

","In Common Lisp, using (eval 'sym) and looking up symbols in the symbol table is generally not more efficient than using a similar mechanism in statically typed languages like Java. The performance of (eval 'sym) depends on the implementation's handling of evaluation, which can be slower due to the dynamic nature of Lisp. In contrast, static language mechanisms like Java's reflection API are optimized for performance and are typically faster. However, the actual performance difference would depend on specific implementations and use cases.",0.5284,[[0.35957869]],0.03335467670651388,0.14647998692120315,0.29378531073446335,0.03409090909090909,0.11864406779661017
"According to CLHS entry for the INTERSECTION function (http://www.lispworks.com/documentation/HyperSpec/Body/f_isec_.htm):

For every pair that satifies the test, exactly one of the two elements
of the pair will be put in the result.

My problem is that i need to know which one of the two elements of the pair will be put in the result, which matters when, for example  :key #'car  is used to extract the arguments to test against, since the cdr might be different. I would like to have a guarantee that either always the first or always the second element will be put in the result. Am I missing something or is this just unspecified behaviour, so I shouldnt use it for my case?
","intersection simply doesn't make the guarantee you want; it implements set-theoretic intersection with a lot of extras, but just not that extra. You'll have to roll your own.
","The message seems pretty clear to me: you are trying to get the first element of an empty list, which conflicts with your specification.
Based on this reference, it seems that first expects a non-empty list, whereas car returns nil when your input is nil.
Either you handle the nil case explicitely with an endp test or you use car instead of first.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 
Yes, the association list is one way to express key-value associations. Other structures Common Lisp provides to that end are property lists and hash tables.
The value is actually already contained in a list. An alist is fundamentally a list of pairs, where the car of each pair is the key, and the cdr is the value associated with that key. If you look up the key LIVING-ROOM with ASSOC and apply CDR to the result:

CL-USER> (cdr (assoc 'living-room *edges*))
((GARDEN WEST DOOR) (ATTIC UPSTAIRS LADDER))

The magic behind this lies in the fact that a pair whose car is living-room and whose cdr is a list of the two elements (garden west door) and (attic upstairs ladder) can also be viewed as the three-element list (living-room (garden west door) (attic upstairs ladder)), due to the way lists are constructed out of pairs.
Usually when representing alists as quoted objects, you see the elements depicted explicitly with dotted pairs, rather than punning with list notation, like so:

(defparameter *edges* 
  '((living-room . ((garden west door)
                    (attic upstairs ladder)))
    (garden . ((living-room east door))) 
    (attic . ((living-room downstairs ladder))) ))

 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 nconc is a destructive operation that alters its first argument by changing its tail. In this case, it means that the constant list '(oh my) gets a new tail.
To hopefully make this clearer. It's a bit like this:
; Hidden variable inside exclaim
oh_my = oh → my → nil

(exclaim '(lions and tigers and bears)) =
    lions → and → tigers → and → bears → oh_my

(nconc * '(goodness)) destructively appends goodness to the last result:
    lions → and → tigers → and → bears → oh → my → goodness → nil
so now, oh_my = oh → my → goodness → nil

Replacing '(oh my) with (list 'oh 'my) fixes this because there is no longer a constant being shared by all and sundry. Each call to exclaim generates a new list (the list function's purpose in life is to create brand new lists).
","Based on your description and the information provided, the behavior of `INTERSECTION` when using a key function (like `:key #'car`) is indeed unspecified. The HyperSpec does not guarantee whether the first or second element of each pair will be included in the result for pairs that satisfy the test condition. Given this lack of specification, you should consider an alternative approach if deterministic behavior is required. For your specific use case, you might need to implement a custom function that explicitly handles the selection logic based on your requirements.",0.5194,[[0.21924337]],0.040970729675321664,0.32234614962272723,0.2,0.0,0.13333333333333333
"Is there a way to sort a list made of only characters in alphabetic order (from ""a"" to ""z""), such as: (list c m a y k) => (list a c k m y)?
I didn't found a sort like that, so i thought this could solve the problem:
cl-prompt> (setq q (mapcar 'string '(c m a y k))) => (""C"" ""M"" ""A"" ""Y"" ""K"")
cl-prompt> (sort q 'string<) => (""A"" ""C"" ""K"" ""M"" ""Y"")

At this point i'm stuck, because by using the char converter the output will not be the list i want.
Example:
char (string 'a) 0 => #\A

And i will have a list made of: (#\A #\C #\K #\M #\Y), which is not the result i want.
","In the case of (c m a y k), you have a list of symbols.
In the case of (#\A #\C #\K #\M #\Y), you have a list of characters.
If you want to sort a list of symbols according to the symbol names, you can do (I am assuming the list is bound to the variable foo below):
(setq foo (sort foo #'string< :key #'symbol-name))

Note that the :key #'symbol-name could be argued to be superfluous, as string< actually operates on ""string designators"", but it is much clearer to a human reader that you are indeed intending to sort the list based on symbol names if you say so explicitly.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Generally return a list of depths. So, if an item is found, then return the list of the single depth. If you branch to the first and rest of the list, then don't 'cons', but 'append'.
Note also that your code does not find all depths.
CL-USER 6 > (search-node '(6 (6)) 6)
0

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
","To sort a list of characters (like (list c m a y k)) alphabetically, you can use the `sort` function along with the appropriate comparison function. However, since your elements are already characters, you don't need to convert them using `string`. You can directly apply `sort` as follows:

```lisp
(sort '(c m a y k) 'char<)
```

This will sort the list of characters from 'a' to 'z'. The result will be (list a c k m y). Here, `char<` is the default comparison function for characters in Common Lisp that you can use.",0.5995,[[0.47849108]],0.22700002195478164,0.32134479332505955,0.4154589371980676,0.17560975609756097,0.21256038647342998
"I am doing exercise 3.13 from SICP but I am unsure of my answer.

Exercise 3.13: Consider the following make-cycle procedure, which uses
  the last-pair procedure defined in Exercise 3.12:
(define (make-cycle x)   (set-cdr! (last-pair x) x)   x)
Draw a box-and-pointer diagram that shows the structure z created by 
(define z (make-cycle (list 'a 'b 'c)))
What happens if we try to compute (last-pair z)?

I'm trying to understand why
(last-pair z)

becomes an infinite loop. Ignoring the box-and-pointer diagram, here is how I understand it:
(set-cdr! (last-pair x) x)

(last-pair x) would be the pair (cons 'c '()), then when we do set-cdr! the pair would become:
(cons 'c (cons 'a (cons 'b (cons 'c (cons 'a (cons 'b (cons 'c (cons 'a (cons 'b (cons 'c ...))))))))))

is my understanding correct?
","No.
Your answer appears to indicate that (last-pair x) is the result of calling cons infinitely many times.
Not so.
x is still just 3 cons cells, but the last one points to the first one, creating a loop (a snake biting itself on the tail).
","As mentioned in first comment it is necessarily to use (list a b c) form.
 You've got it almost right. However, you're terminating your list with 0, when the correct termination is nil. This code works:
(defun vecmul (list list2)
  (cond ((null list) nil)
     (t (cons (* (car list) (car list2)) (vecmul (cdr list) (cdr list2))))))

When you call (cons 1 2), the cons cell you get is written (1 . 2). the notation (1 2 3 4 5) is just shorthand for (1 . (2 . (3 . (4 . (5 . nil))))). If the cdr of the last cons cell is 6, not nil, then you get (1 . (2 . (3 . (4 . (5 . 6))))), which shortens to (1 2 3 4 5 . 6).
 An example: if list is (3 3 5 6 6 6 9), the loop will examine each list element in turn, and set these hash keys to t: 3, 5, 6, and 9.  Since 3 and 6 are duplicated in the list, no new hash key will be created for those elements.  Finally hash-table-count returns the number of keys in the hash table, i.e. 4.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 nconc is a destructive operation that alters its first argument by changing its tail. In this case, it means that the constant list '(oh my) gets a new tail.
To hopefully make this clearer. It's a bit like this:
; Hidden variable inside exclaim
oh_my = oh → my → nil

(exclaim '(lions and tigers and bears)) =
    lions → and → tigers → and → bears → oh_my

(nconc * '(goodness)) destructively appends goodness to the last result:
    lions → and → tigers → and → bears → oh → my → goodness → nil
so now, oh_my = oh → my → goodness → nil

Replacing '(oh my) with (list 'oh 'my) fixes this because there is no longer a constant being shared by all and sundry. Each call to exclaim generates a new list (the list function's purpose in life is to create brand new lists).
","Your understanding is on the right track but needs a bit of clarification. When you call (make-cycle (list 'a 'b 'c)), it creates a cycle where the last pair points back to the beginning of the list, forming a loop. The box-and-pointer diagram for z would show nodes interconnected in a cycle. If you call (last-pair z), it follows this chain until it reaches the node that loops back to the start, creating an infinite loop because there's no termination condition. The set-cdr! operation changes the cdr of the last pair to point to the entire list x, not just the first element 'a'. Therefore, the structure becomes a cycle where (last-pair z) will keep following the chain indefinitely.",0.5543,[[0.45783562]],0.12321711226392493,0.37376235438706107,0.3121387283236994,0.09356725146198831,0.18497109826589594
"Here's what I have so far:
(defun append-all(x L)
  (if (null L)
    L   
    (cons (append (car L) x) (append-all x (cdr L))))
  )
)

Output:
(append-all '3 '((1) (2 1) (2)))

((1 . 3) (2 1 . 3) (2 . 3))

Want:
((1 3) (2 1 3) (2 3))

This is a helper function, so the fact that it is a linked list seems to be causing me problems.
Thanks
edit: fixed recursive call
","In your code, change this part:
(append (car L) x)

To this:
(append (car L) (list x))

It wasn't working before because append should receive two lists as parameters, not a list and an element.
","If I understood correctly, you can combine reduce and append to flatten the list before returning it.  
Example:  
(reduce 'append '((1) (2) (3)))

Output:  
(1 2 3)

In your case this might work:
(reduce 'append (mapcar 'recursive-function L))

 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","It looks like you're trying to flatten and concatenate lists. The issue with your current implementation is that `cons` and `append` are being used incorrectly for flattening the list. Instead of using `append`, you can use `reduce` combined with `append`. Here's how you can modify your function:\n\n```lisp\n(defun append-all (x L)\n  (if (null L)\n      '()\n      (reduce 'append (cons x (mapcar #'(lambda (sublist) (append sublist x)) (cdr L))))))\n```\n\nThis function will correctly flatten and concatenate the lists. Note that we use `reduce` to combine all sublists after adding `x` to each sublist using `mapcar`.",0.513,[[0.22387722]],0.03888031591829772,0.29279198966408276,0.19999999999999998,0.014492753623188404,0.1142857142857143
"I have a list:
*DSTATES* = ( ( list1 ) ( list2 ) ( list3 ) ... ( listn )  )

And a list of state names, x = ( list )
*DSTATES* has ( (zero) (three two one) (two) (three zero) )
x has (two).
Here's my code:
(map '() #'(lambda (x)
           (princ ""Looking at transition "") (princ x)
           (princ #\newline)
           (if (and (eq '() (member x *DSTATES*)) (not (eq '() x)))
               (progn
                 (princ x) (princ "" is not a member of *DSTATES*"")
                 (princ #\newline)
                 (setq *DSTATES* (append *DSTATES* (list x)))))
           (princ ""Intermediate *DSTATES* "") (princ *DSTATES*)
           (princ #\newline) (princ #\newline))
       trans)

When I do ( eq '() ( member x *DSTATES* ) ) it always--as far as I can tell--returns true. Because of this *DSTATES* gets larger and larger and my loop, which has a stop condition on the size of *DSTATES* never terminates.
How can I fix this?
","Simply do (member x *DSTATES* :test #'tree-equal)
That will make member check membership.
Hope that helps guys
how to test whether one list is a member of another
","(setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 You don't need eval here; use begin instead to group those definitions together into a list; i.e., the template to be expanded should be of the form:
`(begin 
   ,@(map ...)
   (define ...)
   (define ...)
   ...)

Edit:
Change for-each to map as suggested by OP.
 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
","The issue you're encountering is due to how the `member` function works. The `eq '() (member x *DSTATES*)` condition will always return true if there are no elements in `*DSTATES*` that match `x`, but it doesn't correctly check for the absence of a specific element within nested lists. Instead, you should use `find` to check if an element exists in the list. Here’s how you can modify your code:\n\n```lisp\n(mapcar #'(lambda (x)\n           (princ \",0.5412,[[0.19653648]],0.08852159567354717,0.34691961602070487,0.23853211009174316,0.03738317757009346,0.12844036697247707
"I am fairly new to functional programming. I am learning clojure. I was trying out a few commands. Some of them work fine.  I got this weird one below:
(read-string ""1 2 3"")
;;this ouputs
1


(read-string ""[1 2 3]"")
;;this ouputs
[1 2 3]

I am wondering why in the first one it doesn't output the complete string.
but does output it in the second one.
     1 2 3
Any reason for this?

In case you are wondering, i was doing this on command line. It shouldn't really matter. 
","None of your examples output a string.
As the docstring says: ""Reads one object from the string s.""
In the first case the object is 1, in the second case the object is [1 2 3].
To output a string the object needs to be a string, e. g. (read-string ""\""1 2 3\"""")
","I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
",The behavior you're observing is due to how `read-string` works in Clojure (and other Lisps). When you call `(read-string ,0.4841,[[0.29739171]],0.035891882402767,0.16274783038934057,0.21052631578947367,0.02702702702702703,0.15789473684210525
"First of all, I work with LispWorks. 
I have an adjustable array where I want to insert an element in position i < fill-pointer, so I will need to move all the elements from i to its position + 1. My problem is I don't know how to do that and have as result an adjustable array but WITHOUT COPYING all the elements to another array. Performance is really important.
With this array #(0 1 2 3 4 6 7) my way to insert number 5 in position i=5:
(let ((arr (make-array 7 :initial-contents (list 0 1 2 3 4 6 7) 
                     :adjustable T :fill-pointer 7))
      (i 5)) 
    (concatenate 'vector (subseq arr 0 i)
                         (make-array 1 :initial-contents '(5))
                         (subseq arr i (fill-pointer arr))))

which I don't know if LispWorks is internally copying all elements to the result array, but  gives me the desired array, although it is no adjustable and does not have fill-pointer.
Some idea?
","To increase optimization opportunities for your compiler, use specialized simple-array if possible; i.e., avoid fill-pointer and adjustable array.  Also, higher level operation such as replace should allow memory to be moved in blocks (instead of one word at a time).
(defun insert-at (vec i val)
  (check-type vec (simple-array fixnum 1))
  (let ((new (make-array (1+ (length vec)) :element-type 'fixnum)))
    (declare (optimize speed))
    (setf (aref new i) val)
    (replace new vec :end1 i)
    (replace new vec :start1 (1+ i) :start2 i)))

Repeat 100 times to get more meaningful benchmark result(using sbcl):
(let ((arr (make-array 1000000 :element-type 'fixnum)))
  (time (loop repeat 100 for i from 500000 do
          (insert-at arr i i))))

Evaluation took:
  0.988 seconds of real time
  0.992062 seconds of total run time (0.804051 user, 0.188011 system)
  [ Run times consist of 0.148 seconds GC time, and 0.845 seconds non-GC time. ]
  100.40% CPU
  2,962,811,250 processor cycles
  800,003,200 bytes consed

Probably you should look at heap, which allows O(log n) insertion while maintaining (some sort of) order.  Several implementations are available via quicklisp.
","Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 A solution that uses your initial approach is the following:
(defun max-occurrences(l)
  (let* ((occurrences (remove-duplicates 
                        (mapcar #'(lambda (elt) (cons elt (count elt l))) l) 
                        :test 'equal))
         (max-occurrence (reduce #'max occurrences :initial-value 0 :key #'cdr)))
    (mapcar #'car (remove-if-not (lambda(x) (= x max-occurrence)) occurrences :key #'cdr))))

However, this solution is not efficient, since it has a cost of O(n2) (in the initial phase, each element of the list is compared with all the others to count its frequency). 
Edited
A more efficient solution could be obtained for instance by using a hash table (with the improvement suggested in the comment by @uselpa):
(defun max-occurrences(l)
   (let* ((table (make-hash-table))
          (max-count (loop for elt in l maximize (incf (gethash elt table 0)))))
     (loop for elt being the hash-key of table using (hash-value count)
        when (= count max-count) collect elt)))

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
","In LispWorks or other Common Lisp implementations, you can use the `adjust-array` function to resize an adjustable array and then manually copy elements if needed. However, for directly inserting an element at a specific position without copying all elements, you might need to create a new array with the required size and copy elements from the original array. Unfortunately, adjusting arrays in-place to insert elements is not straightforward due to how memory allocation works.

Here's a more efficient approach using `adjust-array` and manual element insertion:

```lisp
(defun insert-element (array index value)
  (let* ((new-size (+ (length array) 1))
         (new-array (make-array new-size :initial-contents array :adjustable t)))
    (replace new-array array)
    (setf (aref new-array index) value)
    new-array))

;; Example usage:
(let ((arr #(0 1 2 3 4 6 7))
      (i 5)
      (val 5))
  (setq arr (insert-element arr i val)))
(arr) ;; => #(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
```

This method avoids copying all elements to a new array and manually inserts the value at the specified position. Note that `adjust-array` is used to ensure the resulting array remains adjustable, but element insertion still requires creating a new array for efficiency.",0.6192,[[0.30299892]],0.2826117013955351,0.3747816061778024,0.2842639593908629,0.061224489795918366,0.14720812182741116
"I'd rather use let ... and ... and ... in than nested let's when possible, but the normal let syntax doesn't allow this for expressions that depend on each other.
Not allowed:
let encrypt password =
    let seed = int 16
    and keys = xlat seed (length password)
    and plaintext = map code (explode password) in
        map2 logxor plaintext keys

Does OCaml have an equivalent to Lisp's let*, which does allow this?
","Nested let's don't need nested indentation, so that's good enough.
","(setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 To use open files, you must save the return value of open and uses it as the second argument to princ. You must also use that same return value as an argument to close.
This is usually done with the convenience macro with-open-file.
The files chapter of Practical Common Lisp shows how to use these and other functions and macros.
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 Use MAP-INTO:
CL-USER 16 > (let ((s (list (list 1 2 3)
                            (list 4 5 6)
                            (list 7 8 9))))
               (map-into s #'rest s))
((2 3) (5 6) (8 9))

","In Common Lisp, you can use LET* for bindings that depend on each other, similar to your example. However, if you want to avoid nested forms and prefer a more linear syntax, you can also use multiple VALUES with let. For instance, in your case, you could define the variables as follows:\n\n```lisp\n(let* ((seed (int 16))\n       (keys (xlat seed (length password)))\n       (plaintext (map 'list #'code (explode password))))\n  (map2 'logxor plaintext keys))\n```\nAlternatively, you can use multiple values directly in a let form:\n\n```lisp\n(let ((seed (int 16))\n      (keys (multiple-value-list (xlat seed (length password))))\n      (plaintext (map 'list #'code (explode password))))\n  (map2 'logxor plaintext (second keys)))\n```\nThis approach avoids the need for an explicit LET* and keeps the code clean.",0.3975,[[0.10429993]],0.009432439714628836,0.15224358974358976,0.05405405405405406,0.0,0.04054054054054055
"I am trying to convert a list of S-expressions to a plain list of atoms similar to a problem in the book The Little Schemer.
My code is (as typed in Dr.Racket):
> (define lat '((coffee) cup ((tea) cup) (and (hick)) cup))
> (define f
    (lambda (lat)
      (cond
        ((null? lat) (quote ()))
        ((atom? (car lat)) (cons (car lat) (f (cdr lat))))
        (else (cons (f (car lat)) (f (cdr lat)))))))
> (f lat)
'((coffee) cup ((tea) cup) (and (hick)) cup)

The above code is returning back the list the same as input list. I tried my best, but getting different answers like:
(coffee)
(cup . cup)
( () (()) (()) )

for various modifications in the program.
I would like to know, can we achieve the answer:
'(coffee cup tea cup and hick cup)

given
'((coffee) cup ((tea) cup) (and (hick)) cup)

by using cond cons car and cdr only.
","Tweak it:
(define f
    (lambda (lat)
      (cond
        ((null? lat) (quote ()))
        ;; add this clause
        ((null? (car lat)) (f (cdr lat)))
        ((atom? (car lat)) (cons (car lat) (f (cdr lat))))
        (else ;; (cons (f (car lat)) (f (cdr lat)))
             (f (cons (car (car lat))       ; rotate the tree to the right
                      (cons (cdr (car lat)) (cdr lat))))))))  ; and repeat

Uses John McCarthy's ""gopher"" trick, rotating the tree to the right until the leftmost atom is exposed in the top left position, then splitting it off and continuing.
","Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 Iterate over your list and store each pair's car into a list in an assoc that looks like this:
original: ((2 . 1) (3 . 2) (1 . 2) (5 . 1) (6 . 3))
new:      ((1 . (2 5))
           (2 . (3 1))
           (3 . (6))

Then sum together all the cdrs and flip each pair to get this:
          ((7 . 1) (4 . 2) (6 . 3))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 One problem is you have your < and > reversed. Assuming you want your left sub tree to be the smaller, then (< value (car tree)) should call again with the (cadr tree).
Also you should use #t instead of (#t).
","To convert a list of S-expressions to a plain list of atoms, you need to recursively process each element. If an element is a list, you should first flatten it by calling the function on that sublist before consing it with the result for the rest of the current list. Here's how you can implement this using `cond`, `cons`, `car`, and `cdr` only:

```lisp
(define (flatten lat)
  (cond
    ((null? lat) '())                    ; Base case: if the list is empty, return an empty list
    ((atom? (car lat))                   ; If the first element is an atom
     (cons (car lat)                     ; Cons it with the result of processing the rest of the list
           (flatten (cdr lat))))
    (else                                ; If the first element is a list
     (append (flatten (car lat))         ; Flatten the sublist and cons it to the result of processing the rest of the list
             (flatten (cdr lat))))))

(define lat '((coffee) cup ((tea) cup) (and (hick)) cup))
(flatten lat)
```

This will return `'(coffee cup tea cup and hick cup)` as desired.",0.7136,[[0.46491339]],0.35070040272095937,0.6040690898018471,0.3373493975903614,0.11336032388663968,0.20080321285140562
"I tried to implement a natural sort:
Break 21 [92]> (defparameter *sss* '(""1.txt"" ""10.txt"" ""13.txt"" ""12.txt"" ""2.txt"" ""23.txt""))
*SSS*
Break 21 [92]> (sort *sss* #'string-lessp)
(""1.txt"" ""10.txt"" ""12.txt"" ""13.txt"" ""2.txt"" ""23.txt"")
Break 21 [92]>

Unfortunately, the code above does not work. 
Could someone help me to get a natural sort function?
","
Unfortunately, the code above does not work.

It looks like it worked.  After all, you explicitly asked to sort by string comparison, and according to a string comparison, ""2.txt"" is between ""13.txt"", and ""23.txt"".  If you want to sort numerically, you could use a key function that would read the number from the beginning of the string.  Also, sort is destructive, so you shouldn't use it on literal data (like a quoted list).
At any rate, it's not too hard to cobble together something that will get you the sort of sorting that you're looking for. Here's a definition for a natural-string-lessp function:
(defun natural-string-lessp (a b)
  (multiple-value-bind (ai aend)
      (parse-integer a :junk-allowed t)
    (multiple-value-bind (bi bend)
        (parse-integer b :junk-allowed t)
      (or (and ai
               (or (not bi)
                   (and bi
                        (or (< ai bi)
                            (and (= ai bi)
                                 (string-lessp a b :start1 aend :start2 bend))))))
          (and (not ai)
               (not bi)
               (string-lessp a b))))))

It only handles the leading numbers, and not numbers in the middle of a string, so, e.g., ""a-100-foo.txt"" will still come before ""a-3-foo.txt"", but it might be sufficient for your needs.  Here's an example of its use:
(let ((sss (copy-list '(""1.txt"" ""10.txt"" ""13.txt"" ""12.txt""
                        ""2.txt"" ""23.txt""))))
  (sort sss #'natural-string-lessp))
;=> (""1.txt"" ""2.txt"" ""10.txt"" ""12.txt"" ""13.txt"" ""23.txt"")

The documentation for parse-integer and the keyword arguments for string-lessp may be helpful.
A more robust implementation would figure out how to turn each string into a sequence of strings and numbers, (e.g., ""12.txt"" &rightarrow; (12 "".txt"")) and then sort those lists lexicographically with an ordering among types (e.g., numbers before strings), and with an ordering within each type.
","New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 Break 2 [6]> (FactorialRec ""A"")
Argument must be a number.

It works on my machine. So I think you were passing A but not ""A""?
 An alternate approach:
(require 'cl)

(defun is-useless-buffer (buffer)
  (let ((name (buffer-name buffer)))
    (and (= ?* (aref name 0))
         (not (string-match ""^\\*shell\\*"" name)))))

(defun kill-useless-buffers ()
  (interactive)
  (loop for buffer being the buffers
        do (and (is-useless-buffer buffer) (kill-buffer buffer))))

","To achieve natural sorting in Lisp, you can use the `cl-ppcre` library for regular expression matching or implement a custom comparison function. Here's an example using a custom comparison function that splits each string into numeric and non-numeric parts and compares them accordingly:\n\n```lisp\n(defun natural-lessp (a b)\n  \",0.5428,[[0.23168757]],0.0002915021558275042,0.05155099502161262,0.17886178861788615,0.0544959128065395,0.10298102981029811
"I am trying to parse lisp input to python list. But when I parse the input I get list of strings but I want individual element as int.
Example: When I parse following input: ""(2 (10 (5 11))) (5 6) (4)""
Output: [[['2'], ['10', '5']], [['5'], ['6']], [['4']]]
I use: [[map(int, x) for x in lst] for lst in test] to convert the strings to int but this function will only parse nested list of level 2. But if I have a nested list of more than 2, how should I use it to parse?
I tried pyparsing but I didn't understand it properly.
","If you want to use pyparsing, you could do so without any postprocessing as follows.
import pyparsing as pp

integer = pp.Word(pp.nums).setParseAction(lambda m:int(m[0]))
expr = pp.Forward()
expr << pp.nestedExpr(content=pp.OneOrMore(integer | expr))
manyExpr = pp.OneOrMore(expr)

print manyExpr.parseString('(2 (10 (5 11))) (5 6) (4)')
    #returns [[2, [10, [5, 11]]], [5, 6], [4]]

This first defines an integer as something consisting only of numbers, and tells pyparsing how to convert it from a string of numbers to an integer object.  Next, it makes defines an expression as a list of expressions or integers inside parentheses.  Finally, in order to parse your example, it looks for many consecutive expressions.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 Use with-input-from-string. 
(with-input-from-string (s ""4 3 2"")
  (let ((a (read s))
        (b (read s))
        (c (read s)))
    (format t ""~a, ~a, ~a~%"" a b c))) 

You could also just read from a file, but reading from a string is much easier for making different test cases.
 Here you go: First using coerce to convert the string to a list of characters, then mapcar to convert each character to a string.
(defun get-line ()
    (setf text (mapcar 'string (coerce (string (read)) 'list))))

","To handle parsing a deeply nested Lisp-like structure into Python lists where elements are converted to integers, you can use recursion. The `ast` module in Python provides a safe way to parse expressions and convert them into a tree of `Node` objects which can be traversed recursively for processing.

Here's an example of how you might achieve this:

```python
import ast

def parse_lisp_to_int(lisp_expr):
    def convert(node):
        if isinstance(node, ast.Str):
            return int(node.s)
        elif isinstance(node, ast.List):
            return [convert(e) for e in node.elts]
        else:
            raise ValueError(f",0.5697,[[0.13350492]],0.11204458990026174,0.30013384847774405,0.2672811059907834,0.009302325581395347,0.10138248847926266
"What is the Lisp convention about how many semicolons to use for different kinds of comments (and what the level of indentation for various numbers of semicolons should be)?  
Also, is there any convention about when to use semicolon comments and when to use #|multiline comments|# (assuming they exist and exist on multiple implementations)?
","In Common Lisp:
;;;; At the top of source files

;;; Comments at the beginning of the line

(defun test (a &optional b)
  ;; Commends indented along with code
  (do-something a)                      ; Comments indented at column 40, or the last
  (do-something-else b))                ; column + 1 space if line exceeds 38 columns

Note: Emacs doesn't fontify #| |# very well, but as Rainer suggests in the comments, try using #|| ||# instead.
I'd say there are no rules to use this one, but I reckon it's faster for commenting huge amounts of code, or to insert some long description where the semicolons just get in the way of editing, like huge BNF listings or the like.
There's a neat trick to disable code which is to prefix an expression with #+(or):
(defun test (a &optional b)
  #+(or)
  (do-something a)
  (do-something-else b))

Note: #+nil usually works too, unless you happen to have a nil or :nil feature.  The advantage of #+(or) is that you can edit it easily by either commenting it out or change it to #+(and), or to actually include a set of features upon which you really want that expression to be read.
SLIME helps here by fontifying the form (do-something a) as a comment when you have a Lisp running.
Apart from Common Lisp's particular commenting syntax and tricks, such as #| |# and #+(or) or the more commonly seen #+nil, I believe the semicolon rules are widely adopted in other lisps too.

Here's an excerpt from the specification, note how current practice has diverged regarding the single semicolon:

2.4.4.2 Notes about Style for Semicolon
Some text editors make assumptions about desired indentation based on the number of semicolons that begin a comment. The following style conventions are common, although not by any means universal.
2.4.4.2.1 Use of Single Semicolon
Comments that begin with a single semicolon are all aligned to the same column at the right (sometimes called the “comment column”). The text of such a comment generally applies only to the line on which it appears. Occasionally two or three contain a single sentence together; this is sometimes indicated by indenting all but the first with an additional space (after the semicolon).
2.4.4.2.2 Use of Double Semicolon
Comments that begin with a double semicolon are all aligned to the same level of indentation as a form would be at that same position in the code. The text of such a comment usually describes the state of the program at the point where the comment occurs, the code which follows the comment, or both.
2.4.4.2.3 Use of Triple Semicolon
Comments that begin with a triple semicolon are all aligned to the left margin. Usually they are used prior to a definition or set of definitions, rather than within a definition.
2.4.4.2.4 Use of Quadruple Semicolon
Comments that begin with a quadruple semicolon are all aligned to the left margin, and generally contain only a short piece of text that serve as a title for the code which follows, and might be used in the header or footer of a program that prepares code for presentation as a hardcopy document.
2.4.4.2.5 Examples of Style for Semicolon
;;;; Math Utilities

;;; FIB computes the the Fibonacci function in the traditional
;;; recursive way.

(defun fib (n)
  (check-type n integer)
  ;; At this point we're sure we have an integer argument.
  ;; Now we can get down to some serious computation.
  (cond ((< n 0)
         ;; Hey, this is just supposed to be a simple example.
         ;; Did you really expect me to handle the general case?
         (error ""FIB got ~D as an argument."" n))
        ((< n 2) n)             ;fib[0]=0 and fib[1]=1
        ;; The cheap cases didn't work.
        ;; Nothing more to do but recurse.
        (t (+ (fib (- n 1))     ;The traditional formula
              (fib (- n 2)))))) ; is fib[n-1]+fib[n-2].


","
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 Parenscript will automatically convert from the lisp naming convention (dashes separating words) to CamelCase, so:
(parenscript:ps 
 (slot-value ($ ""#mytextarea"") 'selection-start))

results in
""$('#mytextarea').selectionStart;""

 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
","In Common Lisp, there is no strict convention about how many semicolons to use for different kinds of comments. Generally, a single semicolon (;) is used for inline comments, which extend to the end of the line. For multiline comments, CL implementations often provide the #| ...|# syntax, although this is not universally available across all Common Lisp systems. When using #| ...|#, it is common practice to use it for more extensive comments or documentation blocks that span multiple lines. There are no specific indentation guidelines associated with semicolons; however, maintaining consistent indentation (usually two spaces or four spaces) can improve code readability.",0.5246,[[0.44152483]],0.0006686995060182754,0.07003370723611378,0.1863517060367454,0.0368421052631579,0.09186351706036745
"I just started learning Lisp and I am having trouble understanding what this code from Rosetta Code says:

(defun pascal (n)
   (genrow n '(1)))

(defun genrow (n l)
   (when (< 0 n)   //is the command ""when"" something like if in Java?
       (print l)
       (genrow (1- n) (cons 1 (newrow l)))))

(defun newrow (l)
   (if (> 2 (length l))
      '(1)
      (cons (+ (car l) (cadr l)) (newrow (cdr l)))))

I've been looking at some websites about lisp but it still confusing. The only programming language I know is Java. If someone could please explain in Java what the bold parts say, I would be grateful.
","Lisp uses prefix notation because things that are usually operators (ie +, -, >) in other languages are considered functions in Lisp.  (+ 1 1) in Lisp is equivalent to 1 + 1; in Java.  You could think of it as calling an add function with 1 and 1 as arguments: add(1, 1)  It just takes some getting used to.
So (> 2 (length l)) is equivalent to to 2 > length(l)
The ' in '(1) tells Lisp to treat what follows as a literal.  So instead of Lisp looking for a function called 1 (which is what would happen without the backtick) it returns a list containing 1 as an element.  An equivalent way of saying that in Lisp is (quote (1)) which returns the literal list containing 1.
","Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

","Certainly! Let's break down the Lisp code into simpler terms using Java concepts.\n\n### Function `pascal`\nThis function generates a row of Pascal's Triangle and returns it as a list. Here’s how you can understand it in Java:\n\n```java\npublic List<Integer> pascal(int n) {\n    return genrow(n, Arrays.asList(1));\n}\n```\n\n### Function `genrow`\nThis function recursively generates rows of Pascal's Triangle until the specified row number is reached. Here’s a Java equivalent:\n\n```java\npublic void genrow(int n, List<Integer> l) {\n    if (n > 0) {\n        System.out.println(l); // Print the current row\n        genrow(n - 1, cons(1, newrow(l))); // Recursively call with updated parameters\n    }\n}\n```\n\n### Function `newrow`\nThis function generates a new row based on the previous row. Here’s how you can understand it in Java:\n\n```java\npublic List<Integer> newrow(List<Integer> l) {\n    if (l.size() < 2) {\n        return Arrays.asList(1); // If the list has less than two elements, return [1]\n    } else {\n        int first = l.get(0), second = l.get(1);\n        List<Integer> newRow = new ArrayList<>();\n        newRow.add(first + second); // Add the sum of the first and second elements\n        newRow.addAll(newrow(l.subList(1, l.size()))); // Recursively call with the rest of the list\n        return newRow;\n    }\n}\n```\n\n### Explanation of Key Terms\n- **`when` in Lisp is similar to `if` in Java.**\n- **`cons` in Lisp constructs a new cons cell, which is like creating a new pair `(first, rest)` in Java.** For example, `cons(1, l)` creates a list with 1 as the first element and `l` as the rest.\n\nI hope this helps clarify the code for you!",0.5384,[[0.31519229]],0.08935658248140753,0.3469624227753316,0.28841607565011823,0.047505938242280284,0.14184397163120568
"How to apply changes to emacs .el files?
I've done the following:

# locate buff-menu

/usr/share/emacs/22.1/lisp/buff-menu.el.gz
/usr/share/emacs/22.1/lisp/buff-menu.elc

Modify /usr/share/emacs/22.1/lisp/buff-menu.el.gz - add some custom letters in Buffer-menu-select doc section.
# rm /usr/share/emacs/22.1/lisp/buff-menu.elc
Byte compile /usr/share/emacs/22.1/lisp/buff-menu.el.gz

Start emacs and see old description for Buffer-menu-select
","We could more easily answer you if you tell us what exactly you want
to do. The fact is the correct way to customize Emacs is never to
change the .el in Emacs system libraries.

to change a defun you can:

use an advice (look at the documentation of defadvice)
use a new defun that you will eval in an eval-after-load
(eval-after-load 'buff-menu
   '(defun Buffer-menu-mark ()
       ""do nothing""
       (interactive)))


to add a key binding you can again use eval-after-load:
    (eval-after-load 'buff-menu
       '(define-key Buffer-menu-mode-map ""M"" 'Buffer-menu-mark))


","Well, the answer is a bit more obvious than anticipated. The last argument that can be passed into getfiled will change the File Explorer from ""Open"" to ""Save As.""
;; Opens exsisting file
(getfiled ""Title"" ""test.txt"" """" 0)

;; Saves file
(getfiled ""Title"" ""test.txt"" """" 1)

Reference 1: help.solidworks.com
Reference 2: help.autodesk.com
Reference 3: docs.autodesk.com
 This is described in the manual (first hit on Google for ""emacs add-hook""):
(add-hook 'prog-mode-hook (lambda () (foo ""foobarbaz"")))

 We could more easily answer you if you tell us what exactly you want
to do. The fact is the correct way to customize Emacs is never to
change the .el in Emacs system libraries.

to change a defun you can:

use an advice (look at the documentation of defadvice)
use a new defun that you will eval in an eval-after-load
(eval-after-load 'buff-menu
   '(defun Buffer-menu-mark ()
       ""do nothing""
       (interactive)))


to add a key binding you can again use eval-after-load:
    (eval-after-load 'buff-menu
       '(define-key Buffer-menu-mode-map ""M"" 'Buffer-menu-mark))


 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 Set the -show (:show) option of the entry to the placeholder character you want. You can do it during widget creation:
(make-instance 'ltk:entry ...... :show ""*"")

or later:
(ltk:configure my-entry :show ""*"")

 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

","Modifying Emacs .el files directly is generally not recommended because changes might be overwritten when updating Emacs. Instead, you should customize your settings using hooks or advice. For example, to change the documentation of `Buffer-menu-select`, you can use `add-to-list` to modify the docstring without altering the original source file. Alternatively, you can define a new function that calls the original one and sets the desired description.",0.5323,[[0.36031413]],0.11436498286751384,0.20743639921722115,0.36046511627906974,0.10588235294117646,0.18604651162790697
"I have the following code
(defmacro popm(l)
`(prog1 (car ,l)
    (setf ,l (cdr ,l))))

which is supposed to pop the first element out of the list. However, I don't know how to call the macro. I tried using (popm (2 3 4)) but I get the error ""EVAL: 2 is not a function name; try using a symbol instead"". Can anyone point me in the right direction?
","The correct way to debug macros is to use macroexpand-1:
(macroexpand-1 '(popm (1 2 3)))
(PROG1 (CAR (1 2 3)) (SETF (1 2 3) (CDR (1 2 3))))

Now it should be clear why your macro does not work: it cannot be used with constant objects.
It does work with variables though:
(defparameter a '(1 2 3))
(popm a)
==> 1
a
==> (2 3)

","There is no such built-in operator that I am aware of, but I think that you can get this functionality quite quickly:
(defmacro assoc-pop (key alist)
  `(let ((result (assoc ,key ,alist)))
     (setq ,alist (delete result ,alist))
     result))

 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Your symbol is actually all uppercase, because the reader already upcases it.  In order to prevent that, you can either use a different readtable-case or escape the symbol, using either enclosing pipe symbols: '|aAbB| or a backslash for the next character: '\aA\bB.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
","To call the macro `popm`, you need to use it with a symbol that represents the list. The correct syntax would be `(popm lst)` where `lst` is a variable or a symbol representing your list. For example, if you define `lst` as `(2 3 4)`, then you should call the macro like this: `(popm lst)`. Here’s how you can do it:\n\n```lisp\n(defmacro popm (l)\n  `(prog1 (car ,l)\n     (setf ,l (cdr ,l))))\n\n(let ((lst '(2 3 4))) ; Define the list\n  (popm lst)            ; Call the macro with the symbol `lst`\n  lst)                  ; The result is now `(3 4)`\n```\nThis will correctly pop the first element from the list and return it.",0.578,[[0.26493629]],0.08515068184236894,0.3519740192654677,0.34594594594594597,0.054644808743169404,0.17297297297297298
"My next project is writing a hangman game. I figured it would help me brush up on strings and file I/O.
Currently, i'm stuck on reading in a file of strings into a list. I'm trying to avoid global variables, so could someone point me in the right direction to make this (probably broken) code into a function that returns a list?
(defun read-word-list ()
  ""Returns a list of words read in from a file.""
  (let ((word-list (make-array 0 
                 :adjustable t
                 :fill-pointer 0)))
       (with-open-file (stream #p""wordlist.txt"")
     (loop for line = (read-line stream)
        while line
          (push line word-list)))
       (select-target-word word-list)))))

","You can read-in the words as Lisp symbols, with just a few lines of code:
(defun read-words (file-name)
    (with-open-file (stream file-name)
      (loop while (peek-char nil stream nil nil)
           collect (read stream))))

Example input file - words.txt:
attack attempt attention attraction authority automatic awake 
bright broken brother brown brush bucket building 
comfort committee common company comparison competition

Reading the file:
> (read-words ""words.txt"")
=> (ATTACK ATTEMPT ATTENTION ATTRACTION AUTHORITY AUTOMATIC AWAKE BRIGHT BROKEN BROTHER BROWN BRUSH BUCKET BUILDING COMFORT COMMITTEE COMMON COMPANY COMPARISON COMPETITION)

The case could be preserved by enclosing the symbols in pipes (|) or declaring them as strings:
|attack| ""attempt"" ...

Reading without losing case:
> (read-words ""words.txt"")
=> (|attack| ""attempt"" ...)

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 (with-open-file (in ""filename.txt"")
  (with-output-to-string (out)
    (loop :for line := (read-line in nil) :while line :do
       (write-line line out)))))

 Use read
The simplest option is to ask the user to enter the list (with the parens) and just call (read).
The second option is to put the parens yourself:
(read-from-string (concatenate 'string ""("" (read-line) "")""))

safety and security
Note that the power of the Lisp reader can put you in trouble. E.g., if the user types #.(start-ww3) instead of (1 2 3) at your prompt, you might not reach your bomb shelter in time.
This means that you must bind *read-eval* to nil when calling read on text you do not control.
Call parse-integer repeatedly
Finally, you can call parse-integer in a loop
(defun parse-integers (s &optional (start 0))
  (loop with num do 
    (setf (values num start) (parse-integer s :start start :junk-allowed t))
    while num collect num))

or recursively:
(defun parse-integers (s &optional (start 0))
  (multiple-value-bind (num end) 
      (parse-integer s :start start :junk-allowed t)
    (and num (cons num (parse-integers s end)))))

 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 read-char will return the next available character, and read-line will return an entire line of input as a string. You can use coerce to change a string to a list of characters, e.g.
(coerce ""foo"" 'list) => (#\f #\o #\o)

 Use with-input-from-string. 
(with-input-from-string (s ""4 3 2"")
  (let ((a (read s))
        (b (read s))
        (c (read s)))
    (format t ""~a, ~a, ~a~%"" a b c))) 

You could also just read from a file, but reading from a string is much easier for making different test cases.
","Your current approach is on the right track. However, you can improve it by ensuring that the file path is passed as an argument and using read-line or read-from-string for reading each line from the file. Here's a revised version of your function that reads words from a file into a list without using global variables:\n\n```lisp\n(defun read-word-list (file-path)\n  \",0.5319,[[0.23505863]],0.04883901423211553,0.18210627295734122,0.2751322751322751,0.053475935828877004,0.14814814814814817
"I'm fond of Lisp, but one of the thing I find irksome about it is that it nests too much.
In an imperative programming language, I can break a long expression by using an intermediate value, for instance:
int x = someFunctionCall() ? someOtherFunctionCall() : 42;
int y = myUnterminableNameFunction(x);

instead of
int x = myUnterminableNameFunction(someFunctionCall() ? someOtherFunctionCall() : 42);

This can be done in Lisp too, but as far as I'm aware, only by using let. let introduces an additional level of nesting, which I'd rather avoid.
I'm not looking to argue that opinion, but to find a way to declare local variable in a single, non-nesting function/macro call. Something like declare_local in the following:
(defun my_function (a b)
   (declare_local x (if (some_function_call) (some_other_function_call) 42))
   (my_unterminable_name_function x))

If it does not exist, can it maybe be implemented via a clever macro, without it being detrimental to performances?
","Here's a proof of concept macro that pulls variable declarations from a flat list up into standard let* forms.
(defun my/vardecl-p (x)
  ""Return true if X is a (VAR NAME VALUE) form.""
  (and (listp x)
       (> (length x) 1)
       (eq 'var (car x))))

(defmacro my/defun (name args &rest body)
  ""Special form of DEFUN with a flatter format for LET vars""
  (let ((vardecls (mapcar #'cdr
                          (remove-if-not #'my/vardecl-p body)))
        (realbody (remove-if #'my/vardecl-p body)))
    `(defun ,name ,args
       (let* ,vardecls
         ,@realbody))))

Example:
(my/defun foo (a b)
  (var x 2)
  (var y 3)
  (* x y a b))

(foo 4 5)
; => 120

","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 ? (defun foo (a b) (+ a 2))
;Compiler warnings :
;   In FOO: Unused lexical variable B
FOO

? (defun foo (a b)
    (declare (ignore b))
    (+ a 2))
FOO

 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 In my Emacs, function kill-sexp is bound to C-M-k. That is, assuming the point is just before an opening delimiter of a balanced expression, press Control, Meta, and k at the same time.
This same command works in various other non-Lisp modes, such as killing brace-delimited blocks in a C-style mode, though the kill-sexp command may not be bound to the same keys.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

","In Lisp, you can achieve this by using `let` or `let*` for local variable declaration. While it might seem that these introduce additional nesting, they are the idiomatic way to declare local variables in a function. However, if you want to avoid deep nesting and still have a more functional style, you could consider using higher-order functions like `apply` or `funcall`. Here's an example of how you might structure your code without nested let bindings by using `apply` and a helper function.",0.4456,[[0.08834773]],0.02355310987806428,0.1482701812191104,0.1675392670157068,0.021164021164021163,0.0837696335078534
"I really want to learn Scheme macros. I glanced over the content of ""On Lisp"" and a lot of the chapters have been devoted to Lisp macros. However I do not know common lisp. Can I use it to learn Scheme Macros?
","Scheme macros (""hygienic macros"") are completely different from traditional Lisp macros. Some implementations of Scheme offer Lisp macros in addition to Scheme macros, but this is not required by the Scheme standard.
I would recommend you look for instructional materials specific to Scheme macros if you would like to learn about that style of macro. Google shows many pages offering an introduction to Scheme macros.
","The Chairman of R7RS Small Language (""Working Group 1"") committee, Alex Shinn, created Chibi Scheme as the standard evolved. I believe it is fully compliant. It is a bytecode compiler.
Larceny has a mostly (totally?) compliant R7RS mode, and compiles to machine code.
I have been playing with Picrin which aims for R7RS compliance, and is very very close. It is a bytecode compiler.
A list of implementations that are aiming for R7RS compliance at the committee's wiki include: 

Chibi 
Chicken   (partial)
Foment    
Gauche    
Guile (partial)
Husk  
Kawa  
Larceny   
Mosh  (partial)
Picrin    
Sagittarius

 Use MIT Scheme.
It's recommended by the authors of SICP, and is used at MIT for the 6.001: Structure and Interpretation of Computer Programs course.
 If you haven't programmed before in Scheme, then start with the easier books. Sorted from easier to harder:

The Little Schemer
Simply Scheme
SICP

For any of them, it helps to have a decent mathematical and logical intuition, and a lot of curiosity and motivation to learn by yourself.
 My elisp is a bit rusty, but until someone comes up with the actual explanation:  I could get your examples to work a bit more as expected my replacing cmd with (eval cmd) (possibly same with name) in the macro definition body.
Hope this helps.
 I do not know about the third edition, but the early ones were Scheme around R4RS.  There is also the slightly newer translation ""The Little Schemer'. I'm pretty sure that most of the code should run fine in any modern scheme.  I'd suggest Racket (AKA PLT Scheme) as it is at constructed by a team led by Matthias Felleisen.
Edit:
Looking at the dates, it was in a pre-standardization version of Scheme.
 Every implementation tends to focus on something different.  Racket emphasizes its large libraries as ""batteries included"", while Ikarus Scheme touts itself as compiling fast code.  You should examine implementations based on what you want.  If you're just learning Scheme, DrRacket is a good choice with its friendly interface and specific environments for various Scheme books.
Also, you probably don't need to find a R6RS implementation, when most implementations target R5RS and most textbooks were written for R5RS and earlier.
Since you're looking to learn Scheme, I recommend The Little Schemer as an introduction to thinking using Scheme's lists and recursion.
","Yes, you can use your knowledge of Common Lisp macros to understand Scheme macros. While there are differences between the two languages, the fundamental concepts and techniques used in macros are quite similar. Many of the principles you learn from 'On Lisp' will be applicable to Scheme macros as well. However, it's beneficial to consult specific resources on Scheme macros, such as \",0.5817,[[0.51377711]],0.25395999953457155,0.36304870843629006,0.39062500000000006,0.09523809523809523,0.21875000000000003
"I am trying to write a program in Scheme that reverses a given number. However, the problem is that although I have got my recursion right, Scheme is saying that the number of arguments to my recursive call is not correct.
What is wrong in this code? Why do I get the error of wrong arguments?
(define (rev revs n)
    (cond ( (= n 0) 1)
        (else ( 
            (rev ( ( + (* revs 10) (remainder n 10) ) (quotient n 10) ) ) 
            ) )))

","You have a couple of erroneous parentheses, and the base case is wrong (you have to return the accumulator). Try this:
(define (rev revs n)
  (cond ((= n 0) revs)
        (else 
         (rev (+ (* revs 10) (remainder n 10)) (quotient n 10)))))

Remember, in Scheme parentheses mean ""function application, if you surround something with () the interpreter will try to apply what's inside as a function. Be very, very careful where you put those ().
","You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 The easiest way is to reverse the result:
(defun pozpar (lst)
  (do ((l lst (cddr l))
       (x '() (cons (car l) x)))
      ((null l)
       (nreverse x))))

(pozpar '(1 2 3 4 5))
==> (1 3 5)

Notes

This returns, not outputs the value you want.
Prepending values and reverting the result is a common Lisp coding pattern.
Since append is linear in the length of its argument, using it in a loop produces quadratic code.
I formatted the code in the standard Lisp way. If you use this style, lispers will have an easier time reading your code, and, consequently, more willing to help you.

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You are on the right track, but your last two conditions have the same action, which should give an indication that one of them is not doing what it should. Indeed, the second condition, the listp case, is not right, because when it's a list, you need to append the reverse of that list instead of the unmodified list. A possible solution:
(defun my-reverse (l)
  (cond ((null l) nil)
        ((listp (car l)) (append (my-reverse (cdr l)) 
                                 (list (my-reverse (car l)))))
        (t
          (append (my-reverse (cdr l)) 
                  (list (car l))))))

>  (my-reverse '((1 2 3) (4 5 6)))
((6 5 4) (3 2 1))

As you can see, the only difference is that you test if the first element is a list, and if it is, you reverse the first element before appending it.
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
","The issue with your code lies in the recursive call. You are passing two arguments to the `rev` function inside the recursive call, but you have defined it to take only two parameters: `revs` and `n`. To fix this, you need to adjust how you pass the parameters. Additionally, there is no need for the inner parentheses around `( + (* revs 10) (remainder n 10) )`. Here's a corrected version of your function:\n\n```scheme\n(define (rev revs n)\n    (cond ((= n 0) revs)\n          (else (rev (+ (* revs 10) (remainder n 10)) (quotient n 10)))))\n```\nWith this correction, the function should work as intended.",0.6722,[[0.55206102]],0.368379360292307,0.4330422172579607,0.4772727272727273,0.1954022988505747,0.29545454545454547
"I'm learning lisp and have a question about a simple list:
(setq stuff '(one two three (+ 2 2)))
stuff ; prints ""one two three (+ 2 2)""

(setq stuff (list `one `two `three (+ 2 2)))
stuff ; prints ""one two three 4""

The first setq creates a list ""one two three (+ 2 2)"".  The second list creates ""one two three 4"".  Why does the first list not evaluate the (+ 2 2), but the second one does?  I read in the Emacs Lisp intro documentation that when the list is built that it evaluates from the inside out.  Why doesn't the first list evaluate the addition before adding it to the list?
This is elisp in emacs 24.
","' is not equivalent to list, it's shorthand for quote. You're really doing this:
(setq stuff (quote (one two three (+ 2 2))))

The argument to quote is the expression (one two three (+ 2 2)).
From http://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html: ""The special form quote returns its single argument, as written, without evaluating it"".
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 As mentioned in first comment it is necessarily to use (list a b c) form.
 A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

","In Lisp, including Emacs Lisp, the first form `(setq stuff '(one two three (+ 2 2)))` creates a list with the exact elements provided. The expression `(+ 2 2)` is not evaluated because it is treated as a symbol in this context, and lists are constructed by quoting their contents using parentheses `'`. When you use `(list ...)` in the second form, each element inside the list is evaluated before being added to the new list. This is why `(+ 2 2)` evaluates to `4` in the resulting list.",0.5738,[[0.33932138]],0.2021073016480792,0.35682160694094783,0.3724137931034483,0.11188811188811189,0.2206896551724138
"This happened:
 CL-USER> (/4 5.)
Invoking restart: Retry applying /4 to (5).
Invoking restart: Reset this thread
; Evaluation aborted on #<CCL::UNDEFINED-FUNCTION-CALL #x302000B0B6AD>.
CL-USER> (/ 4 5.)

sljk

No matter what I type, the CL-USER> prompt does not return. Obviously, I had a typo and didn't include a space after the / which gave me the error screen (what's that REPL screen called?). I must have chosen an option that was one of the abort options, but while it gave me the CL-USER> prompt right after that, it is somewhat ""inactive"" as you can see here.
How to exit out of this situation?
","This happens to me when I manage to fry the underlying Lisp instance. Alternatively, if I manage to kill the thread that SLIME is interactive with... that also damages the instance.
Check the *inferior-lisp* buffer for clues; if it's hung, M-x slime-restart-inferior-lisp will restart your underlying Common Lisp.
","CL-USER 52 > (remove 0 '((5 ((2 x)))
                         (3 ((1 y)))
                         (0 ((2 x))))
                     :key #'first)
((5 ((2 X))) (3 ((1 Y))))

 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 CL-USER> (mapcar #'caddr *jack*)
(FRUIT FRUIT AGENT AGENT)

EDIT: If you want to practise your recursive approach, try:
(defun attempt (list-of-lists)
    (if (null list-of-lists) nil
        (cons (third (car list-of-lists))
              (attempt (cdr list-of-lists)))))

EDIT2: Tail-recursively:
(defun attempt-tail (list-of-lists)
    (labels ((iter (rest ans)
               (if (null rest) (nreverse ans)
                   (iter (cdr rest) (push (third (car rest)) ans)))))
      (iter list-of-lists nil)))

EDIT3: While I'm at it, here's the loop version:
(loop for list in *jack* collect (third list))

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 CL-USER 15 > (reduce #'union '((a b c) (a d)))
(D A B C)

","It sounds like you encountered an issue where the Lisp environment was not properly handling your input. This could be due to a typo or some other error that caused the REPL (Read-Eval-Print Loop) to get into an undefined state. Here are steps to try and resolve this situation:

1. **Restart the Lisp Environment**: The simplest way is to restart your Lisp session. In many Common Lisp implementations, you can use `:RESTART` or a similar command from the debugger menu to exit the current thread and return to the main prompt.

2. **Use the Debugger**: If restarting doesn't work, you might need to step into the debugger. In SBCL (Steel Bank Common Lisp), for example, you can type `(sb-ext:quit)` to exit the session or use `(sb-ext:exit)` if you just want to quit the current session.

3. **Check for Undefined Functions**: Ensure that all functions and variables used are correctly defined before evaluation. For instance, in your case, `/` is a valid function name, but make sure there isn't an issue with how it's being called or any other part of your codebase.

4. **Consult Documentation**: If you're using a specific implementation like SBCL, CLISP, or Allegro CL, refer to the documentation for more detailed guidance on handling errors and exiting the environment.
",0.5388,[[0.40899191]],0.051113076282684036,0.2943867425784811,0.20363636363636362,0.021978021978021976,0.11636363636363636
"I'm using OpenMCL on Darwin, and I'd like to do something like:
(loop for f in (directory ""somedir"")
  collect (some-per-file-processing f))

But I can't get directory to return anything other than NIL, and I can't seem to find any good explanation online (other than ""its different for each system"").
Any pointers?
","Does your pathname specification contain a wildcard? Common Lisp's pathname stuff is somewhat hard to grasp at first - at least for me it was... As the CLHS states on the directory function:

If the pathspec is not wild, the
  resulting list will contain either
  zero or one elements.

In order to have your pathname include a wildcard, you might try the make-pathname function, like
(directory (make-pathname :directory '(:absolute ""srv"" ""hunchentoot"") :name :wild :type ""lisp""))

Or even
(directory (make-pathname :directory '(:absolute ""srv"" ""hunchentoot"") :name :wild :type :wild))

I found the CL-FAD library a great help for dealing with pathnames and the file system. In particular, its list-directory function might be easier to use than the plain standard directory function.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","The issue you are encountering might be due to the way directory paths and file handling work on Darwin with OpenMCL. On Unix-like systems, including Darwin, the `directory` function typically returns a list of matching filenames in the current directory by default if no path is specified. However, it seems that specifying an absolute or relative path correctly can help. Try using the following approach to ensure you are listing files from the desired directory:\n\n```lisp\n(loop for f in (directory \",0.5372,[[0.42304556]],0.06907590640584631,0.23675656387124833,0.3732057416267942,0.028985507246376812,0.1626794258373206
"I am new to Scheme, and I am learning SICP now. I write some code for Exercise 2.20, to return a list whose element shares the same parity with the first one:
(define (same-parity first . rest)
    (define (same-parity-iter ret rest)
        (if (null? rest)
            ret
            ((if (odd? (+ first (car rest)))
                 (same-parity-iter ret (cdr rest))
             (same-parity-iter (append ret (list (car rest))) (cdr rest))))))
    (same-parity-iter (list first) (cdr rest)))

and run it with some example:
(same-parity 1 2 3 4 5)

then there is the error:
The object (1 3 5) is not applicable.

Do you know how to fix this error? I guess it treats the return value (1 3 5) as a function, but have no idea how to fix it. Thank you.
","There is a ( too much in your code. Have a look at the second if:
((if (odd? (+ first (car rest)))
     (same-parity-iter ret (cdr rest))
     (same-parity-iter (append ret (list (car rest))) (cdr rest)))))

Basically, you are telling the interpreter (or compiler): take the result of the 
(if (odd? (+ first (car rest)))
     (same-parity-iter ...)
     (same-parity-iter ...))

and apply it as a function. The result is a list of integers, which is not a function -- hence the error. Change the code to
(define (same-parity first . rest)
  (define (same-parity-iter ret rest)
    (if (null? rest)
        ret
        (if (odd? (+ first (car rest)))
            (same-parity-iter ret (cdr rest))
            (same-parity-iter (append ret (list (car rest))) (cdr rest)))))
    (same-parity-iter (list first) (cdr rest)))

","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You are on the right track, but your last two conditions have the same action, which should give an indication that one of them is not doing what it should. Indeed, the second condition, the listp case, is not right, because when it's a list, you need to append the reverse of that list instead of the unmodified list. A possible solution:
(defun my-reverse (l)
  (cond ((null l) nil)
        ((listp (car l)) (append (my-reverse (cdr l)) 
                                 (list (my-reverse (car l)))))
        (t
          (append (my-reverse (cdr l)) 
                  (list (car l))))))

>  (my-reverse '((1 2 3) (4 5 6)))
((6 5 4) (3 2 1))

As you can see, the only difference is that you test if the first element is a list, and if it is, you reverse the first element before appending it.
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 Iterate over your list and store each pair's car into a list in an assoc that looks like this:
original: ((2 . 1) (3 . 2) (1 . 2) (5 . 1) (6 . 3))
new:      ((1 . (2 5))
           (2 . (3 1))
           (3 . (6))

Then sum together all the cdrs and flip each pair to get this:
          ((7 . 1) (4 . 2) (6 . 3))

 The easiest way is to reverse the result:
(defun pozpar (lst)
  (do ((l lst (cddr l))
       (x '() (cons (car l) x)))
      ((null l)
       (nreverse x))))

(pozpar '(1 2 3 4 5))
==> (1 3 5)

Notes

This returns, not outputs the value you want.
Prepending values and reverting the result is a common Lisp coding pattern.
Since append is linear in the length of its argument, using it in a loop produces quadratic code.
I formatted the code in the standard Lisp way. If you use this style, lispers will have an easier time reading your code, and, consequently, more willing to help you.

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

","The issue with your code is that you are using `append` inside the recursive call of `(same-parity-iter)`, which is causing the return value to be treated as a function. Instead, you should directly concatenate the list without using `append`. Here's the corrected version of your function:\n\n```scheme\n(define (same-parity first . rest)\n  (define (same-parity-iter ret rest)\n    (if (null? rest)\n        ret\n        (if (odd? (+ first (car rest)))\n            (same-parity-iter (cons (car rest) ret) (cdr rest))\n            (same-parity-iter ret (cdr rest)))))\n  (reverse (same-pararity-iter () (cons first rest))))\n```\n\nNote that I've also added `reverse` at the end to ensure the list is in the correct order. This function will now work as expected.",0.7109,[[0.79636768]],0.43826194856302597,0.4914616075357079,0.5348837209302326,0.26562500000000006,0.40310077519379844
"It seems both 
(mapcar 'car '((foo bar) (foo1 bar1))) 

and 
(mapcar #'car '((foo bar) (foo1 bar1)))

work as the same. 
And I also know ' means (quote symbol) and #' means (function function-name). 
But what's the underlying difference? Why these 2 both work in previous mapcar?
","'foo

evaluates to the symbol FOO.
#'foo

evaluates to the function bound to the name FOO.
In Lisp a symbol can be called as a function when the symbol FOO has a function binding. Here CAR is a symbol that has a function binding.
But this does not work:
(flet ((foo (a) (+ a 42)))
  (mapcar 'foo '(1 2 3 4 5)))

That's because FOO as a symbol does not access the local lexical function and the Lisp system will complain when foo is not a function defined elsewhere.
We need to write:
(flet ((foo (a) (+ a 42)))
  (mapcar #'foo '(1 2 3 4 5)))

Here the (function foo) or its shorthand notation #'foo refers to the lexical local function FOO.
Note also that in
(funcall #'foo ...)

vs.
(funcall 'foo ...)

The later might do one more indirection, since it needs to lookup the function from the symbol, while #'foo denotes the function directly.
Summary:
If a symbol has a function binding, calling a function through the symbol works.    
","One problem is you have your < and > reversed. Assuming you want your left sub tree to be the smaller, then (< value (car tree)) should call again with the (cadr tree).
Also you should use #t instead of (#t).
 I don't understand why your function takes 2 arguments when it's going to rearrange one list.
Your t case is almost correct, but you've practically turned it inside out - it should be
(cons (car x) (Func1 (cdr x)))

That is, a list where the car is the same as in the input, and the cdr is the result of flattening the cdr of the input.
The listp case looks like it's suffering from a similar form of ""inside-out-ness"".
Apart from the inexplicable y you have all the right bits but in the wrong order, except that it needs two Func1 calls - one for the car and one for the cdr.  
I'll leave the rearrangement of the bits in that case as an exercise.
 You can use mapcar for that:
(mapcar #'cons '(a b c) '(1 2 3))
;; ==> ((a . 1) (b . 2) (c . 3))

 What are the similarities? Or, is there another question lurking here?
(Links from elisp, because that is what I know. The quotes are just excerpts and the links contain examples which may or may not be relevant in a particular ""Lisp"".)
mapcar


mapcar is a function that calls its first argument with each element of its second argument, in turn. The second argument must be a sequence. 


apply (in Calling Functions)


apply calls function with arguments, just like funcall but with one difference: the last of arguments is a list of objects, which are passed to function as separate arguments, rather than a single list. We say that apply spreads this list so that each individual element becomes an argument. 


Happy coding.
 In Lisp, a linked list element is called a CONS. It is a data structure with two elements, called the CAR and the CDR for historical reasons. (Some Common Lisp programmers prefer to refer to them using the FIRST and REST functions, while others like CAR and CDR because they fit well with the precomposed versions such as (CADR x) ≡ (CAR (CDR x)).
The joke is a parody of the bumper stickers you sometimes see on beat-up old cars saying ""My other car is a Porsche/BMW/etc.""
My response to this joke has always been ""My other CAR is a CADR. CDR isn't a CAR at all.""
 You need to apply car to every element (sublist) of the main list, using map:
(define (concatenate lst)
  (map car lst))

(concatenate '((""one"" ""two"") (""three"" ""four"") (""five"" ""six"")))
=> '(""one"" ""three"" ""five"")

To print these values each on its own line, use for-each:
(for-each displayln (concatenate '((""one"" ""two"") (""three"" ""four"") (""five"" ""six""))))
=> 
one
three
five

You could also use map instead of for-each, but then you'd get
one
three
five
'(#<void> #<void> #<void>)

The trailing '(#<void> #<void> #<void>) is the result of applying displayln to each value (displayln always returns void). So use map if you care about the result, for-each if you don't.
","Both 'car and #'car work in this context because they serve different purposes but achieve similar outcomes here. The single quote ' before car creates a quoted symbol, meaning that the function call mapcar is passed the symbol car as an argument rather than trying to evaluate it immediately. On the other hand, #'car directly refers to the function object associated with the symbol car, which can then be used by mapcar to operate on each element of the list. In this specific example, both approaches effectively pass the car function to mapcar, so they behave identically. However, using #' is generally preferred in Common Lisp when you want to explicitly reference a function rather than a quoted symbol.",0.5355,[[0.39426114]],0.11802089909060107,0.2380750958181915,0.3368421052631579,0.05653710247349823,0.16842105263157894
"When one is programming in an imperative programming languages such as Java one can conveniently add trace statements. For example:
for (int i=0; i<10; i++) {
  // do something
  // do something
  System.out.println(""Some trace statement"");
  // do something 
}

How does one accomplish this in a LISP dialect such as Clojure - for example say I wanted to add a trace just before recur:
(def fact
  (fn [n]
    (loop [cnt n acc 1]
       (if (zero? cnt)
            acc
          ;; say I want to add a trace here
          (recur (dec cnt) (* acc cnt))))))

Notes:

The method should be relatively as simple as adding a line 
For example if I were to use a do block -- I have to reformat, make sure I close the brackets appropriately

","Non-invasive tracing
Lisp environments generally provide interactive debugging environment and trace mechanisms.
For example, in SBCL, you could use the trace macro:
you don't even need to modify your code, like you did in your Java example.
For Clojure, look at the tools.trace library, or the following answer: clojure: adding a debug trace to every function in a namespace?
Custom functions and macros
See also the many answers to this question: Debugging in Clojure?
Most of them involve nesting the expression you want to debug/trace inside another expression, like Chiron suggested.
I don't think that ""I have to reformat and close the brackets appropriately"" is a good argument; everytime you edit your program you have to deal with the syntax, or else you won't ever modify your code.
Paredit
I personally don't use I am now a happy user of Paredit. Your editor keep track of parens and brackets while you code, which is quite handy. 
Reader macros
I you really don't want to nest your expression inside another one, I suppose you could write a reader macro so that you could annotate an expression with a debug statement, but this is overkill, imho (edit: this is what spyscope does, apparently; see NielsK's answer).
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 As mentioned in first comment it is necessarily to use (list a b c) form.
 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

",Answer not found.,0.3819,[[0.02667073]],8.038195956695831e-35,0.007251631617113851,0.00925925925925926,0.0,0.00925925925925926
"I have no idea if there exists a pattern matching function for Common Lisp, nevertheless I have to make my own function. I have no idea about Lisp. Can somebody give heads-up on learning Lisp and most importantly, how to go about doing pattern matching in Lisp. I will have to pass a pattern and a fact and say if they match.
An example would be
(heroes (hitpoints=hp) (mana=m)) 

should match
(Morphling (hitpoints 435) (mana 260))

it should also be able to also do numeric comparisons of if a number is greater or lesser. Like if another heroes mana is less that Morphling.
","Simple pattern matching functionality is explained in various Lisp books.

Lisp, 3rd edition, Winston/Horn
Paradigms of Artificial Intelligence Programming, Case Studies in Common Lisp, Peter Norvig

and others.
Above books explain implementing pattern matching in Lisp very well.
Libraries exist, for example trivia, cl-match, and various others.
","I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 A simple and robust solution is to use the built-in regexp-opt function, which takes a list of fixed strings and returns an efficient regex to match any one of them. Then all you need to do is split your original string into one-character segments:
(regexp-opt
 (mapcar #'char-to-string
         (string-to-list ""abcdefg. *""))) ; => ""[ *.a-g]""

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You are comparing a list containing 1 & 2 with a list containing the symbols a & b. Symbols are legitimate values in Clojure. '(a b) is equivalent to (list 'a 'b) not (list a b).
 (= '(1 2) (list a b))

Is probably the comparison you want.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 A solution that uses your initial approach is the following:
(defun max-occurrences(l)
  (let* ((occurrences (remove-duplicates 
                        (mapcar #'(lambda (elt) (cons elt (count elt l))) l) 
                        :test 'equal))
         (max-occurrence (reduce #'max occurrences :initial-value 0 :key #'cdr)))
    (mapcar #'car (remove-if-not (lambda(x) (= x max-occurrence)) occurrences :key #'cdr))))

However, this solution is not efficient, since it has a cost of O(n2) (in the initial phase, each element of the list is compared with all the others to count its frequency). 
Edited
A more efficient solution could be obtained for instance by using a hash table (with the improvement suggested in the comment by @uselpa):
(defun max-occurrences(l)
   (let* ((table (make-hash-table))
          (max-count (loop for elt in l maximize (incf (gethash elt table 0)))))
     (loop for elt being the hash-key of table using (hash-value count)
        when (= count max-count) collect elt)))

","In Common Lisp, you can implement pattern matching using higher-order functions and macros. Since there isn't a built-in pattern matching mechanism like in some functional languages (e.g., Haskell), you would need to define your own function or macro to handle this task. Here's an example of how you might approach it:

First, let's consider the pattern matching problem: given a pattern and a fact, determine if they match. The pattern can include simple variables and numeric comparisons.

Here's a simplified version of how you could implement such a function using a recursive approach and EQL for simple value comparison and TYPECASE or CASE for handling different data types (e.g., numbers, symbols).

```lisp
(defun match-pattern (pattern fact)
  ",0.5175,[[0.29564257]],0.08331217929911809,0.3279809194482549,0.22988505747126436,0.05813953488372092,0.11494252873563218
"To insert an item at position 0 in scheme I can do the following:
(define 1-to-3 (cons 1 (cons 2 (cons 3 nil))))
(cons 100 1-to-3)
; (100 1 2 3)

Is there a built-in way to insert an element at the end of a list (i.e., append it to the list)?
","Use append
There is no built-in way to add an item to the end of a list in standard Scheme. If this is something that you really need to do, but infrequently, you can use append:
;;; Using append: linear in the length of the list `xs`.
(define (append-item xs x)
  (append xs (list x)))

> (append-item '(1 2 3 4) 5)
(1 2 3 4 5)

Pick a Better Data Structure
If you need to add a lot of items to the ends of lists, append will become expensive since it has linear time complexity. The specific use case will guide your choices here; if the goal is to build a list from the end instead of from the front then it may be best to cons up the list and reverse it, as discussed by @Sylwester. If instead you need to be able to add and remove elements from both ends of a list, you might consider a double-ended queue. You can roll your own, or you may be able to use a preexisting library such as SRFI 117 or SRFI 134.
There is no way to get the last pair of a list without either walking the list, maintaining an index, or maintaining a pointer to the last pair of the list in Scheme. You can walk a list directly (but have linear time complexity); you can get constant time complexity by maintaining state (e.g., an index or tail pointer). When you start down this path, you will likely want to create some sort of data structure that abstracts the details. A deque is one example of such a data structure, but as @WillNess has observed, that may be more data structure than you need. A simpler data structure could be created, but the details would depend on an actual use case.
Mutation on a List
You can use mutation to add an element to the end of a list, but this is not idiomatic in Scheme, and it is probably a bad idea, anyway. (Although you might find mutation used in an implementation of a deque or similar data structure). You could mutate the last pair in the input list, using set-cdr! to attach a list containing the new element, like this:
;;; Using `set-cdr!`: this is still linear in the length of `xs`, since it
;;; requires `length`.
(define (append-item! xs x)
  (set-cdr! (list-tail xs (- (length xs) 1)) (list x))
  xs)

> (append-item! (list 1 2 3 4) 5)
(1 2 3 4 5)
> (append-item! (list 1 2 3 4) 5)
(1 2 3 4 5)
> (define xs (list 1 2 3 4))
> (append-item! xs 5)
(1 2 3 4 5)
> xs
(1 2 3 4 5)

This is a bad idea because: 1) you should not attempt to modify list literals in Scheme, which means that you have to pay attention to the provenance of lists given to append-item!, and 2) it is linear in the length of its input list anyway.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 When the reader encounters a syntax-quoted form, that turns out to be a collection, it will iterate over each element and call syntax-quote recursively. The result is consed, beginning with nil.
So it comes down to the question why the following holds:
> (list? (cons 'inc nil))
true
> (list? (cons 'inc (cons 1 nil)))
false

This seems to be a matter of definition.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 No, the answer in the book is right. Note that the expression has 3 occurrences of (quote ()), to create 3 lists. Then it conses various atoms onto the lists. Your answer contains 5 lists, not 3.
(quote ()) simply returns an empty list. (cons 1 (quote ())) adds one item to the empty list to yield (1).
 The alternate expression for the 'if' expression is ((set! ...) ...).  The first position needs to be either a function or a syntactic form.  In this case you need progn as:
(progn
  (setq list1 ...)
  (setq list2 ...)
  (eql x y))

",Answer not found.,0.3397,[[0.01134844]],1.1871480835742435e-85,0.002844950213371266,0.00392156862745098,0.0,0.00392156862745098
"We have two ways to define a function: defun and lambda, and we can use setf for labeling a lambda function.
(defun g (x) (* x x)) 
(setf f (lambda (x) (+ x x)))

The function can be the first element in a list.
(g 3)
9

Or it can be a parameter to the other function.
(mapcar #'g '(1 2 3))
(1 4 9)    

However with lambda, the usage is different. 
(funcall f 3)
6

(mapcar f '(1 2 3))
(2 4 6)

I'm curious what's the logic behind the differences? 
It's even more confusing compared with scheme's rather consistent use cases.
> (define (g x) (+ x x))
> (g 3)
6
> (map g '(1 3 4))
(2 6 8)

> (define f (lambda (x) (* x x)))
> (f 2)
4
> (map f '(1 2 3))
(1 4 9)

","See Kent Pitman's paper Technical Issues of Separation in Function Cells and Value Cells
","To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 You need another comma before A in the nested backquote, so it expands to the value of the variable outside the outside the outer backquote. And then it needs to be quoted to keep from evaluating that as a variable. So it becomes ,',A
(defmacro define-access (F A)
  (let ((X (gensym))
        (Y (gensym)))
    `(progn
       (defun ,F (,X)
         (,A ,X))
       (defsetf ,F (,X) (,Y)
         `(setf (,',A ,,X) ,,Y)))))

DEMO
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You don't need eval here; use begin instead to group those definitions together into a list; i.e., the template to be expanded should be of the form:
`(begin 
   ,@(map ...)
   (define ...)
   (define ...)
   ...)

Edit:
Change for-each to map as suggested by OP.
","The differences between using `defun` and `lambda`, along with their interactions with `setf` and functions like `mapcar`, lie in how Lisp treats function definitions and calls. In Common Lisp, `defun` is used to define a named function that can be referenced by name throughout your code. On the other hand, `lambda` creates an anonymous function that is typically used where you need a simple function without naming it explicitly. When using `setf`, you're creating a setter for the lambda function, which allows you to modify its behavior dynamically.

For example, when you use `(defun g (x) (* x x))`, `g` becomes a named function that can be called directly or passed around as needed. Conversely, with `(setf f (lambda (x) (+ x x)))`, you create an anonymous function and assign it to the symbol `f`. The `funcall` function is used to invoke functions dynamically by name, whereas `mapcar` applies a given function to each element of a list.

This contrasts with Scheme's approach where both named and unnamed functions are treated similarly, often leading to more consistent behavior in certain contexts. However, Common Lisp’s flexibility allows for powerful metaprogramming capabilities, such as defining setf expanders, which can be quite useful in complex scenarios.",0.398,[[0.12454636]],0.009254525446317465,0.13386880856760378,0.045662100456620995,0.0,0.0273972602739726
"I define square and sum-of-squares as:
(defun square(x)
  (* x x))
(defun sum-of-squares (x y)
  (+ (square x) (square y)))

then apply it an array with reduce:
(reduce 'sum-of-squares '(2 2 2))

but get result as 68 rather than 12.
What's the problem?
","The reduction does
(sum-of-squares (sum-of-squares 2 2) 2)

which is
    (sum-of-squares 8 2)

which is 64 + 4
You can get the result you expect with
(reduce #'+ (mapcar #'square '(2 2 2)))

or
(reduce #'(lambda (x y) (+ x (square y))) '(2 2 2) :initial-value 0)

or by defining sum-of-squares to take an arbitrary number of arguments.
","(make-hash-table :test #'equal)

 The cut is not used for efficiency, but to commit to the first solution (see the comment next to the !/0: ""single solution: longest input match""). If you comment out the !/0, you get for example:
?- parse(""abc"", E).
E = [s(abc)] ;
E = [s(ab), s(c)] ;
E = [s(a), s(bc)] ;
E = [s(a), s(b), s(c)] ;
false.

It is clear that only the first solution, consisting of the longest sequence of characters that form a token, is desired in such cases. Given the example above, I therefore disagree with ""false"": expression//1 is ambiguous, because number//1 and symbolr//1 are. In Mercury, you could use the determinism declaration cc_nondet to commit to a solution, if any.
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 (remove '(1 2) '((1 2) (1 3)) :test #'equal)

 In the book, authors have an example of formulating an iterative process for computing the Fibonacci numbers.
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))

The point here is that use two parameter a and b to memorise f(n+1) and f(n) during computing. The similar could be applied: we need a, b, c to memorise f(n+2), f(n+1) and f(n)
;; an interative process implementation                                                                                                                       
(define (f-i n)                                                                                                                                               
  ;; f2 is f(n+2), f1 is f(n+1), f0 is f(n)                                                                                                                   
  (define (interative-f f2 f1 f0 count)                                                                                                                       
    (cond                                                                                                                                                     
      ((= count 0) f0)                                                                                                                                         
      (else (interative-f                                                                                                                                      
              (+ f2 (* f1 2) (* f0 3))                                                                                                                          
              f2                                                                                                                                                
              f1                                                                                                                                                
              (- count 1)))))                                                                                                                                   
  (interative-f 2 1 0 n))             

 If order is not important, use the SET-DIFFERENCE function:
(set-difference '(""a"" ""b"" ""c"" ""d"") '(""b"" ""c"") :test #'string=)

","The issue lies in how `reduce` is being used. The `reduce` function applies the binary function (in this case, `sum-of-squares`) cumulatively to the items of the list, from left to right, so as to reduce the list to a single value. However, when you call `(reduce 'sum-of-squares '(2 2 2))`, it first calls `(sum-of-squares 2 2)`, which returns `8`, and then tries to apply `sum-of-squares` again with the result of that (which is now an integer) and the next element in the list, leading to incorrect results. 

To correctly compute the sum of squares for a list of numbers using `reduce`, you should pass the function name as a quoted symbol, not as a bare symbol. The correct way to do it would be:

```lisp
(reduce #'sum-of-squares '(2 2 2))
```

This will first apply `(sum-of-squares 2 2)`, then use the result (8) and the next element in the list, and so on.",0.6022,[[0.52438562]],0.17265849467830932,0.4161118079800623,0.3684210526315789,0.168141592920354,0.23684210526315788
"This recursive definition of a macro does what it should (sum integers from 1 to n):
(defmacro sum-int-seq (n)
  `(cond
     ((equal 0 ,n) 0)
     (t (+ ,n (sum-int-seq (- ,n 1))))))

For example (sum-int-seq 5) gives 15.
But why does it work? When the macro gets expanded i get this:
(macroexpand '(sum-int-seq 5))
(IF (EQUAL 0 5) 0 (+ 5 (SUM-INT-SEQ (- 5 1))))

But because sum-int-seq is a macro the macro evaluation should become an infinite loop. Does the compiler create a recursive function instead? If this definition creates a recursive function is there any way to define macros recursively?
(This is a silly example for the sake of brevity, a function would of course work better for this)
","Your example does not work.
It may work in an interpreter. But with a compiler you'll see an endless loop during compilation.
CL-USER 23 > (defun test (foo)
                (sum-int-seq 5))
TEST

Let's use the LispWorks interpreter:
CL-USER 24 > (test :foo)
15

Let's try to compile the function:
CL-USER 25 > (compile 'test)

Stack overflow (stack size 15997).
  1 (continue) Extend stack by 50%.
  2 Extend stack by 300%.
  3 (abort) Return to level 0.
  4 Return to top loop level 0.

Type :b for backtrace or :c <option number> to proceed.
Type :bug-form ""<subject>"" for a bug report template or :? for other options.

So, now the next question: why does it work in the interpreter, but the compiler can't compile it?
Okay, I'll explain it.
Let's look at the interpreter first.

it sees (sum-int-seq 5).
it macroexpands it to (COND ((EQUAL 0 5) 0) (T (+ 5 (SUM-INT-SEQ (- 5 1))))).
it then evaluates above form. It determines that it needs to compute (+ 5 (SUM-INT-SEQ (- 5 1))). For that it needs to macroexpand (SUM-INT-SEQ (- 5 1)).
eventually it will expand into something like (cond ((EQUAL 0 (- (- (- (- (- 5 1) 1) 1) 1) 1)) 0) .... Which then will return 0 and the computation can use this result and add the other terms to it.

The interpreter takes the code, evaluates what it can and macroexpands if necessary. The generated code is then evaluated or macroexpanded. And so on.
Now let's look at the compiler.

it sees (sum-int-seq 5) and macroexpands it into (COND ((EQUAL 0 5) 0) (T (+ 5 (SUM-INT-SEQ (- 5 1))))).
now the macroexpansion will be done on the subforms, eventually.
the compiler will macroexpand (SUM-INT-SEQ (- 5 1)). note that the code never gets evaluated, only expanded.
the compiler will macroexpand (SUM-INT-SEQ (- (- 5 1) 1)) and so forth. finally you'll see a stack overflow.

The compiler walks (recursively compiles / expands) the code. It may not execute the code (unless it does optimizations or a macro actually evaluates it explicitly).
For a recursive macro you'll need to actually count down. If you eval inside the macro, then something like (sum-int-seq 5) can made work. But for (defun foo (n) (sum-int-seq n)) this is hopeless, since the compiler does not know what the value of n is.
","You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The difference in using the macro vs function is in whether all the choices always are evaluated.
The expanded in macro evaluates the choices sequentially. If it reaches a choice that is eql to the first argument, it returns a true value without evaluating any more
forms.
In contrast, the in-func function will evaluate all the choices at the time the function is called.
 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
 Use the macro CHECK-TYPE:
CL-USER 9 > (let ((n ""10""))
              (check-type n integer))

Error: The value ""10"" of N is not of type INTEGER.

 Macro expansion happens at compile time. Your message indicates that the file that uses the macro was compiled when the macro was not defined, so the compiler assumed that the unknown name my-macro names a function (if you look at the compilation logs, you should see a message to that effect).
Solution: require the file containing macro definitions in files that use them.
","The macro expansion happens at compile time. When you call (sum-int-seq 5), the macro is expanded into an IF form at that point, not during runtime. This IF form is then evaluated normally by Common Lisp, which handles it as a recursive function call but without further macro expansion. The macro definition does not create a recursive function itself; instead, it generates code that defines such a function. Therefore, there's no infinite loop because the generated IF form is fully expanded and can be evaluated recursively by the runtime environment. To define macros recursively, you would need to ensure that the recursion in your macro expansion does not lead to further macro expansions, as demonstrated in this example.",0.5405,[[0.42668952]],0.01476216787594135,0.11816945133157945,0.2661596958174905,0.0534351145038168,0.12547528517110268
"Structure and Interpretation of Computer Programs has the following footnote:

Another way to define the selectors and constructor is
(define make-rat cons)
(define numer car)
(define denom cdr)
The first definition associates the name make-rat with the value of the expression cons, which is the primitive procedure that constructs pairs. Thus make-rat and cons are names for the same primitive constructor.
Defining selectors and constructors in this way is efficient: Instead of make-rat calling cons, make-rat is cons, so there is only one procedure called, not two, when make-rat is called. On the other hand, doing this defeats debugging aids that trace procedure calls or put breakpoints on procedure calls: You may want to watch make-rat being called, but you certainly don't want to watch every call to cons.

Does this advice still apply? For example, are modern debugging aids still defeated in this way?
","Quite often they will be.  For instance imagine some debugger which is trying to print a backtrace in a useful way.  It's going to want to map between the procedure objects sitting in the backtrace and their names.  And that map is either going to point at the 'wrong' name, or it's going to point at all the names and you then have to know which one you actually used.
Here's an example in Racket:
> (object-name cons)
'cons
> (define make-thingy cons)
> (object-name make-thingy)
'cons

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Quite often they will be.  For instance imagine some debugger which is trying to print a backtrace in a useful way.  It's going to want to map between the procedure objects sitting in the backtrace and their names.  And that map is either going to point at the 'wrong' name, or it's going to point at all the names and you then have to know which one you actually used.
Here's an example in Racket:
> (object-name cons)
'cons
> (define make-thingy cons)
> (object-name make-thingy)
'cons

 To turn make-canned-format into a function, you need to replace
function with
compile or
(coerce (lambda ...) 'function).
However, your refactoring is misguided.
make-canned-format should be a macro - this way it will produce
a closure in the current compilation environment.
The function, however, will produce a closure in the global environment.
 TRACE works by redefining the function to something that prints the trace messages and then calls the original function. But you're not normally allowed to redefine built-in functions, so you get this error.
 
This shows normal-order evaluation, because the operands are evaluated before being substituted for parameters

Actually you got it the wrong way around. Applicative order is when the operands are evaluated first. Normal-order is when the arguments are substituted into the expression unevaluated.
So racket uses applicative order because as you said the arguments are evaluated first (unless you use ""Lazy Racket"" in which case it uses call-by-need aka lazy evaluation, which is like normal-order except each argument is evaluated at most once).
","The advice about defining selectors and constructors using primitive procedures like `cons` for `make-rat`, `car` for `numer`, and `cdr` for `denom` still applies in modern Lisp dialects, including Racket. This approach remains efficient because it avoids the overhead of an additional procedure call. However, modern debugging aids may not be entirely defeated. While you won't see a separate trace entry for `make-rat` calling `cons`, you can typically still debug by setting breakpoints or tracing at higher levels. For instance, in Racket, you can use `breakpoint` to pause execution and inspect the call stack, even if individual procedure calls like `cons` are not separately traced.",0.5039,[[0.27648499]],0.08133638463925234,0.30447651903765044,0.29292929292929293,0.02040816326530612,0.101010101010101
"right now I have a keyboard macro defined and named, and i want to make a lisp function which goes to the top of the buffer, and does:
i = 1
do{
    run macro
    if macro hit the end of the buffer, break out of the loop
    insert i
    i++
}while(true)

here's what's in my .emacs
(fset 'next-id
   (lambda (&optional arg) ""Keyboard macro."" (interactive ""p"") (kmacro-exec-ring-item (quote ([19 73 68 61 34 13 67108896 19 34 13 2 23] 0 ""%d"")) arg)))
(global-set-key (kbd ""C-x n"") 'next-id)

how would I go about this?
","This should do the trick:
(defun apply-macro-to-buffer (&optional macro)
  ""Apply last keyboard macro to the buffer""
  (interactive ""CEnter the name of the macro to apply: "")
  (or macro
      (progn
        (if (null last-kbd-macro)
            (error ""No keyboard macro has been defined""))
        (setq macro last-kbd-macro)))
  (let ((end-marker (copy-marker (point-max)))
        (i 1))
    (save-excursion
      (goto-char (point-min))
      (while (and  (< (point) end-marker))
        (let ((mark-active nil))
          (execute-kbd-macro macro))
        (insert (format ""%d\n"" i))
        (setq i (1+ i))))))

To do the same for a regular command, try this:
(defun apply-command-to-buffer (command)
  ""Apply a command to the buffer""
  (interactive ""CEnter the name of the command to apply: "")
  (let ((end-marker (copy-marker (point-max)))
        (i 1))
    (save-excursion
      (goto-char (point-min))
      (while (and  (< (point) end-marker))
        (call-interactively command)
        (insert (format ""%d\n"" i))
        (setq i (1+ i))))))

","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 If that's what you want to do, this will do it:
(global-set-key [(control ?v)]
 (lambda () (interactive (next-line (/ (window-height (selected-window)) 2)))))

 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 You will somehow need to print the whitespace yourself.  Simple extension of your code:
(loop for i from 1 to 5
      do (princ i)
         (princ #\space))

(Note that I used princ instead of prin1.)
","To achieve what you're asking for in Emacs Lisp, you can define a function that simulates a loop by repeatedly calling your keyboard macro until it hits the end of the buffer. Here's how you could do it:\n\n```lisp\n(defun run-macro-loop (macro-key)\n  \",0.5061,[[0.25098057]],0.002459366171318524,0.0659238625812442,0.1909547738693467,0.030456852791878174,0.09045226130653267
"I am studying SICP and wrote two procedures to compute the sum of 1/n^2, the first generating a recursive process and the second generating an iterative process :
(define (sum-rec a b)
  (if (> a b)
      0
      (exact->inexact (+ (/ 1 (* a a)) (sum-rec (1+ a) b)))))

(define (sum-it a b)
  (define (sum_iter a tot)
    (if (> a b)
        tot
        (sum_iter (1+ a) (+ (/ 1 (* a a)) tot))))
  (exact->inexact (sum_iter a 0)))

I tested that both procedures give exactly the same results when called with small values of b, and that the result is approaching $pi^2/6$ as b gets larger, as expected.
But surprisingly, calling (sum-rec 1 250000) is almost instantaneous whereas calling (sum-it 1 250000) takes forever.
Is there an explanation for that? 
","As was mentioned in the comments, sum-it in its present form is adding numbers using exact arithmetic, which is slower than the inexact arithmetic being used in sum-rec. To do an equivalent comparison, this is how you should implement it:
(define (sum-it a b)
  (define (sum_iter a tot)
    (if (> a b)
        tot
        (sum_iter (1+ a) (+ (/ 1.0 (* a a)) tot))))
  (sum_iter a 0))

Notice that replacing the 1 with a 1.0 forces the interpreter to use inexact arithmetic. Now this will return immediately:
(sum-it 1 250000)
=> 1.6449300668562465

","Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 In the book, authors have an example of formulating an iterative process for computing the Fibonacci numbers.
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))

The point here is that use two parameter a and b to memorise f(n+1) and f(n) during computing. The similar could be applied: we need a, b, c to memorise f(n+2), f(n+1) and f(n)
;; an interative process implementation                                                                                                                       
(define (f-i n)                                                                                                                                               
  ;; f2 is f(n+2), f1 is f(n+1), f0 is f(n)                                                                                                                   
  (define (interative-f f2 f1 f0 count)                                                                                                                       
    (cond                                                                                                                                                     
      ((= count 0) f0)                                                                                                                                         
      (else (interative-f                                                                                                                                      
              (+ f2 (* f1 2) (* f0 3))                                                                                                                          
              f2                                                                                                                                                
              f1                                                                                                                                                
              (- count 1)))))                                                                                                                                   
  (interative-f 2 1 0 n))             

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 I think I have known what happen.
The second program returns 1, because the symbol x is captured by cbr's param x. When the body of  cbr is evaluated, there are two bindings in the environment: one is the let binding x = 1, the other is x = x which is created by cbr's application. The symbol x in the (set x 2) uses the later one.
A workaround of this question is:
(let ((gen-x (gensym)))
  (set gen-x 1)
  (cbr gen-x)
  (symbol-value gen-x))
;; cbr (symbol-name x) g36
;; cbr (symbol-value x) 1
;; 2 

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

","The difference in performance between the recursive and iterative processes is due to how Scheme (or Lisp) handles recursion. The recursive version `sum-rec` has a linear time complexity O(n), but each recursive call adds a new frame to the call stack, which can lead to a high overhead for large values of b. On the other hand, the iterative version `sum-it` avoids this overhead by using a loop and updating variables in place, resulting in better performance. This is especially noticeable with large values of b, as the recursive approach has additional overhead due to function calls and stack management.",0.49,[[0.28129375]],0.07636739265749595,0.29778536282303836,0.31155778894472363,0.030456852791878174,0.17085427135678394
"I am having some trouble working out how to return a line of text if a match is found.
(set 'wireshark ""http://anonsvn.wireshark.org/wireshark/trunk/manuf"")

(set 'arptable (map (fn (x) (parse x "" "")) (exec ""arp -a"")))

(define (cleanIPaddress x)
  (slice x 1 -1))

(define (cleanMACaddress x) 
  (upper-case (join (slice (parse x "":"") 0 3) "":"")))

(define (addIPandMACaddress x) 
  (list (cleanIPaddress (nth 1 x)) (cleanMACaddress (nth 3 x))))

(set 'arplist (map addIPandMACaddress arptable))

(set 'routerMAC (last (assoc (exec ""ipconfig getoption en1 router"") arplist)))

(find-all routerMAC (get-url wireshark))

returns 
(""20:AA:4B"")
so I know that the code ""works""
but I would like to retrieve the full line of text
""20:AA:4B  Cisco-Li               # Cisco-Linksys, LLC""
","In the end I used:
(find-all (string routerMAC "".*"") (get-url wireshark))

","I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 Read up on mapcar et al:
(defparameter a (list 1 2 3 4))
(mapcon (lambda (tail)
          (mapcar (lambda (x)
                    (cons (car tail) x))
                  (cdr tail)))
        a)
==> ((1 . 2) (1 . 3) (1 . 4) (2 . 3) (2 . 4) (3 . 4))

 You don't need to do any of that.
Cygwin provides a command specifically for converting Windows paths to Cygwin paths, so that you don't need to bother about this sort of thing.
cmd> C:\cygwin\bin\cygpath.exe ""C:\Users\name\documents\visual studio 2010\projects\test""

/cygdrive/c/Users/name/documents/visual studio 2010/projects/test

Edit: I was curious about a Windows shell equivalent of backticks, and found Batch equivalent of Bash backticks, which suggests you might be able to do it all with this one-liner?
cmd> for /f ""usebackq tokens=*"" %a in (`C:\cygwin\bin\cygpath.exe ""$(ItemPath)""`) do emacsclient -d 127.0.0.1:0.0 ""%a""

 In the end I used:
(find-all (string routerMAC "".*"") (get-url wireshark))

","To return the full line of text when a match is found, you can modify your approach slightly. Instead of using (find-all), which returns all matching lines, you can use (find-one) or process each line individually to check for the match and then retrieve the entire line if a match is found. Here's an example:\n\n(set 'wireshark ",0.5261,[[0.14877244]],0.03698116398469192,0.2670940170940171,0.13513513513513511,0.05555555555555556,0.13513513513513511
"In Common Lisp I can evaluate the following snippet of code (in SBCL) without being signalled any syntax error:
(let ((x 0))
   (defun my-incf (y)
     (setf x (+ x y)))
   (defun my-decf (y)
     (setf x (- x y))))
MY-DECF

CL-USER> (my-incf 1)
1
CL-USER> (my-incf 1)
2
CL-USER> (my-decf 1)
1
CL-USER> (my-decf 1)
0

When I try to evaluate a corresponding Scheme snippet of code (in DrRacket):
(let ((x 0))
  (define (my-incf y)
    (set! x (+ x y)))
  (define (my-decf y)
    (set! x (- x y))))

it signals a syntax error.
begin (possibly implicit): no expression after a sequence of internal definitions in: (begin (define (my-incf y) (set! x (+ x y))) (define (my-decf y) (set! x (- x y))))

Does anybody know the reason why this cannot be done in Scheme?
","You can't define top-level bindings outside of the top-level, in Scheme. (And inside of a let is definitely outside of the top-level---what you had, instead, was internal definitions, which are not exported to the top-level.) However, using define-values, you can still do what you need to do:
(define-values (my-incf my-decf)
  (let ((x 0))
    (values (lambda (y)
              (set! x (+ x y))
              x)
            (lambda (y)
              (set! x (- x y))
              x))))

However, you can still use internal definitions, to make your code more readable:
(define-values (my-incf my-decf)
  (let ((x 0))
    (define (my-incf y)
      (set! x (+ x y))
      x)
    (define (my-decf y)
      (set! x (- x y))
      x)
    (values my-incf my-decf)))

Best of both worlds. :-) In this case, the values sends the internal my-incf and my-decf definitions to the outer define-values, which is where the real top-level definition happens.
","See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","The reason you encounter a syntax error in Scheme is due to the way internal definitions (those not enclosed within a specific form such as `let`, `lambda`, etc.) are handled. In Scheme, an `internal definition` must be associated with a specific syntactic form. The `(define ...)` forms you have used need to be placed inside a specific context like `let`, `lambda`, or another defining form. 

The correct way to define `my-incf` and `my-decf` in Scheme would be to place them within a `let` block, which is equivalent to Common Lisp's lexical scope for definitions:

```scheme
(let ((x 0))
  (define (my-incf y)
    (set! x (+ x y)))
  (define (my-decf y)
    (set! x (- x y))))
```

Alternatively, you can define the functions outside of any internal definition context and then associate them with `x` within a function:

```scheme
(define (my-incf y)
  (set! x (+ x y)))

(define (my-decf y)
  (set! x (- x y)))

(let ((x 0))
  (my-incf 1)
  (my-incf 1)
  (my-decf 1)
  (my-decf 1))
```

In this way, the definitions are valid and can be used within a lexical scope provided by `let`.",0.6921,[[0.57311816]],0.43730768885753135,0.4164344791018926,0.5730994152046783,0.2764705882352941,0.35672514619883045
"How can i convert the string ""1 2 3 4 5 6 7"" into the list (1 2 3 4 5 6 7) elegantly? I am using CLISP.
","Hint: Take a look at with-input-from-string.
","See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 
CLHS: Symbol Index
l1sp.org
In Slime, type C-cC-dh, a few chars of your search term, and then Tab to get a completion list.
Just type (apropos ""term"") in repl.

 There is a library called cl-ppcre:
(cl-ppcre:regex-replace-all ""qwer"" ""something to qwer"" ""replace"")
; ""something to replace""

Install it via quicklisp.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 I came up with: 
 (defn interpose-envelop-and-stringify [coll sep]
   (str sep
        (join sep coll)
        sep))
 (interpose-envelop-and-stringify (map up [""one"" ""two""]) ""\n"")

I am using join from clojure.string.
",You can convert the string \,0.5368,[[0.08704447]],0.014915054006802334,0.1570680628272251,0.14285714285714285,0.0,0.14285714285714285
"What is the proper way to convert the character #\1 to the integer 1?
I coerced a number into a list and got this:
(#\1 #\2 #\3)
and want to convert that into 
(1 2 3)

","CL-USER > (digit-char-p #\1)
1

digit-char-p returns

the numeric value of the character, if it is a digit char
NIL otherwise

Thus it is both:

a predicate, since numbers are true
a conversion function

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 The #' is a reader macro. #'+ is an abbreviation for (function +). ' is a reader macro expanding to (quote …). The latter returns its argument unevaluated. So, '(#'+ +) yields ((function +) +) (#'+ will be turned into (function +) at read-time). The first of this is just the list (function +), which is not a function. Now, (function +) is printed as #'+, which is what you see in the debugger.
Using non-literal lists will work:
CL-USER> (funcall (first (list #'+ '+)) 1)
1

 Here you go: First using coerce to convert the string to a list of characters, then mapcar to convert each character to a string.
(defun get-line ()
    (setf text (mapcar 'string (coerce (string (read)) 'list))))

 Why would you do that? What you ask is to split a string (a one-dimensional array of characters) into a list of symbols. Do you really want that?
#\h is a character object printed.
You can print them differently:
CL-USER 8 > (princ #\h)
h

CL-USER 9 > (prin1 #\h)
#\h

Let's print the list using PRINC:
CL-USER 10 > (map nil #'princ (coerce ""Hello!"" 'list))
Hello!

Btw., since strings, vectors and lists are sequences, you can MAP directly over the string...
CL-USER 11 > (map nil #'princ ""Hello!"")
Hello!

","To convert the character #\\1 to the integer 1 in Lisp, you can use the CHAR-CODE function. For example: (char-code #\\1) will return 49, which is the Unicode code point for the digit '1'. If your goal is to convert a string like \",0.5241,[[0.28446916]],0.08972745428251416,0.3136475158640231,0.3373493975903614,0.02469135802469136,0.21686746987951808
"I saw a piece of code from the website http://www.ccs.neu.edu/home/shivers/newstyle.html:
> (defun element-generator ()
    (let ((state '(() . (list of elements to be generated)))) ;() sentinel.
      (let ((ans (cadr state)))       ;pick off the first element
        (rplacd state (cddr state))   ;smash the cons
        ans)))
ELEMENT-GENERATOR
> (element-generator)
LIST
> (element-generator)
OF
> (element-generator)
ELEMENTS
> (element-generator)
TO
> (element-generator)
BE
> (element-generator)
GENERATED

I don't understand how the function remembers the state. Isn't state redefined to the whole list each time the function runs? And why the two layers of let (which is necessary)? It'd be appreciated if someone is able to explain how this function works.
","The value of state in (let ((state '(() . (list of elements to be generated)))) ...) is a quoted literal, and it is being modified (which, as explained in this answer is undefined behavior). This behavior has been discussed other questions, such as:

Strange Lisp Quoting scenario - Graham's On Lisp, page 37
Why does this function return a different value every time?
Modifying a list passed as a parameter gives different results in SBCL and CLISP
Lisp, cons and (number . number) difference

","Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I think I have known what happen.
The second program returns 1, because the symbol x is captured by cbr's param x. When the body of  cbr is evaluated, there are two bindings in the environment: one is the let binding x = 1, the other is x = x which is created by cbr's application. The symbol x in the (set x 2) uses the later one.
A workaround of this question is:
(let ((gen-x (gensym)))
  (set gen-x 1)
  (cbr gen-x)
  (symbol-value gen-x))
;; cbr (symbol-name x) g36
;; cbr (symbol-value x) 1
;; 2 

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

","The `element-generator` function maintains its state through the use of a closure created by the outer `let` form. The inner `let` is used to access and modify the state. Here's how it works:

1. **Outer `let`**: This binds `state` to an initial value, which is a cons cell where the car is `()` (a sentinel) and the cdr is a list of elements that need to be generated.

2. **Inner `let`**: This form accesses two parts of the state:
   - `(cadr state)` picks off the first element from the list.
   - `(rplacd state (cddr state))` removes the first element from the cdr part of the cons cell, effectively ",0.5227,[[0.27412218]],0.14082878823860506,0.33834681865488553,0.320855614973262,0.06486486486486487,0.14973262032085563
"I've been reading about how Racket is used for academic research, but I'm having a problem finding commercial success stories in business and/or start ups. Is anyone having any success using Racket commercially or am I barking up the wrong tree? I ask because I've got an idea for a start up and am evaluating languages and tools at the moment.
","Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
","Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
 ITA Software's airline-fare search service. See here to understand why this is impressive.
 Based off several google searches, I've come to the conclusion that one currently does not exist. If someone where to inform me otherwise, I would happily change my best answer however.
 The first manual you mentioned in your question contains a description of the most important steps, together with some examples, in the section ""Embedding Racket into a Program"" of chapter ""1 Overview"":
http://docs.racket-lang.org/inside/overview.html#(part._embedding)
 Are you looking for this?
(eval (read-from-string ""(car '(1 2))""))

Gives: 1

UPDATE:
How about (funcall (intern ""CAR"") '(1 2)) ? :)
 It's a very cool idea - would be great for evaluating mathematical expressions but you simply can't set an operator (or the logic behind it) to a variable.  Sorry :-)
","Yes, there are commercial success stories using Racket. One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket and uses it for other projects. Additionally, ITA Software used Racket for their airline-fare search service. These examples demonstrate that Racket can be successfully applied in commercial settings.",0.8271,[[0.57730414]],0.4234482805161156,0.5172806760665474,0.625,0.5128205128205128,0.6
"(define (pow b n) 
    ""YOUR-DOC-HERE""
    (cond ((= n 0) 1)
          ((even? n) (pow (pow b (/ n 2)) 2))
          ((odd? n) (* b (pow (pow b (/ (- n 1) 2)) 2)))))


(define (pow b n) 
    ""YOUR-DOC-HERE""
    (cond ((= n 0) 1)
          ((even? n) (* (pow b (/ n 2)) (pow b (/ n 2))))
          ((odd? n) (* b (pow b (/ (- n 1) 2)) (pow b (/ (- n 1) 2))))))

Here are two versions of my code for a power function with logarithmic efficiency. However, the first function would have a maximum recursion depth exceeded error and the second, though works, doesn't seem to function at a required efficiency. I am new to Scheme and I wonder what's wrong with these implementations?
","Your 1st version uses itself to square every value, which creates an infinite loop in the even? clause.
Your 2nd version calls pow twice in each clause which reverses any gain from the logarithmic algorithm.
Your can fix it using let like this:
(define (pow b n)
  ""Recursive power in logarithmic depth.""
  (let ((square (lambda (x) (* x x))))
    (cond ((= n 0) 1)
          ((even? n) (square (pow b (/ n 2))))
          ((odd? n) (* b (square (pow b (/ (- n 1) 2))))))))

or like this:
(define (pow b n)
  ""Recursive power in logarithmic depth.""
  (cond ((= n 0) 1)
        ((even? n)
         (let ((x (pow b (/ n 2))))
           (* x x)))
        ((odd? n)
         (let ((x (square (pow b (/ (- n 1) 2)))))
           (* b x x)))))

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 You can use ""v"" on a frame to jump to the definition of the function in the debugger.
In this case, the function sb-kernel:two-arg-> sounds like a specialized version of > that is called when there are exactly two arguments provided. If the arguments are 1 and NIL, you'll get an error because NIL is not a number.
I'm not sure how you'd figure this out yourself, except by practicing and asking questions.
 There are a couple of mistakes in the code, including misplaced parentheses. For starters, good-enough? as defined for the exercise 1.7, should look like this:
(define (good-enough? guess-old guess-new)
  (< (/ (abs (- guess-old guess-new)) guess)
     (/ 0.001 guess)))

And sqrt-iter, as written in your code, will lead to an infinite recursion. Try this instead:
(define (sqrt-iter guess-old guess-new x)
  (if (good-enough? guess-old guess-new)
      guess-new
      (sqrt-iter guess-new (improve guess-new x) x)))

(define (my-sqrt x)
  (sqrt-iter 0.0 1.0 x))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 In the book, authors have an example of formulating an iterative process for computing the Fibonacci numbers.
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))

The point here is that use two parameter a and b to memorise f(n+1) and f(n) during computing. The similar could be applied: we need a, b, c to memorise f(n+2), f(n+1) and f(n)
;; an interative process implementation                                                                                                                       
(define (f-i n)                                                                                                                                               
  ;; f2 is f(n+2), f1 is f(n+1), f0 is f(n)                                                                                                                   
  (define (interative-f f2 f1 f0 count)                                                                                                                       
    (cond                                                                                                                                                     
      ((= count 0) f0)                                                                                                                                         
      (else (interative-f                                                                                                                                      
              (+ f2 (* f1 2) (* f0 3))                                                                                                                          
              f2                                                                                                                                                
              f1                                                                                                                                                
              (- count 1)))))                                                                                                                                   
  (interative-f 2 1 0 n))             

",The first version of your power function is almost correct but has an issue with how it handles even exponents. The second version you provided does not have a direct problem but can be optimized further for clarity and efficiency. Here's the corrected version:\n\n(define (pow b n)\n  \,0.5092,[[0.18644809]],0.008502120474337826,0.08896797153024912,0.20118343195266272,0.03592814371257485,0.1420118343195266
"I'm using QuickLisp to load Common Lisp libraries. However, there are many libraries that all do similar things. For example, there are many libraries that all deal with parsing a CSV file. 
Are there any resources you use to check which libraries meet your needs? How do you determine if a library is still being supported? Are there any heuristics short of visiting individual libraries's websites?
I'm aware of http://www.cliki.net/, which provides some recommendations. 
","There are two separate questions:

Are there any resources you use to check which libraries meet your
  needs?

I just use the library's official documentation, or quickdocs as mentioned earlier. I don't think there are any comparison tables between similar libraries. But you can always ask for help on #lisp on Freenode IRC network (since StackOverflow doesn't like questions like ""What's the best CL library for parsing CSV?"")

How do you determine if a library is still being supported? Are there any heuristics short of visiting individual libraries's websites?

If a library is on Quicklisp then it is supported. Unsupported libraries usually drop out soon enough. Xach (Quicklisp's developer and maintainer) makes sure that there is no library in Quicklisp which can't be built on a supported CL implementation.
","See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 The Common Lisp wiki, cliki, links to two WebSocket libraries, both of which are available through Quicklisp. You should evaluate both of them and see which meets your needs. (Edit: clws appears to be the more actively maintained of the two.)
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Another simple way is to have Lisp running a HTTP server and contact Lisp from the outside via HTTP requests.
 It's been a tricky problem, and there have been several attempted solutions.
I recently did a survey of Common Lisp users, and most of them simply manage libraries by hand by downloading project archives and checking things out of git, cvs, svn, etc.
The next most popular method of library management is a program called ""asdf-install"". See http://cliki.net/asdf-install for some info about it.
Some people use a program called clbuild. It grabs libraries from git, cvs, svn for you. http://common-lisp.net/project/clbuild/ has more info.
I'm working on a project called Quicklisp. I'm starting a public beta tomorrow. I think it has some advantages over manual library management, asdf-install, and clbuild, but unfortunately it doesn't have any documentation or information. It does have a group of enthusiastic users, though, and I hope it will help people get the CL libraries they need. For more information, see http://quicklisp.org. The link to download the beta will be there tomorrow.
 There is a library called cl-ppcre:
(cl-ppcre:regex-replace-all ""qwer"" ""something to qwer"" ""replace"")
; ""something to replace""

Install it via quicklisp.
","When dealing with a plethora of similar libraries, there are several strategies you can use to determine which library meets your needs and is still being supported. Firstly, visit the library’s page on sites like http://www.cliki.net/ or GitHub, where you might find information about the last update, contributors, and issues raised and addressed. Another resource is Quicklisp’s package information, often available by running `(ql:info 'package-name)` in your Lisp environment. This will give you details about the library, including its version history and dependencies. Additionally, you can look for libraries that have active communities on platforms like Stack Overflow or Reddit. The Common Lisp community forum (http://www.cliki.net/) is also a good place to ask for recommendations specific to your use case. Finally, checking out repositories that integrate with the library, such as those using it in their projects or testing suites, can provide insights into its current usage and maintenance.",0.5667,[[0.3799818]],0.176070734073845,0.3270252324037185,0.3661016949152542,0.10238907849829351,0.18983050847457625
"I'm relatively new to Lisp (I just know the very basics) and I'm currently trying to run an algorithmic composition program created by David Cope. It runs in MCL 5.0, and I keep getting the following error:

Error in process play: Stack overflow on value stack.
  To globally increase stack space, increase *minimum-stack-overflow-size*

Does anyone know what function I would use to increase the stack overflow size and how I would calculate the best stack overflow size for my computer? I'm running MCL on an old Powerbook with 512 MB of RAM.
Thanks for your time,
Eddie
","It seems to say that you simply need to modify the special variable *minimum-stack-overflow-size*.  When you are at the REPL (CL-USER> prompt or similar), inspect this variable by evaluating its name:
CL-USER> *minimum-stack-overflow-size*

Then, set it to a bigger value (the 1234567 is just a placeholder) with setf:
CL-USER> (setf *minimum-stack-overflow-size* 1234567)

However, this might not be the real issue.  I do not know MCL well, but it might be necessary to (declaim (optimize (speed 3) (safety 0))) or similar to enable tail call elimination, if the program you want to run uses a tail recursive function which depends on such optimization.
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I am working on a windows account with administrator permissions. The server directory in emacs.d was owned by the group ""Administrators"". I changed the ownership from the user group ""Administrators"" to be owned by the username I am currently working with (which is ""Administrator"") and the error message went away.
This solution is quite similar to the one given in this answer: https://stackoverflow.com/a/2944197/1312456
 You have three options:

Rewrite the algorithm to be tail-recursive or, equivalently, iterative
Change the algorithm all together
Increase the lisp's stack size

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
","To address the stack overflow issue you're encountering in MCL 5.0 on an old Powerbook with 512 MB of RAM, you can increase the *minimum-stack-overflow-size* by modifying the Lisp environment settings. In MCL, you typically set this through command-line options or by editing your initialization file (init.lisp).

For a one-time adjustment via command line when starting MCL, you could use:

```
mcl -min-stack-overflow-size 1048576
```

This sets the minimum stack overflow size to 1 MB. You can adjust this value based on your needs; however, since you're working with limited RAM (512 MB), it's important not to set it too high as it could lead to other issues or crashes.

For a more permanent solution, you might add something like the following to your init.lisp file:

```lisp
(setf *minimum-stack-overflow-size* 1048576)
```

To calculate an appropriate value, consider how much stack space your program uses. A common heuristic is to multiply the number of recursive calls by the average stack depth per call and then add some buffer for overhead. Given your constraints, starting with a conservative increase like 1 MB might be prudent.

Remember that increasing the stack size does not come without trade-offs, as it consumes more memory from your limited RAM.",0.6008,[[0.45589125]],0.15803031467498102,0.3794347466298264,0.36746987951807225,0.08484848484848484,0.17469879518072293
"I think I understand Lisp macros and their role in the compilation phase.
But in Python, you can pass a function into another function
def f(filename, g):
  try:                                
     fh = open(filename, ""rb"") 
     g(fh)
  finally:
     close(fh) 

So, we get lazy evaluation here. What can I do with macros and not with functions as first class objects?
","First of all Lisp has first-class functions too, so you could as well ask: ""Why do I need macros in Lisp if I already have first-class functions"". The answer to that is that first-class functions don't allow you to play with syntax.
On a cosmetic level, first-class functions allow you to write f(filename, some_function) or f(filename, lambda fh: fh.whatever(x)), but not f(filename, fh, fh.whatever(x)). Though arguably that's a good thing because in that last case it is a lot less clear where fh suddenly comes from.
More importantly functions can only contain code that is valid. So you can't write a higher-order function reverse_function that takes a function as an argument and executes it ""in reverse"", so that reverse_function(lambda: ""hello world"" print) would execute print ""hello world"". With a macro you can do this. Of course this particular example is quite silly, but this ability is enormously useful when embedding domain specific languages.
For example you couldn't implement common lisp's loop construct in python. Hell, you couldn't even implement python's for ... in construct in python if it wasn't really built-in - at least not with that syntax. Sure you could implement something like for(collection, function), but that's a lot less pretty.
","Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 Remember that a macro returns an expression to be evaluated. In order to do this, you have to backquote:
(defmacro ++ (variable)
   `(incf ,variable))

 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 I think the answer to this is macros: if you write a macro which expands to the code you want, then simply place an invocation of the macro at top-level, then the expansion of the macro will end up in the compiled file.
So:
(defmacro foo ()
  (if <compile-time-condition>
      `(setq ...)
      `(setq ...)))

(foo)

Caveat: you can only conditionalise on things you know at compile time: your example of dispatching on UID might not do what you expect.
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
","In Lisp, macros operate during the compile-time phase rather than at runtime like functions. While you can pass a function as an argument to another function in Lisp (similar to Python's example), macros allow for more powerful and flexible code transformation. With macros, you can generate code based on the context of the macro call, which can include conditional logic that depends on compile-time values or even dynamically generated expressions. This means you can alter not just the value passed around but also how the code is structured at compile time. For example, a macro might expand to different pieces of code depending on certain conditions known only during compilation.",0.5287,[[0.32026705]],0.08157181778050701,0.19033743947415988,0.2823529411764706,0.0650887573964497,0.13529411764705884
"Structure and Interpretation of Computer Programs (SICP)'s box-and-pointer diagrams in Figures 3.16 and 3.17 don't appear equivalent (purely with respect to value, not memory) even though it says they are. (""When thought of as a list, z1 and z2 both represent ""the same"" list, ((a b) a b))"", pg. 258)
(define x (list 'a 'b))
(define z1 (cons x x))
(define z2 (cons (list 'a 'b) (list 'a 'b)))

SICP diagrams the pair z1 like this:

and z2 like this:

The arrows in the pair, z1, don't both seem to be pointing to the entire pair, x. They don't even point to the same thing, despite both having received the same (memory and value) pair.
I would evaluate the first diagram as (a b), and the second as ((a b) a b)
I could guess that each arrow is actually pointing to the entire pair, x, but in figure 2.3 on page 98:

it very clearly points to an entire box by either pointing to the side or in between two items.
Am I understanding box-and-pointer diagrams incorrectly or something else entirely?
","Your last assumption is correct. The dot indicates where the pointer value is, the whole double box the arrow is pointing at is the target. It doesn't matter if it's pointing on the side, top middle, top left or top right. It's the whole pair that is the ""address"" of the object. 
You can't point to a part of an object without accessing its part with car and cdr. The second you do that you have whatever it was pointed to and not a indirect pointer. (car '(a b)) ; ==> a and a doesn't have any essence of the list that still is pointing to it until it is garbage collected. 
We could illustrate it like this instead: 
[=#1|#3|#2]
[=#2|#3|()] 
[=#3|a |#4]
[=#4|b |()]

The first value with =# is the location of the box itself, while the next two are car and cdr. Above, x points to the address #3 and z1 to #1. Let's make z2
[=#5|#6|#8]
[=#6|a |#7] 
[=#7|b |()] 
[=#8|#9|()]
[=#9|a |#10]
[=#10|b |()]

As you can see, z2 uses two more cons than z1 since it doesn't reuse the same object as both elements of its list, but uses individual similar-looking lists. 
In the drawings, both car and cdr of z1 point to the same list x. z2 points to two different lists, but the elements in those lists are the same.  
The reason for this is that symbols are singletons. Thus, you only have one symbol object for a and evaluating 'a in two different places will both point to the same a.  Other singletons are #f, #t and ()
cons always creates a fresh pair and list is just a procedure that cons together the arguments. Thus the same code (list 'a 'b) two places in the expression makes two different objects that just look the same.
(eq? (car z1) (cdr z1))    ; ==> #t same object
(eq? (car z2) (cdr z2))    ; ==> #f not same object
(equal? (car z2) (cdr z2)) ; ==> #t they look the same, but they are not the same. (created at different places)

Quoted data can be seen as created all at once before the program starts. Thus this is undefined.
(eq? '(a b) '(a b))         ; ==> #t or #f (undefined)
(eq? '(b c) (cdr '(a b c))) ; ==> #t or #f (undefined)

The reason is that Scheme is allowed, but not obligated, to reuse data the same way as with the structure z1. 
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 It stands for Aesthetic.  A-formatted output is not escaped.  See http://www.lispworks.com/documentation/HyperSpec/Body/22_cda.htm
Incidentally, S stands for Standard rather than S-expression.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Cons cells in general hold two pointers that can point to anything. General usage of course is to point to a ""value"" with the left one, and to another Cons cell (or nil) with the ""right"" one.
 You had too many parentheses in the recursive call. Consider the following:

(is-word-in-list (x (cdr lst))) is equivalent to isWordInList(x(cdr(lst))) in JavaScript syntax
(is-word-in-list x (cdr lst)) is equivalent to isWordInList(x, cdr(lst)) in JavaScript syntax

See the difference?
","The key difference lies in how cons cells are used to form pairs and lists. In Scheme (and Lisp), a cons cell is used to create pairs where the first element is stored in the left pointer, and the second element is stored in the right pointer. When you define `z1` as `(cons x x)`, it creates a pair where both pointers point to the same list object. Thus, modifying one will affect the other because they are the same object. In contrast, when you define `z2` as `(cons (list 'a 'b) (list 'a 'b))`, you create two separate pairs of cons cells that each hold a different list object. This is why `z1` behaves differently from `z2`: it's due to the sharing of objects rather than creating distinct lists. The box-and-pointer diagrams in SICP visually represent this sharing, where z1 shows both pointers pointing to the same box containing (a b), while z2 shows each pointer pointing to a separate box containing (a b).",0.5694,[[0.6341624]],0.0616765475349263,0.1666427822399041,0.3951890034364261,0.11034482758620691,0.1683848797250859
"
Possible Duplicate:
How to remove nested parentheses in LISP 

This is my second quick-and-silly question about LISP, but I am kind of stuck. I need to access all the nodes in a list with several levels. I need something like:
>> (get-symbols '(A (B (C D) E )))
(A B C D E)

I don't care about the order. How would you do that? I prefer code intuitivity rather than efficency.
Thanks
","From OnLisp:
(defun flatten (tree)
  (if (atom tree)
      (mklist tree)
    (nconc (flatten (car tree))
       (if (cdr tree) (flatten (cdr tree))))))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The example is unfortunate, as it only leaves one argument after ""the opening of the parentheses"". But yes, that's how I also think about it. The simpler the better, :) as long as it is correct.
Except that of course the values in the list are first evaluated, so it's not a simply-syntactical process. But as a basic example,
(apply + (list 1 2 3)) 
== 
(      +       1 2 3 )

i.e. the parens around the arguments is what goes away.
For a non-trivial example, see

Matrix multiplication in scheme, List of lists

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
","To flatten a nested list like the one you described, you can use recursion or iterate through the list and collect all symbols. Here's an example using recursion:

```lisp
(defun get-symbols (lst)
  (if (null lst) ; Check if the list is empty
      nil         ; If it is, return nil
    (let ((first (car lst))) ; Get the first element of the current sublist
      (cond
        ((atom first)       ; If the first element is not a list (i.e., an atom)
         (cons first (get-symbols (cdr lst)))) ; Add it to the result and continue with the rest of the list
        (t                  ; Otherwise, if the first element is a list
         (append (get-symbols first) (get-symbols (cdr lst)))))))) ; Recursively get symbols from both the sublist and the rest of the list

;; Example usage:
(get-symbols '(A (B (C D) E)))
;; => (A B C D E)
",0.6578,[[0.06934516]],0.10561098380434009,0.3406433047873747,0.11320754716981132,0.0,0.07547169811320754
"I'm trying to learn LISP. I got my way around functions and I wanted to test myself with some.
I was trying to write a function that can remove an element from a list in a given index.
This seems pretty straightforward, but I can't manage to do it.
Example: I have the list (20 8 13 10) and I want to remove the number at index 2.
How would I go about something like this?
","It's very easy. This is the base case:
(remove-nth 0 '(2 3)) ; => (3)

And the default case:
(remove-nth 1 '(1 2 3))         ; ==
(cons 1 (remove-nth 0 '(2 3)))

The only thing left for you to do is to actually implement it!
There is a third case. What if the list is nil? In the strictest sense you cannot do the job and you should signal an error or perhaps there isn't anything to do so it's ok to then have it as a base case that evaluates to '() so that (remove-nth 5 '(1 2)) ; ==> (1 2)
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 It's very easy. This is the base case:
(remove-nth 0 '(2 3)) ; => (3)

And the default case:
(remove-nth 1 '(1 2 3))         ; ==
(cons 1 (remove-nth 0 '(2 3)))

The only thing left for you to do is to actually implement it!
There is a third case. What if the list is nil? In the strictest sense you cannot do the job and you should signal an error or perhaps there isn't anything to do so it's ok to then have it as a base case that evaluates to '() so that (remove-nth 5 '(1 2)) ; ==> (1 2)
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

","To remove an element from a list at a specific index in Lisp, you can use recursion. Here's how you might implement such a function:\n\n```lisp\n(defun remove-nth (index list)\n  (cond ((null list) nil) ; Base case: empty list\n        ((= index 0) (cdr list)) ; Base case: removing the first element\n        (t (cons (car list) (remove-nth (- index 1) (cdr list))))))\n```\n\nFor example, if you call `(remove-nth 2 '(20 8 13 10))`, it will return `(20 8 10)`. This function works by recursively traversing the list and constructing a new list that excludes the element at the given index.",0.5836,[[0.3446059]],0.2094012411435323,0.38399117103433444,0.3523809523809524,0.0673076923076923,0.16190476190476188
"In Racket, it's possible to make a copy of a struct with particular fields changed. The following:
(struct foo (a b c))
(define tst (foo 1 2 3))
(struct-copy foo tst [a 4])

Should produce (foo 4 2 3).
I was wondering, what if the field I want to modify isn't known at compile time? Say for instance I want to write a function that can modify either a, b, or c depending on user input. If I have a function: 
(define (update-foo somefoo param)
  (struct-copy foo somefoo [param 4]))

Then I receive the error struct-copy: accessor name not associated with the given structure type. Because it's treating 'param' as an accessor, rather than evaluating it and treating the symbol/string inside as an accessor.
So I was wondering, is it possible to use struct-copy where the intended field name is known only at runtime? And if not, is there a workaround of some sort, or should I just bite the bullet and change foo to a mutable struct (as set-foo-a! and the like exist at runtime)?
","(This was originally a comment, but OP asked me to post it as an answer)
If you want to have arbitrary runtime field names, then it sounds like you're duck-typing a dictionary not a struct... in which case you should use a dictionary.
One characteristic of a Racket struct is that referencing a field can be faster precisely because it's a static offset known at compile time. Another characteristic is that you can't add a field unknown at compile time, or, omit a field.
When those characteristics are advantages (i.e. when you don't want to add or omit fields accidentally), you should use a struct. Otherwise (i.e. when you do want to add or omit fields intentionally -- which sounds like your situation) you should probably instead use some sort of dictionary, e.g. a hash-table or association list.
","Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
","In Racket, `struct-copy` requires that the field name be known at compile time. If you need to specify a field dynamically based on runtime input, one workaround is to use an association list (alist) or hash table to map the field names to their corresponding accessor functions and then apply those functions within your function. Here’s an example using an alist:\n\n```racket\n(struct foo (a b c))\n(define tst (foo 1 2 3))\n\n(define (update-foo somefoo param value)\n  (define field->accessor (hash 'a foo-a 'b foo-b 'c foo-c))\n  (define (get-accessor field) (cdr (assoc field field->accessor)))\n  (define (set-accessor field obj new-value)\n    (let ((accessor (get-accessor field)))\n      (struct-copy somefoo obj [field (accessor obj new-value)])))\n  (set-accessor param somefoo value))\n\n(update-foo tst 'a 4) ; This will return (foo 4 2 3)\n```\nThis approach allows you to use `param` as a symbol at runtime and still modify the appropriate field of the struct.",0.5159,[[0.24101904]],0.12160820614285575,0.31814010400734166,0.31578947368421056,0.056074766355140186,0.14241486068111456
"is it possible  in C-Lisp to collect the results of a map into an array with 2 dimensions? how would I reference this array in the function?
I've tried things like,
(map  'Array'(3 3)  #'somefunction  sequence) 

or
(map '(simple-array T (3 3))  #'somefunction  sequence)

and was not successful.
Of course the sequence i'm starting from have the same number of total elements of the result array i wish to obtain
","A good way to do this is to use displaced arrays and map-into.  Here's an over-simple example:
(defun map-array (f a &rest make-array-kws &key &allow-other-keys)
  ;; Map F over A, which can be any array, returning a new array with
  ;; the same shape as A.  Keyword arguments get passwd to MAKE-ARRAY
  ;; of the result array.  This may not handle things like fill
  ;; pointers well or at all.
  (let ((r (apply #'make-array (array-dimensions a)
                   make-array-kws)))
    (map-into
     (make-array (array-total-size r)
                 :element-type (array-element-type r)
                 :displaced-to r)
     f
     (make-array (array-total-size a)
                 :element-type (array-element-type a)
                 :displaced-to a))
    r))

","To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 You would do this also:
(def xs '(5 10 12 15))

(map - (rest xs) xs)
;; => (5 2 3)

map applies the function - to two lists:
  10  12  15
-  5  10  12  15
----------------
   5   2   3

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 If I understood correctly, you can combine reduce and append to flatten the list before returning it.  
Example:  
(reduce 'append '((1) (2) (3)))

Output:  
(1 2 3)

In your case this might work:
(reduce 'append (mapcar 'recursive-function L))

 What you appear to be trying to do is apply a factorial function to each member of a list and collect the results in a list.
For this you need a factorial function and mapcar.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","In Common Lisp, you can collect the results of `map` into a two-dimensional array by first creating an empty array and then using `dotimes` or another loop to fill it. Here's an example of how you might do this for a list `sequence` that is suitable in length for your 2D array dimensions (e.g., 9 elements for a 3x3 array). You can use the `make-array` function to create the initial array and then iterate over the mapped results to fill it. Here’s a sample code snippet:\n\n```lisp\n(let ((array (make-array '(3 3))))\n  (dotimes (i 9)\n    (setf (aref array (floor i 3) (mod i 3)) (somefunction (nth i sequence))))\n  array)\n)\n\nThis code creates a 3x3 array and fills it with the results of `somefunction` applied to each element of `sequence`. Adjust the dimensions as needed for your specific case.",0.5583,[[0.51387023]],0.13350734522382204,0.298954731833831,0.3602941176470589,0.07407407407407407,0.19117647058823534
"I found out that top-level declarations order does not seems to matter. Is there any documentation about that topic? I don't quite understand it.
Examples showing that a function can be called without being defined
#lang racket

(define (function-defined-early)
  (function-defined-later))

(define (function-defined-later)
  1)

(function-defined-early)
> 1

;; Common Lisp

(defun function-defined-early ()
  (function-defined-later))

(defun function-defined-later ()
  1)

(print (function-defined-early))
> 1

","For Common Lisp it's a bit complicated, since implementations can use interpreted code, compiled code and heavily optimized compiled code.
Function calling in simple compiled code
For example SBCL by default compiles all code. Even the code entered via a read-eval-print-loop:
* (defun foo (a) (bar (1+ a)))
; in: DEFUN FOO
;     (BAR (1+ A))
;
; caught STYLE-WARNING:
;   undefined function: COMMON-LISP-USER::BAR
;
; compilation unit finished
;   Undefined function:
;     BAR
;   caught 1 STYLE-WARNING condition
FOO

Since the function gets compiled immediately, the compiler sees that there is an undefined function. But it's just a warning and not an error. The generated code will call the function bar, even if it is defined later.
Symbols have a function value
In Common Lisp the function objects for global functions are registered as symbols.
* (fboundp 'foo)
T
* (fboundp 'bar)
NIL

bar has no function definition. If we later define a function for bar, then the code of our earlier defined function foo will call this new function.
How does it work? The code in foo does a lookup at runtime to get the function value of the symbol bar and calls that function.
Thus we can also redefine bar and foo will call the new function.
Late Binding
The concept of doing runtime lookup of functions is often called late binding. This was described for Lisp in the 1960s.
Thus a call of a global function
(bar 1 a)

is conceptionally basically the same as
(if (fbound 'bar)
    (funcall (symbol-function 'bar) 1 a)
    (error ""undefined function BAR""))

Keep in mind that this is a simplistic model and in reality a Common Lisp file compiler may use more aggressive optimizations (like inlining), where there is no runtime lookup.
The evaluation of function forms
The Common Lisp standard says in Conses as Forms:

If the operator is neither a special operator nor a macro name, it is assumed to be a function name (even if there is no definition for such a function).

","
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 Enclose your call to f in a module clause in a.rkt:
#lang racket
(provide f)
(define (f) 10)
(module+ main
  (f))

The forms in the module+ main part will only be executed when you run a.rkt directly, not when you require it.
For more info see here.
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 You don't need eval here; use begin instead to group those definitions together into a list; i.e., the template to be expanded should be of the form:
`(begin 
   ,@(map ...)
   (define ...)
   (define ...)
   ...)

Edit:
Change for-each to map as suggested by OP.
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","In Common Lisp and Racket, you can define functions in any order because of how their evaluation and compilation phases work. In Racket, top-level definitions are compiled or expanded into an abstract syntax tree (AST) form before the program starts running. This means that by the time a function is called, all necessary definitions have been processed. In Common Lisp, similar behavior occurs during macro expansion and compilation. However, both languages ensure that functions can be called before they are fully defined in the execution context due to their dynamic evaluation or ahead-of-time processing mechanisms.",0.4953,[[0.29101876]],0.01372236236863864,0.11756662017661032,0.22273781902552203,0.037296037296037296,0.12064965197215778
"In common lisp, I would like to be able to find out wether or not a symbol is a macro or not. Is there a predicate such as (macrop) which will allow me to detect if a name/symbol is a macro?
","If macro-function returns non-NIL, then it is a macro.
CL-USER 1 > (defmacro foo (bar) bar)
FOO

CL-USER 2 > (macro-function 'foo)
#<anonymous interpreted function 40600108FC>

Note that this works for typical global macros. There are also local&lexical macros, symbol macros, ...
","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
 Use the macro CHECK-TYPE:
CL-USER 9 > (let ((n ""10""))
              (check-type n integer))

Error: The value ""10"" of N is not of type INTEGER.

 To get the same result for an empty list in Clojure as you do in Common Lisp, use the empty? function. This function is in the core library: no imports are necessary. 
It is also a predicate, and suffixed with a ?, making it a little clearer what exactly you're doing in the code.
=> (empty? '())
true
=> (empty? '(1 2))
false
=> (empty? nil)
true

As j-g faustus already noted, seq can be used for a similar effect.
 Macros get their arguments passed unevaluated. They may choose to evaluate them. dolist does that for its list argument. It works with an unquoted list passed in for lst in your macro test:
(defmacro test (lst)
  (dolist (x lst)
    (print x)))

That's because at macro-expansion time the dolist sees lst as its argument. So when it evaluates it, it gets the list (1 2 3).
","In Common Lisp, you can use the function 'macro-function' to check if a symbol is a macro. If 'macro-function' returns a non-nil value for a given symbol, then that symbol is a macro. There isn't a direct predicate like (macrop) for macros, but you can achieve similar functionality with (if (macro-function 'symbol-name) ...).",0.5704,[[0.39075314]],0.22243679225721363,0.3867168645622165,0.3883495145631068,0.15841584158415842,0.27184466019417475
"I only found how to kill a thread that I have assigned to a variable:
(setf *foo* (bt:make-thread (lambda () (loop)) :name ""Foo2"")) --> (bt:destroy-thread *foo*) 
How can I kill just any thread that I can see with (bt:all-threads):
(bt:make-thread (lambda () (loop)) :name ""Foo"") --> ?
","You can kill any thread. There is nothing special about it. If you get a list of threads, just get the thread you want to kill and pass it to the function.
The function destroy-thread does not see a variable. Since it is a function, Lisp uses the usual evaluation rules. It gets passed a thread. The thread just happens to be the value of a variable in your example.
It could be the value of a function call:
(defun my-thread ()
  *foo*)

(bt:destroy-thread (my-thread))

or even part of a data structure, for example a list:
(defun my-thread ()
  (list 1 *foo* 3))

(bt:destroy-thread (second (my-thread)))

A thread is just another object.
If you get a list of threads, then you need to identify the correct thread. For example by looking at the name of the thread.
","New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 (let ((a read)))
   (eval a))

(+ 2 2 2)

=> 6

there's a reason they call it a READ EVAL PRINT LOOP.
 ? (defun foo (a b) (+ a 2))
;Compiler warnings :
;   In FOO: Unused lexical variable B
FOO

? (defun foo (a b)
    (declare (ignore b))
    (+ a 2))
FOO

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
","To kill a thread that you find using `(bt:all-threads)`, you would need to first retrieve the thread object. Unfortunately, there is no direct way to access a thread by its name once it has been created and added to the list of threads returned by `(bt:all-threads)`. You would have to iterate over the list of all threads and check their names or other properties to find the one you want to kill.

Here is an example of how you might do this:

```lisp
(defun find-and-kill-thread (thread-name)
  (let ((threads (bt:all-threads)))
    (dolist (thread threads nil)
      (when (string= (bt:thread-name thread) thread-name)
        (bt:destroy-thread thread)))))

;; Usage:
(find-and-kill-thread ",0.6138,[[0.59101535]],0.2477614776497041,0.37645100228553635,0.42424242424242425,0.11450381679389313,0.23484848484848486
"In scheme, the new multiply function is:
( define ( iter b a n)
    ( cond (( = b 0) n)
           (( even? b) ( iter ( / b 2) ( * 2 a) n))
           ( else ( iter ( - b 1) ( / ( * a b) ( - b 1)) ( + a ( * a ( - b 1)))))))

( define ( mul b a)
    ( iter b a 1))

the question requires me to use iterative method rather than recursive method to deal with this problem, my thinking is following:
for example: ( mul 2 3 ) 

        b     a     n

 begin: 2     3     1
 1    : 1     6     1
 2    : 0     6/0   6

Obviously, in step 2, a equals 6/0. That should be impossible. But the function works well. Could anyone explain this? Here is the example in an online Scheme interpreter.
","No, the function doesn't work well. Copy a fresh definition of the procedure, run it again and you'll see the error:
(define (iter b a n)
  (cond ((= b 0) n)
        ((even? b)
         (iter (/ b 2) (* 2 a) n))
        (else
         (iter (- b 1) (/ (* a b) (- b 1)) (+ a (* a (- b 1)))))))

(define (mul b a)
  (iter b a 1))

(mul 2 3)
=> /: division by zero

In fact, the expected solution would be more along these lines, and notice that special care must be taken in case that b is negative:
(define (iter a b n)
  (cond ((zero? b) n)
        ((even? b)
         (iter (+ a a) (/ b 2) n))
        (else
         (iter a (- b 1) (+ a n)))))

(define (mul a b)
  (if (< b 0)
      (- (iter a (- b) 0))
      (iter a b 0)))

And following your example, here's how the parameters look in each iteration when we execute (mul 2 3):
        a     b     n
 begin: 2     3     0
 1    : 2     2     2
 2    : 4     1     2
 3    : 4     0     6

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The cut is not used for efficiency, but to commit to the first solution (see the comment next to the !/0: ""single solution: longest input match""). If you comment out the !/0, you get for example:
?- parse(""abc"", E).
E = [s(abc)] ;
E = [s(ab), s(c)] ;
E = [s(a), s(bc)] ;
E = [s(a), s(b), s(c)] ;
false.

It is clear that only the first solution, consisting of the longest sequence of characters that form a token, is desired in such cases. Given the example above, I therefore disagree with ""false"": expression//1 is ambiguous, because number//1 and symbolr//1 are. In Mercury, you could use the determinism declaration cc_nondet to commit to a solution, if any.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
 The right-hand side of and and or are tail expressions (see R5RS section 3.5), so you can safely use those for iterative purposes.
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

","The issue you're encountering with (mul 2 3) is due to a logical error in the function definition. Specifically, the condition `(else (iter (- b 1) (/ (* a b) (- b 1)) (+ a (* a (- b 1))))` incorrectly updates `a`, leading to division by zero when `b` becomes 0 and `n` is not yet updated correctly. The correct approach should ensure that `b` is halved only if it's even, and decrementing `b` by 1 and updating `a` and `n` appropriately in other cases. Here’s a corrected version of the function using an iterative method instead of recursion:",0.5769,[[0.38055143]],0.08258417656579292,0.16825763106834102,0.40909090909090917,0.16030534351145037,0.25
"I just start to learn Scheme today.
I wrote a function gcd(), but it always returns 0.
(define (gcd a b)
    (cond (= b 0) 
        (a)
     (else ((gcd b (modulo a b))))
    )
)

Why I am wrong?
","This should fix the problems:
(define (gcd a b)
  (cond [(= b 0) a]
        [else (gcd b (modulo a b))]))

You were incorrectly surrounding some expressions between parenthesis, and some parenthesis were missing from the cond expression.
Notice that in Scheme, when you surround something in parenthesis, say (a) you're telling the interpreter: a is a procedure with no arguments and I want to call it, and this was not the case in here, a is just a number.
Also, for readability's sake, it's a good idea to use [] instead of () to separate each of the conditions in a cond expression, as shown in my code above - but don't forget them, they're mandatory and in your code you forgot them in the first condition.
","The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 As mentioned in first comment it is necessarily to use (list a b c) form.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

","There are a couple of issues with your gcd function. First, there's a syntax error: the condition should be `(= b 0)` and not ` (= b 0) (a)`. Second, you need to return the result of the recursive call to `(gcd b (modulo a b))` instead of just using it in the conditional statement. Here is the corrected version of your function:\n\n```lisp\n(define (gcd a b)\n    (cond ((= b 0) a)\n          (else (gcd b (modulo a b))))\n)\n\nThis will correctly compute the greatest common divisor of `a` and `b`. Happy coding!",0.6242,[[0.4227585]],0.26970291412301184,0.31216248276674585,0.4355555555555556,0.14349775784753366,0.19555555555555557
"guys.
Today I want to write sigma macro to calculate the sum from the flexible expression input.
The code below is I written this afternoon. But it does not work follow my purpose.
(defmacro sigma (exp ll)
  `(+ ,@(loop for i in ll collect
             (progn (setf (elt exp 1) i)
                    (print exp)
                    exp)))
  )

>>(pprint (macroexpand-1 '(sigma (+ 1 2) (2 3 4))))
>>(+ 2 2) 
  (+ 3 2) 
  (+ 4 2) 
  (+ (+ 4 2) (+ 4 2) (+ 4 2))

I want it works (+ (+ 2 2) (+ 3 2) (+ 4 2)) but loop collect give me the weird answer. 
Why does it work like this? Do I have some methods to fix this?
","If you want a freshly consed list, then copy-list is a way:
(defmacro sigma (exp ll)
  `(+ ,@(loop for i in ll and exp1 = (copy-list exp)
              do (setf (second exp1) i)
              collect exp1)))

Nested backquote expressions are also possible:
(defmacro sigma ((op arg0 &rest args) ll)
  (declare (ignore arg0))
  `(+ ,@(loop for i in ll collect `(,op ,i ,@args))))

","I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 This snippet is current in Clojure 1.4. Is it idiomatic for a function to submit a task back to the agent that called it? Yes.
Here is an example that uses a similar approach to recursively calculate a factorial:
(defn fac [n limit total]
  (if (< n limit)
    (let [next-n (inc n)]
       (send-off *agent* fac limit (* total next-n)) 
       next-n)
     total))

 (def a (agent 1))

 (await (send-off a fac 5 1))
 ; => nil
 @a
 ;=> 120

Update
The above is a contrived example and actually not a good one, as there is a race condition between the various recursive send-off calls and the later await.  There may be some send-off calls yet to be added to the agent's task queue. 
I re-wrote the above as follows:
(defn factorial-using-agent-recursive [x]
  (let [a (agent 1)]
    (letfn [(calc  [n limit total]
               (if (< n limit)
                 (let [next-n (inc n)]
                   (send-off *agent* calc limit (* total next-n))
                   next-n)
                 total))]
      (await (send-off a calc x 1)))
    @a))

and observed the following behavior:
user=> (for [x (range 10)] (factorial-using-agent-recursive 5))
(2 4 3 120 2 120 120 120 120 2)
user=> (for [x (range 10)] (factorial-using-agent-recursive 5))
(2 2 2 3 2 2 3 2 120 2)
user=> (for [x (range 10)] (factorial-using-agent-recursive 5))
(120 120 120 120 120 120 120 120 120 120)

Moral of the story is: don't use agents for synchronous calculations. Use them for asynchronous independent tasks - like updating animations displayed to a user :)
 FWIW, here's how I load zenburn in my .emacs:
(require 'zenburn)
(zenburn)

Loads fine via emacsclient.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

",Answer not found.,0.3132,[[0.]],1.7630671019759805e-16,0.008103727714748784,0.0,0.0,0.0
"I want to access the contents of the current region as a string within a function.  For example:
(concat ""stringa"" (get-region-as-string) ""stringb"")

Thanks
Ed
","buffer-substring together with region-beginning and region-end can do that.
","The sequence of frames is the linked list (of frames) pointing 'upwards' towards the global environment.  So when an environment is created (for example, in the context of a procedure binding), the 'environment' is a pointer to the frame...which in term points to the enclosing environment (or null, if the global environment).
So ... a qualified 'yes'...it's the first frame in the sense that the rest of the environment is accessible from that first frame.
Does that help?
Cordially,
Dak
 To copy loop use
(setq new_tour (copy-list loop))

 Open the file and read in the data:
(with-open-file (f ""file.txt"")
  (read f))

 out is the stream variable bound to the open file.
with-open-file guarantees that the file is open inside the scope, and closed
outside the scope, no matter how you exit.
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 As mentioned in first comment it is necessarily to use (list a b c) form.
","To access the contents of the current region as a string within a function in Emacs Lisp (which is often associated with Lisp), you can use the `region-beginning` and `region-end` functions to get the positions of the region, and then use `buffer-substring` to extract the text. Here's an example:\n\n```lisp\n(defun my-function ()\n  (let ((beg (region-beginning))\n        (end (region-end)))\n    (when (and beg end)\n      (let ((region-string (buffer-substring beg end)))\n        (concat ",0.5126,[[0.41393118]],0.030477428684296395,0.2307692307692308,0.1875,0.10638297872340424,0.14583333333333331
"According to manual, methods runtime and system-clock return: 

the amount of process time, in seconds, that has elapsed since Scheme was
  started.

However, calling them in REPL always return value 0.1:
1 ]=> (runtime)
;Value: .01
1 ]=> (system-clock)
;Value: .01

Any ideas what is happening here?
mit-scheme version:
Release 9.1.1 || Microcode 15.3 || Runtime 15.7 || SF 4.41 || LIAR/x86-64 4.118

","These procedures don't give you the real time that has elapsed since you started scheme but the time it has taken to process scheme code, not including system calls. Thus you have evaluated two expressions that have taken very short time and the time you are looking at the prompt or writing code is not included since it doesn't process anything when it is waiting for a line of input. 
The code below takes almost 2 seconds to complete and sure enough it shows that it has been working for 1.49s.
(begin
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

  (fib 30)
  (system-clock))
; ==> 1.49

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

 There is an ASDF library called shut-it-down that provides a quit function that works by just having cases for the common CL implementations.
 You got rid of the msg parameter, but you were still trying to use it. Use let to bind a local variable to that value.
(defun timed-notification()
  (interactive)
  (let ((msg ""Take a break, time's up!""))
    (run-at-time 25 nil (lambda (mess) (terminal-notifier-notify ""pomodoro"" mess)) msg)))

","The values returned by `runtime` and `system-clock` are not necessarily the total elapsed time since Scheme was started. These functions measure the process time and system clock time respectively for the current process. The value you're seeing (0.1 seconds) might be the cumulative time spent in the current evaluation context, such as within a function or during the current interactive session. If no significant computation has been done between evaluations, it would return a small non-zero value like 0.1 seconds.",0.5281,[[0.38886254]],0.08330817338155201,0.22351284758887716,0.35175879396984927,0.030456852791878174,0.16080402010050251
"I am using dynamic variables, let's call one of them *x* with a value of 10.
I want to change its value through a function call by passing the variable's name as the parameter:
(defun change-value (varname)
  (setf varname 20))

then calling (change-value *x*). If I understand correctly, varname takes local scope and therefore the setf has no effect outside change-value. So, *x* remains as 10 afterwards.
My question is, is there a way to make *x* equal to 20 through a function call similar to the above? I tried adding (proclaim '(special varname)) and (declare (special varname)) and they don't seem to do anything.
Oh, and defining a macro does more or less what I want, but I doubt this is good practice:
(defmacro change-value-macro (varname)
  `(setf ,varname 20))

(change-value-macro *x*)

","Defining
(defparameter *x* 10)
(defun change-value (varname) ; the argument name is misleading!
  (setf varname 20))

and calling (change-value *x*) does not buy you anything because change-value is a function and you just passed it 10 as the argument; it has no idea that *x* is involved. So, what the function does is modify the local binding of the variable varname, changing it from 10 to 20 and returning the latter.
You need to pass the symbol (variable name) itself:
(defun change-value (varname)
  (setf (symbol-value varname) 20))

and call it as (change-value '*x*) (note the quote mark ' before *x*).
","You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

","In Lisp, you cannot directly modify a dynamic variable's value from within a function by passing its name as a parameter. The issue arises because variables passed into functions are typically treated as local bindings unless declared as special. Declaring the variable with (proclaim '(special varname)) or (declare (special varname)) inside the function does not have an effect on the external scope of *x*.

However, you can achieve your goal by using a macro as you suggested, which is indeed a common and effective way to modify special variables within functions. Here's how you could define such a macro:

```lisp
(defmacro change-value-macro (varname)
  `(setf ,varname 20))

(change-value-macro *x*)
```

This macro expands into the appropriate SETF form that can affect the external variable *x*. Macros are used in this case to allow for the necessary lexical expansion that enables modifying the special variable.

If you prefer not to use a macro, another approach is to pass the value explicitly:

```lisp
(defun change-value (varname new-value)
  (setf varname new-value))

(change-value *x* 20)
```

This function directly modifies the value of the passed-in variable.",0.6282,[[0.54472293]],0.236939962430118,0.4473212254526155,0.4081632653061224,0.136986301369863,0.21088435374149658
"here is my wonderful & working LISP racket ""intermediate with lambda"" style recursive function to determine the symbol with the highest value of symbols in a list.
(define maximum
  (lambda [x]
    (cond
      [(empty? x) 0]
      [(cons? x)
           (cond
             [(>= (first x) (maximum (rest x))) (first x)]
             [else (maximum (rest x))]
           )
      ]
    )
  )
)

(check-expect (maximum '(1 2 3)) 3)
(check-expect (maximum '(1)) 1)
(check-expect (maximum '(0)) 0)


How can I check for and optimize runtime?
Is recursion any different in runtime than iteration?
Thank you for your answer!
Kind regards,
","There is one main thing that will improve the performance greatly, taking it from exponential to linear time.
Don't re-compute the recursion, save it as an intermediate result.
In the inner cond expression, (maximum (rest x)) is computed twice. Once in the question of the first branch, and once is the answer of the second branch.
(cond
  [(>= (first x) (maximum (rest x))) (first x)]
  [else (maximum (rest x))])

In the common case where the first question is false, (maximum (rest x)) will be re-computed, doubling the work it has to do. Even worse, this doubling can potentially happen at every level of recursion in the worst case when the max is at the end. This is what makes it exponential.
To fix this, you can use local to define and name the intermediate result.
(local [(define maxrst (maximum (rest x)))]
  (cond
    [(>= (first x) maxrst) (first x)]
    [else maxrst]))

This takes the big-O complexity from exponential to linear in the length of the input.
There are other potential optimizations such as taking advantage of tail-calls, but those aren't as important as saving the intermediate result to avoid re-computing the recursion.
This method of improving performance using local definitions is also described in How to Design Programs 2e Figure 100: Using local to improve performance.
","You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Try adding :direction :output to create an output file stream:
(with-open-file (stream ""test.txt"" :direction :output
                                   :if-does-not-exist :create)
      (format stream ""success!""))

 You never assign the read input to your variables:
(defun func ()
  (print ""Enter first integer"") 
  (finish-output)
  (let ((a (read)))
    (print ""Enter second integer"")
    (finish-output)
    (let ((b (read)))
      (print (+ a b)))))

 Because the IF operator of Emacs Lisp allows one then form and multiple else forms. The else forms are indented differently from the then form for readability.
ELISP> (if (> 10 20)
           (print 'foo)
         (princ 'bar)
         (princ 'baz)
         nil)
barbaz
nil

",Answer not found.,0.3632,[[0.01055708]],3.538832272330698e-40,0.005205080158234438,0.008968609865470852,0.0,0.008968609865470852
"How do I get started?
","I have found the easiest way to achieve this by using Clojure.
Here is the example code:

(ns example
  (:require [clojure.contrib.sql :as sql])
  (:import  [java.sql Types]))

(def devdb {:classname ""oracle.jdbc.driver.OracleDriver""
            :subprotocol ""oracle""
            :subname ""thin:username/password@localhost:1509:devdb""
            :create true})

(defn exec-ora-stored-proc [input-param db callback]
  (sql/with-connection db
    (with-open [stmt (.prepareCall (sql/connection) ""{call some_schema.some_package.test_proc(?, ?, ?)}"")]
      (doto stmt
        (.setInt               1 input-param)
        (.registerOutParameter 2 Types/INTEGER)
        (.registerOutParameter 3 oracle.jdbc.driver.OracleTypes/CURSOR)
        (.execute))
      (callback (. stmt getInt 2) (. stmt getObject 3)))))

(exec-ora-stored-proc
 123 ;;input param value
 devdb
 (fn [err-code res-cursor]
   (println (str ""ret_code: "" err-code))
   ;; prints returned refcursor rows
   (let [resultset (resultset-seq res-cursor)]
     (doseq [rec resultset]
       (println rec)))))

","You could start at the beginning: http://www-formal.stanford.edu/jmc/recursive.html
 A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Here's how:

Click on the ""run"" button, as you discovered
Press Esc  + p

And this is the relevant page in the documentation.
 Start with the second edition. Unless you are an instructor, use the draft version not the stable one. 
Switch to the first edition for Parts V and VI for now. I am developing replacements now but no promises. 
Parts VII and VIII will not be replaced. 
","To get started with Lisp programming, you can begin by familiarizing yourself with basic constructs and functions. A good resource is the Stanford website mentioned: http://www-formal.stanford.edu/jmc/recursive.html. It recommends creating access functions for data records using first, second, and third instead of car, cdr, etc., to make your code more readable. For example, you can define these functions as follows:\n\n```lisp\n(defun first (lst) (car lst))\n(defun rest (lst) (cdr lst))\n(defun second (lst) (first (rest lst)))\n(defun third (lst) (second (rest lst)))\n```\nYou can then use these functions to access elements in a list. For generating combinations, you can follow the approach of converting 2^n to binary and counting down from that number, as described. Start by checking your Lisp environment setup and using the `run` command with `Esc + p`. The documentation starting from the second edition is recommended for learning, especially the draft version unless you are an instructor.",0.5002,[[0.06390853]],0.037761734453293685,0.2210370445496112,0.08724832214765099,0.006756756756756756,0.053691275167785234
"I would like to do something akin to this:
(defstruct person
  real-name
  (fake-name real-name)) ;if fake-name not supplied, default to real-name

However, Common Lisp says The variable REAL-NAME is unbound. So how can I get the constructor to evaluate its arguments sequentially (like I can with function keyword arguments), or how else should I be better doing this?
","One way is:
(defstruct (person
             (:constructor make-person (&key real-name
                                             (fake-name real-name))))
  real-name
  fake-name)

You can essentially tailor the constructor function to your needs, including

providing a different name than make-xxx
having Lisp generate a ""by-order-of-arguments"" (BOA) constructor instead of a keyword-based one

Consider 
(defstruct (person 
             (:constructor make-person (real-name
                                        &optional (fake-name real-name))))
    real-name
    fake-name)

You can even initialize constructed fields using the &aux lambda-list keyword:
(defstruct (person
             (:constructor make-person (real-name
                                        &aux (fake-name (format nil
                                                                ""fake-of-~A""
                                                                real-name)))))
    real-name
    fake-name)

","The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 It is bad style to setq an unknown name.  It is assumed that you mean to create a new global special variable, then set it, but this should be made explicit by introducing these bindings first.  You do this at the top level by using defvar (or defparameter or defconstant) instead, and in lexical blocks by using let, do, multiple-value-bind or similar constructs.
 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

 In the cond special form, there's an implicit begin after each condition, so it's ok to write several expressions, remembering that only the value of the last one will be returned. Like this:
(cond [<first condition>
       (set! global-variable value)
       ""string to return""]
      [else
       ""other return value""])

","In Common Lisp, you cannot use the same syntax for default argument values as in some other languages. Instead, you can achieve similar functionality by using a lambda function or a let binding within your defstruct form to set default values conditionally. Here is an example of how you can do this:\n\n```lisp\n(defstruct person\n  real-name\n  (fake-name (let ((name (slot-value this 'real-name)))\n               (if name name \",0.6185,[[0.49178595]],0.03378074707886102,0.1579161254125746,0.33707865168539325,0.07954545454545454,0.20224719101123595
"I want to create several items for each call to a recursive function, and collect everything in a list. That is, I want to do something like this:
(defn myfunc [x]
  (loop [x x retur '()]
    (when condition1
      (let [templist '()]
        (if condition2 (def templist (conj templist {:somekey someval})))
        (if condition3 (def templist (conj templist {:somekey someval})))
        (recur (+ x 1) (concat retur templist))))))

The problem is that in Clojure I can't rebind a let. I would like to avoid using global variables. 
","Some of the functions in core use this pattern of chaining the same symbol through a let to conditionally build up a value. I had to change contition1 to an example that would not loop forever, and change the when to an if so it could return a value at the end of the loop.
(defn myfunc [x someval1 someval2 condition1 condition2 condition3]
  (loop [x x retur '()]
    (if (condition1 x)
      (let [templist '()
            templist (if condition2 (conj templist {:somekey1 someval1}) templist)
            templist (if condition3 (conj templist {:somekey2 someval2}) templist)]
        (recur (+ x 1) (concat retur templist)))
      retur)))

which can then be tested:
 user> (myfunc 0 1 2 #(< % 5) true true)
 ({:somekey2 2} {:somekey1 1} {:somekey2 2} {:somekey1 1} {:somekey2 2} 
  {:somekey1 1} {:somekey2 2} {:somekey1 1} {:somekey2 2} {:somekey1 1})

user> (myfunc 0 1 2 #(< % 5) true false)
({:somekey1 1} {:somekey1 1} {:somekey1 1} {:somekey1 1} {:somekey1 1})

The idea in the let is to have each stage change the value if the condition is true, or return it unchanged if the condition is false. This pattern gives functional code an imperative look and can help to make it clear how a value is constructed, though it can also be taken too far in using it to ""convert"" imperative logic into a functional program.
","Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 An alternate approach:
(require 'cl)

(defun is-useless-buffer (buffer)
  (let ((name (buffer-name buffer)))
    (and (= ?* (aref name 0))
         (not (string-match ""^\\*shell\\*"" name)))))

(defun kill-useless-buffers ()
  (interactive)
  (loop for buffer being the buffers
        do (and (is-useless-buffer buffer) (kill-buffer buffer))))

","In Lisp, particularly in Common Lisp (CL), you can achieve your goal by avoiding rebindings within `let` and instead modifying a collection passed through the recursive call. Here is how you can rewrite your function to accumulate items without using global variables or rebindings:\n\n```lisp\n(defun myfunc (x retur)\n  (when condition1\n    (let ((templist '()))\n      (if condition2 (push {:somekey someval} templist))\n      (if condition3 (push {:somekey someval} templist))\n      (myfunc (+ x 1) (append retur templist)))))\n```\n\nIn this version, `retur` is passed down the recursion stack, and you use `push` to add elements to `templist`. After modifying `templist`, it gets appended to `retur`. Note that `concat` in your original code should be replaced with `append` as `append` is the correct function for concatenating lists.",0.6279,[[0.33892814]],0.1387560240020993,0.22000597904603297,0.31085043988269795,0.04129793510324484,0.17008797653958946
"I am trying to do a simple task of appending a number to a string multiple times, and hoping that this will build a string.
But it is not working, each call to (string-append ....) seems to do nothing at all.
Here is my code:
(define myString """")
(string-append (number->string 4) myString)
(string-append (number->string 5) myString)
(string-append (number->string 6) myString)
(string-append (number->string 7) myString)
(display myString)

this displays:
""4""
""5""
""6""
""7""
and a blank line for (display myString)
What am I doing wrong?
also if I do it the other way like so it doesn't work either:
(define myString """")
(string-append myString (number->string 4))
(string-append myString (number->string 5))
(string-append myString (number->string 6))
(string-append myString (number->string 7))
(display myString)

Thanks for any help
","string-append does not alter an existing string; it returns a new string that is the result of the operation.
If this seems unusual, consider the addition operator, +. When I write 
3+4
I'm not changing 3 into 7, just returning the result of the operation.
So, in your case, if you write
(define my-string (string-append (number->string 4) (number->string 5)))
(display my-string)

You should see
45

To advise you further, it might help to know where you're heading with this.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 The code as you pasted is fine.
The behavior you describe is indicative of lisp choking on a non-ascii character.
Please copy the code into Emacs and find the offending character using, e.g., 
(defun my-search-for-non-acsii ()
  (interactive)
  (skip-chars-forward ""\000-\177""))

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","In Common Lisp, `STRING-APPEND` does not modify its first argument directly. Instead, it returns a new string that is the result of appending all its arguments together. Therefore, you need to assign the result back to your variable or use other methods to concatenate strings. Here’s how you can do it correctly:\n\n```lisp\n(define myString (\",0.5608,[[0.38331584]],0.1841114217555527,0.2265705458290422,0.35374149659863946,0.1793103448275862,0.27210884353741494
"I discovered that special forms can not be passed as arguments or saved in variables, both in Clojure:
user=> (defn my-func 
         [op] 
         (op 1 2 3))
#'user/my-func
user=> (my-func +)
6
user=> (my-func if)
java.lang.Exception: Unable to resolve symbol: if in this context (NO_SOURCE_FILE:5)
user=> (def my-if if)
java.lang.Exception: Unable to resolve symbol: if in this context (NO_SOURCE_FILE:9)

and in Racket/Scheme:
> (define (my-func op)
    (op 1 2 3))
> (my-func +)
6
> (my-func if)
  if: bad syntax in: if
> (define my-if if)
  *if: bad syntax in: if

That's cool, I'm fine with that, I know that I can just write a function to wrap a special form and then pass that function.  
But I'd like to know why Lisps have this restriction, and what negative consequences allowing this would have.  Are they any major dialects that do allow that?
","It makes evaluation more complicated and compilation hard.
If you have a form (a b c), then you need to resolve at runtime the value of a and then apply it somehow to the forms b and c.
The simpler model of a few limited number of special forms and otherwise strict evaluation is then gone.
See also: FEXPR
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Not clear what you are asking, but ignoring errors simply is:
CL-USER 37 > (ignore-errors (read-from-string ""(. foo bar)""))
NIL
#<CONDITIONS:SIMPLE-READER-ERROR 402000243B>

In case of an error, IGNORE-ERRORS returns NIL and as the second return value the condition.
If you want more control, you would need to write an error handler.
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
","Lisps restrict special forms from being passed as arguments or saved in variables due to their design philosophy and the nature of how these forms are evaluated. Special forms like `if`, `begin`, `let`, etc., have a specific structure that is recognized by the Lisp reader and evaluator, which allows them to perform operations such as control flow or variable binding at the syntax level rather than just returning values.\n\nAllowing special forms to be passed around as ordinary functions could lead to several negative consequences:\n1. **Loss of Context**: Special forms often rely on specific lexical context that might not be available when they are called as regular functions.\n2. **Error Prone**: The semantics of these forms are closely tied to their evaluation at the top level or within certain constructs; invoking them outside of this context could lead to unexpected behavior or errors.\n3. **Inconsistent Behavior**: Special forms are designed to interact with the Lisp environment in a specific way that might not be replicable by a simple function call.\n\nHowever, as you mentioned, wrapping special forms into functions is a common workaround in Lisps like Clojure and Scheme. This approach maintains the benefits of the special form while allowing for more flexibility in code organization and reuse.",0.4796,[[0.32627704]],0.05670944918098333,0.30835069438240525,0.21481481481481482,0.014925373134328358,0.13333333333333336
"I have this list code block.
(defun test (y)
    (do 
        ((l NIL (setq y (rest y))))
        ((null y) 1)
        (setq l (append l '(1 1)))
        (print l)
    )
)

And the output is pictured below. For some reason it's setting l to y and then appending '(1 1). Can anyone explain this behavior?

","The structure of a do loop is:
(do ((var init-form step-form))
    (termination-form result-form)
  (body))

I think what you're missing is that step-form is  executed at every iteration and the result of this form is set to the variable.  So using setq in the step-form is a flag that you're probably not doing what you intend.
So the sequence of the loop from (test '(2 3 4)) is (eliding the print)
 - Initialize l to nil
 - Check (null y) which is false since y = '(2 3 4).
 - (setq l (append l '(1 1))) l now has the value '(1 1)
 - Execute the step form, this sets y = '(3 4) _and_ l = '(3 4)
 - (null y) still false.
 -  (setq l (append l '(1 1))) sets l = '(3 4 1 1)
 - Execute step form, sets y = '(4) _and_ l = '(4)
 - (setq l (append l '(1 1))) sets l = '(4 1 1)
 - Execute step form, y = () so loop terminates.

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You never assign the read input to your variables:
(defun func ()
  (print ""Enter first integer"") 
  (finish-output)
  (let ((a (read)))
    (print ""Enter second integer"")
    (finish-output)
    (let ((b (read)))
      (print (+ a b)))))

 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
",Answer not found.,0.3449,[[0.01546596]],3.4546257139216562e-34,0.0060299083453931495,0.012121212121212121,0.0,0.012121212121212121
"I have an application I wrote in PHP (on symfony) that imports large CSV files (up to 100,000 lines). It has a real memory usage problem. Once it gets through about 15,000 rows, it grinds to a halt.
I know there are measures I could take within PHP but I'm kind of done with PHP, anyway.
If I wanted to write an app that imports CSV files, do you think there would be any significant difference between Ruby and Python? Is either one of them geared to more import-related tasks? I realize I'm asking a question based on very little information. Feel free to ask me to clarify things, or just speak really generally.
If it makes any difference, I really like Lisp and I would prefer the Lispier of the two languages, if possible.
","What are you importing the CSV file into? Couldn't you parse the CSV file in a way that doesn't load the whole thing into memory at once (i.e. work with one line at a time)?
If so, then you can use Python's standard csv library to do something like the following
import csv
with open('csvfile.csv', 'rb') as source:
    rdr= csv.reader( source )
    for row in rdr:
        # do whatever with row

Now don't take this answer as an immediate reason to switch to Python. I'd be very surprised if PHP didn't have a similar functionality in its CSV library, etc.
","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 On anything but Gentoo (which has a very well maintained Lisp overlay), I would use clbuild for now.  I have the hope that XCVB will be usable soon.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 It's very easy. This is the base case:
(remove-nth 0 '(2 3)) ; => (3)

And the default case:
(remove-nth 1 '(1 2 3))         ; ==
(cons 1 (remove-nth 0 '(2 3)))

The only thing left for you to do is to actually implement it!
There is a third case. What if the list is nil? In the strictest sense you cannot do the job and you should signal an error or perhaps there isn't anything to do so it's ok to then have it as a base case that evaluates to '() so that (remove-nth 5 '(1 2)) ; ==> (1 2)
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
","Given your interest in Lisp and the need for handling large CSV files efficiently, you might find Common Lisp or a dialect like Clojure more suitable. Common Lisp has strong support for memory management and can be quite efficient with large data sets due to its powerful garbage collection mechanisms and dynamic nature. Additionally, you could use ASDF (Another System Definition Facility) to manage your project dependencies, which is well-suited for Lisp projects.\n\nIf you're leaning towards a more specific language geared towards import-related tasks, both Ruby and Python have robust libraries and tools that can handle CSV imports efficiently. However, if you prefer sticking with Lisp, consider using a library like Quicklisp to manage your packages and dependencies. For example, the `cl-csv` package can be used for parsing CSV files in Common Lisp.\n\nHere's a simple example of how you might use `cl-csv` to read a CSV file:\n```lisp\n(require 'cl-csv)\n\n(defun read-csv (filename)\n  (with-open-file (stream filename :direction :input)\n    (cl-csv:csv-to-list stream)))\n\n;; Example usage\n(let ((data (read-csv \",0.5485,[[0.36150299]],0.07054317551972059,0.3217550274223035,0.2857142857142857,0.02675585284280936,0.1461794019933555
"In SICP lecture 2a, I'm confused on (average (f x) x). Can it not just be (average f x). Doesn't f mean the lambda of (/ x y) already? Why do I need (average (f x) x)?  Could someone help me out with the substitution method for this?
(define (sqrt x)
    (fixed-point
        (average-damp (λ (y) (/ x y)))
        1))

(define average-damp
    (λ (f)
        (λ (x) (average (f x) x))))

","This snippet:
(average (f x) x)

Means a different thing than this:
(average (f) x)

For starters, f is a function that expects a single parameter, which in this case must be x, hence we say (f x) . If you write (f) you're trying to call f with no parameters, resulting in an error. Substituting in average-damp after calling it with a value for the f parameter we discover that it returns another lambda, which is:
(λ (x)
  (average ((λ (y) (/ x y)) x) x))

As you can see, in this expression ((λ (y) (/ x y)) x), x is passed as a parameter to (λ (y) (/ x y)) x) (which was f), and x binds to the y parameter. Don't get confused! because now we have:
(/ x x)

But the first x at this point is not a variable, it's the value that was captured in a closure when calling sqrt, whereas the second x is the parameter in the lambda that we just returned, and is still unbound until the point where it gets called, presumably in fixed-point.
","The average-damp procedure takes a procedure as its argument and returns a procedure as its value. When given a procedure that takes one argument, average-damp returns another procedure that computes the average of the values before and after applying the original function f to its argument.  It's inside the fixed-point procedure where that returned function is applied (iteratively).
So the average-damp procedure doesn't execute either (/ x y) or (average(f whatami) whatami) at all, it just uses the function passed to it to create a new function that it returns.
 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 You need to include an (abs ...) in good-enough?, otherwise you don't just see if two values are close enough, but just if one value is greater than another (approximately).
(define (good-enough? guess x)
  (< (abs (- guess (improve guess x))) 0.00001))

 This snippet:
(average (f x) x)

Means a different thing than this:
(average (f) x)

For starters, f is a function that expects a single parameter, which in this case must be x, hence we say (f x) . If you write (f) you're trying to call f with no parameters, resulting in an error. Substituting in average-damp after calling it with a value for the f parameter we discover that it returns another lambda, which is:
(λ (x)
  (average ((λ (y) (/ x y)) x) x))

As you can see, in this expression ((λ (y) (/ x y)) x), x is passed as a parameter to (λ (y) (/ x y)) x) (which was f), and x binds to the y parameter. Don't get confused! because now we have:
(/ x x)

But the first x at this point is not a variable, it's the value that was captured in a closure when calling sqrt, whereas the second x is the parameter in the lambda that we just returned, and is still unbound until the point where it gets called, presumably in fixed-point.
 (make-hash-table :test #'equal)

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","The expression `(average (f x) x)` is used because `f` is a function that takes one argument. In this case, `f` is defined as `(λ (y) (/ x y))`. When you write `(f x)`, you are passing the value of `x` to the function `f`, and the result of that is then averaged with `x`. If you were to simply use `(average f x)`, it would not make sense because `f` is a procedure (function), not a number, and averaging a function with a number does not have a meaningful interpretation in this context. The expression `(average (f x) x)` correctly applies the function `f` to `x`, computes its result, and then averages that result with `x`. This is crucial for the iterative approximation process used in the `sqrt` procedure.",0.6073,[[0.5261835]],0.24649874274669129,0.2921080846231584,0.5194805194805195,0.18300653594771243,0.26623376623376627
"It is stated in section ""Global variables and constants"" of the Google Common Lisp Style Guide that:
""Common Lisp does not have global lexical variables, so a naming convention is used to ensure that globals, which are dynamically bound, never have names that overlap with local variables. 
It is possible to fake global lexical variables with a differently named global variable and a DEFINE-SYMBOL-MACRO. You should not use this trick, unless you first publish a library that abstracts it away.""
Can someone, please, help me to understand the meaning of this last sentence.
","The last sentence,

You should not use this trick, unless you first publish a library that abstracts it away.

means that if you do something that simulates global lexical variables, then the implementation of that simulation should not be apparent to the user.  For instance, you might simulate a global lexical using some scheme using define-symbol-macro, but if you do, it should be transparent to the user.  See Ron Garret's GLOBALS — Global Variables Done Right for an example of “a library that abstracts it away.”
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 It is bad style to setq an unknown name.  It is assumed that you mean to create a new global special variable, then set it, but this should be made explicit by introducing these bindings first.  You do this at the top level by using defvar (or defparameter or defconstant) instead, and in lexical blocks by using let, do, multiple-value-bind or similar constructs.
 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

 You are using the ""extended"" loop form, so you need to do 
(loop while ...
  do ...)

instead of
(loop while ...
  ...)

This is what the error is telling you: it wants a keyword after while condition, and it found the first statement of the body.
You might want to review The LOOP Facility more carefully.
PS. Please bind local variables using let or, in loop, with, before setting them with setq. Otherwise your variables are global specials.
PPS. Please indent your code properly; you can use Emacs for that.
 The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

 What you are seeing is the output being concatenated for brevity. The actual list is correct and not affected, but because it would be too long to print to the output, the lisp REPL shortens it when printing and uses # to indicate that it has done so.
","The sentence suggests that if you do decide to use the trick of faking global lexical variables with DEFINE-SYMBOL-MACRO, you should first create a library that abstracts away this complexity. This means that once you have encapsulated this behavior within a well-documented and tested library, you can then safely expose it for others to use without them needing to understand the underlying implementation details. This promotes better code organization and maintainability by providing a clean interface.",0.624,[[0.51797544]],0.24400841044181074,0.35059153039832286,0.4790419161676646,0.14545454545454548,0.25149700598802394
"I am still learning Lisp language and I need to understand how to implement a stack with Lisp (Need push-pop-peek functions.). In addition I have found this code when I am searching for help. But I am not sure if it is working properly.
(defstruct stack
  elements)

(defun stack-push (element stack)
  (push element (stack-elements stack)))

(defun stack-pop (stack)(deftype Stack [elements])

(defun stack-empty (stack)
  (endp (stack-elements stack)))

(defun stack-top (stack)
  (first (stack-elements stack)))

(defun stack-peek (stack)
  (stack-top stack))

","Lisp lists are actually functional stacks in and of themselves.
(cons a l) pushes a to the stack l.
(car l) returns the first element (a peek).
(cdr l) returns all but the first element (a pop).
","I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

 This is an often asked question. There are possibly duplicates of this on Stackoverflow.
The output can be buffered.
You then need to call the standard Common Lisp function FINISH-OUTPUT to force the IO system to write any pending output.
After that, read.
 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 There is no such built-in operator that I am aware of, but I think that you can get this functionality quite quickly:
(defmacro assoc-pop (key alist)
  `(let ((result (assoc ,key ,alist)))
     (setq ,alist (delete result ,alist))
     result))

 One option is to put (sb-ext:disable-debugger) early in your startup function. When an error occurs and there is no handler, SBCL will print an error and a backtrace and exit.
Another option is to write a function that does what you want on error and set it as your debugger hook; see command-line-debugger in buildapp itself for an example.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
","The provided code for implementing a stack in Lisp is mostly correct but has a small issue. The `deftype Stack [elements]` line should be removed as it's not necessary and doesn't define anything. Here is the corrected version of your stack implementation:\n\n```lisp\n(defstruct stack\n  elements)\n\n(defun stack-push (element stack)\n  (push element (stack-elements stack)))\n\n(defun stack-pop (stack)\n  (if (stack-empty stack)\n      nil\n      (pop (stack-elements stack))))\n\n(defun stack-empty (stack)\n  (endp (stack-elements stack)))\n\n(defun stack-top (stack)\n  (if (stack-empty stack)\n      nil\n      (first (stack-elements stack))))\n\n(defun stack-peek (stack)\n  (stack-top stack))\n```\nThis code defines a `stack` structure with an `elements` field, and provides `push`, `pop`, `empty?`, `top`, and `peek` functions for working with the stack. Note that `stack-pop` returns `nil` if the stack is empty to avoid errors, which might be more appropriate depending on your use case.",0.4713,[[0.25105673]],0.03932389295325195,0.28225806451612906,0.2115384615384615,0.019417475728155338,0.11538461538461539
"What I'm trying to do is this:
(defgeneric fn (x))

(defmethod fn ((x (integer 1 *)))
    ""Positive integer"")

(defmethod fn ((x (integer * -1)))
    ""Negative integer"")

I want a generic function that works with arbitrary type specifiers, including the list-based ones such as (and x y), (or x y), (satisfies p), etc. Now when I attempt to run the above code, I get an ""Invalid Specializer"" error. A little bit of research reveals that defgeneric is designed to work with CLOS, not with arbitrary type specifiers. Is there a defgeneric-like system in Common Lisp that would get me the behavior I want for arbitrary type specifiers, not just classes?
","Common Lisp defines two hierarchies which are related but not identical: the type hierarchy and the class hierarchy.  Every class is a type, but the converse is not true — there are types that are not classes.  For example, integer and string are classes, and therefore also types.  On the other hand, (integer 1 *) and (satisfies evenp) are types, but not classes.
> (type-of ""toto"")
(SIMPLE-BASE-STRING 4)
> (class-of ""toto"")
#<BUILT-IN-CLASS STRING>

Parameter specialisers — the things that you put after parameters in defmethod — can only be class names (or of the form (eql value)).  Since (integer 1 *) is not a class name, your code is not allowed by Common Lisp.  There is an excellent reason for that: the compiler is always able to determine the class hierarchy, while the type language is way too powerful for that:
(defun satisfies-the-collatz-conjecture (n)
  (cond
    ((<= n 1) t)
    ((evenp n) (satisfies-the-collatz-conjecture (/ n 2)))
    (t (satisfies-the-collatz-conjecture (+ 1 (* n 3))))))

(subtypep 'integer '(satisfies satisfies-the-collatz-conjecture))
NIL ;
NIL

If you really need your code to be modular, you will need to first classify your values into something that can be made into a specialiser, and then dispatch on that:
(defmethod fn-generic (x (sign (eql 'positive)))
  ""Positive integer"")

(defmethod fn-generic (x (sign (eql 'negative)))
  ""Negative integer"")

(defun classify (x)
  (cond
    ((< x 0) 'negative)
    ((= x 0) 'null)
    ((> x 0) 'positive)))

(defun fn (x)
  (fn-generic x (classify x)))

","The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
","The issue you're encountering is due to the fact that `defgeneric` and its methods are designed to work with CLOS (Common Lisp Object System) classes or specific type specifiers, not arbitrary type specifiers. To handle a more general case where you want to define generic functions based on any kind of type specifier, including lists like `(and x y)` or `(or x y)`, you would need to implement your own logic outside of `defgeneric` and CLOS.\n\nOne approach is to use pattern matching libraries or macros that can interpret these type specifiers. However, this requires a more complex setup and might involve defining your own macro or using existing tools like `match` from the `cl-match` package (or similar).\n\nHere's an example of how you could start implementing such functionality with a custom macro:\n\n```lisp\n(defmacro defgeneric-with-type-specifiers ((name &rest specifiers) &body body)\n  \",0.5224,[[0.26329332]],0.05098802152143412,0.17720013069850812,0.271356783919598,0.015151515151515152,0.11557788944723618
"I am looking for tools that check the well-formness/schema of S-expressions. 
Are you aware of such tools ?
As precised by Paul Nathan, what I'm exactly looking for is a Schema validator for sexp. 
","I suspect that OP question is about replacing the XML technology stack with S-expressions and Lisp.
An idiomatic approach with S-expressions is to implement ad hoc validators and transformers, tailored for specific data formats. Since Lisps are nearly declarative (and they allow defining countless possible declarative languages on top of them) there is no need in a specialised, common solution like XML Schema or DTD.
Depending on the Lisp flavour you're using, you can choose a pattern matching library suitable for your needs. Embedded Prolog implementations (like Schelog) can help too.
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 It stands for Aesthetic.  A-formatted output is not escaped.  See http://www.lispworks.com/documentation/HyperSpec/Body/22_cda.htm
Incidentally, S stands for Standard rather than S-expression.
 It makes evaluation more complicated and compilation hard.
If you have a form (a b c), then you need to resolve at runtime the value of a and then apply it somehow to the forms b and c.
The simpler model of a few limited number of special forms and otherwise strict evaluation is then gone.
See also: FEXPR
 I am not a smartparens user but I found the answer from its wiki: 
You can bind ) to sp-up-sexp command: 
(define-key smartparens-mode-map "")"" #'sp-up-sexp) 

 The source code is read by the Lisp reader before evaluation (see read). The reader can't intern the symbols if the packages aren't already defined.
 You are comparing a list containing 1 & 2 with a list containing the symbols a & b. Symbols are legitimate values in Clojure. '(a b) is equivalent to (list 'a 'b) not (list a b).
 (= '(1 2) (list a b))

Is probably the comparison you want.
","There are several tools that can help with validating and checking the well-formedness of S-expressions (S-exps) in Lisp. One popular tool is `cl-ppcre`, which can be used for regular expression matching to validate S-exp structures. Another option is to use a custom function or library designed specifically for this purpose, such as `sexp-validation` on Quicklisp.

Additionally, you might consider using a more comprehensive solution like `alexandria` and its associated utilities, though it primarily focuses on Lisp programming utilities rather than validation. For a dedicated schema validator, you could look into integrating a JSON schema validator since S-exps can be represented in JSON format, or explore libraries that support custom schema definitions for S-exps.

If you need a more specialized solution tailored to your specific needs, you might want to implement a parser-combinator library or a dedicated S-exp validation function.",0.5777,[[0.33168254]],0.152123265898522,0.3631607931793789,0.3703703703703704,0.049792531120331954,0.18106995884773663
"I've read that javascript was in part based on Scheme, a dialect of LISP. When I was reading about this and LISP, it struck me that the javascript function expression syntax seemed like a similar kind of structure. My understanding of s-expressions is that all syntax is either treated as an atom, or s-expressions which can then be recursively referenced, and is eventually reduced down to an atom. If a javascript function treats the creation and reference of a function as just another variable (and arrays, strings, and numbers can all be assigned to variables too) does that mean that the javascript function expression is essentially a implementation of the s-expression idea?
","Sort of, they are first class functions which you can pass around as values.
This is very close to scheme's lexically scope lambda and lisp is the first language family to have this feature. but instead of the javascript function parameters having lexical they have ""function scope"".
Javascript's ""function scope"" is a bit less mathematically pure than lexical scope but it's a minor difference.
Regarding s-expressions, javascript has no equivalent to this - you can't ""quote"" pieces of javascript code to get a js AST object.
","Read McCarthy's 1960 paper, ""Recursive Functions of Symbolic Expressions and Their Computation By Machine, Part I"".
He starts by defining S-expressions.  One of the rules is that if e1 is an S-expression and e2 is an S-expression, then < e1 . e2 >, the dotted pair, is also an S-expression.
A few lines later, he defines the list notation, as a shorthand for an expression built up of a chain of dotted pairs.
This was the paper that first defined what would eventually become LISP.  It didn't become an actual programming language until Steve ""Slug"" Russell implemented the first interpreter.
 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 They are the same, since one gets expanded into the other.  The first expression is easier to both write & read; having it expand into the second simplifies the interpreter (something you should appreciate).
 Courtesy of Paul Graham, here's a Common Lisp implementation of John McCarthy's original LISP:
It assumes quote, atom, eq, cons, car, cdr, and cond, and defines null, and, not, append, list, pair, assoc, eval, evcon and evlis.
","Yes, your understanding is correct. JavaScript function expressions can be seen as an implementation of the s-expression idea from Lisp. In Lisp, all data structures are built using s-expressions, which consist of atoms or nested pairs (dotted pairs and lists). Similarly, in JavaScript, functions can be treated just like any other value and assigned to variables. This means that a function expression in JavaScript is essentially an s-expression where the function itself is a first-class citizen, much like how atoms, arrays, strings, and numbers are handled in Lisp. The functional nature of JavaScript, including higher-order functions and closures, also aligns well with the Lisp tradition.",0.5412,[[0.31157632]],0.13094147435683187,0.3359426449604867,0.33999999999999997,0.06060606060606061,0.16
"The cosine similarity of two lists can be calculated in linear time using a for-loop. I'm curious as to how one would achieve this using a Lisp-like language. Below is an example of my code in Python and Hy (Hylang).
Python:
def cos_sim(A,B):
    import math as _math
    n,da,db,d = 0,0,0,0

    for a,b in zip(A,B):
        n += a*b
        da += a*a
        db += b*b

    da = _math.sqrt(da)
    db = _math.sqrt(db)
    d = da*db

    return n / (d + 1e-32)

Hy (Lisp):
(import math)

(defn l2norm [a]
    (math.sqrt (reduce + (map (fn [s](* s s)) a))))

(defn dot [a b]
   (reduce + (map * a b)))

(defn cossim [a b]
   (/ (dot a b) (* (l2norm a) (l2norm b))))

","""I'm curious as to how one would achieve this using a Lisp-like language."" This really depends on which Lisp you are using. In Scheme you might do something similar to the posted Hy solution:
(define (cos-sim-1 u v)
  (/ (dot-prod u v)
     (* (norm u) (norm v))))

(define (dot-prod u v)
  (fold-left + 0 (map * u v)))

(define (norm u)
  (sqrt (fold-left (lambda (acc x) (+ acc (* x x)))
                   0
                   u)))

This is linear in time complexity, but it could be improved by a constant factor by passing over the input only once. Scheme provides a named let construct that can be used to bind a name to a procedure; this is convenient here as it provides a simple mechanism for building the dot product and norms:
(define (cos-sim-2 u v)
  (let iter ((u u)
             (v v)
             (dot-product 0)
             (U^2 0)
             (V^2 0))
    (if (null? u)
        (/ dot-product (sqrt (* U^2 V^2)))
        (let ((x (car u))
              (y (car v)))
          (iter (cdr u)
                (cdr v)
                (+ dot-product (* x y))
                (+ U^2 (* x x))
                (+ V^2 (* y y)))))))

Both of these procedures assume that the input lists have the same length; it might be useful to add some validation code that checks this. Note that fold-left is standard in R6RS Scheme, but other standards rely on SRFIs for this, and some implementations may use different names, but the fold-left functionality is commonly available (perhaps as foldl or reduce).
It is possible to solve the problem in Common Lisp using either of the basic methods shown above, though in Common Lisp you would use labels instead of named let. But it would be typical to see a Common Lisp solution using the loop macro. The Common Lisp standard does not guarantee tail call elimination (though some implementations do support that), so explicit loops are seen much more often than in Scheme. The loop macro is pretty powerful, and one way that you could solve this problem while passing over the input lists only once is this:
(defun cos-sim (u v)
  (loop :for x :in u
        :for y :in v
        :sum (* x y) :into dot-product
        :sum (* x x) :into u2
        :sum (* y y) :into y2
        :finally (return (/ dot-product (sqrt (* u2 y2))))))

Here are some sample interactions:
Scheme (Chez Scheme):
> (cos-sim-1 '(1 0 0) '(1 0 0))
1
> (cos-sim-1 '(1 0 0) '(-1 0 0))
-1
> (cos-sim-1 '(1 0 0) '(0 1 0))
0
> (cos-sim-1 '(1 1 0) '(0 1 0))
0.7071067811865475

> (cos-sim-2 '(1 0 0) '(1 0 0))
1
> (cos-sim-2 '(1 0 0) '(-1 0 0))
-1
> (cos-sim-2 '(1 0 0) '(0 1 0))
0
> (cos-sim-2 '(1 1 0) '(0 1 0))
0.7071067811865475

Common Lisp:
CL-USER> (cos-sim '(1 0 0) '(1 0 0))
1.0
CL-USER> (cos-sim '(1 0 0) '(-1 0 0))
-1.0
CL-USER> (cos-sim '(1 0 0) '(0 1 0))
0.0
CL-USER> (cos-sim '(1 1 0) '(0 1 0))
0.70710677

","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 Read up on mapcar et al:
(defparameter a (list 1 2 3 4))
(mapcon (lambda (tail)
          (mapcar (lambda (x)
                    (cons (car tail) x))
                  (cdr tail)))
        a)
==> ((1 . 2) (1 . 3) (1 . 4) (2 . 3) (2 . 4) (3 . 4))

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

","In Lisp-like languages, you can calculate cosine similarity using similar concepts as shown in your Python and Hy examples. Here's how you can do it in Common Lisp:\n\n```lisp\n(defun l2norm (a)\n  (sqrt (reduce #'+ (mapcar #'(lambda (s) (* s s)) a))))\n\n(defun dot (a b)\n  (reduce #'+ (mapcar '* a b)))\n\n(defun cos-sim (a b)\n  (/ (dot a b) (* (l2norm a) (l2norm b))))\n\n;; Example usage:\n(let ((a '(1.0 2.0 3.0)) (b '(4.0 5.0 6.0)))\n  (cos-sim a b))\n```\nThis code defines functions `l2norm` for calculating the L2 norm, `dot` for computing the dot product, and `cos-sim` for finding the cosine similarity between two lists.\n\nNote that this example assumes that the input lists are of equal length. If they might not be, you would need to add additional checks or padding as necessary.",0.5826,[[0.49152692]],0.01406589242851432,0.10682337960848987,0.25406203840472674,0.056296296296296296,0.103397341211226
"I've seen it in An Introduction to Programming in Emacs Elisp, section 4.4.1:
(interactive
  (list (read-buffer
    ""Append to buffer: ""
    (other-buffer (current-buffer) t))
    (region-beginning)
    (region-end)))

It's surprisingly hard to Google what ""list"" means in lisp, because every page is a hit. I'm guessing it just makes a list of its arguments, in which case, why is it better or clearer to use than just making a list ""manually"" with another set of parentheses?
","That's because you cannot just use ""another set of parentheses"" to make a list.
Here's an expression that creates a list containing the numbers 1, 2, 3, 4.
(list 1 2 3 4)

However, you cannot use (1 2 3 4) or even ((1 2 3 4)) to express that.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The example is unfortunate, as it only leaves one argument after ""the opening of the parentheses"". But yes, that's how I also think about it. The simpler the better, :) as long as it is correct.
Except that of course the values in the list are first evaluated, so it's not a simply-syntactical process. But as a basic example,
(apply + (list 1 2 3)) 
== 
(      +       1 2 3 )

i.e. the parens around the arguments is what goes away.
For a non-trivial example, see

Matrix multiplication in scheme, List of lists

 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
","In Lisp, the `list` function indeed creates a new list from its arguments. It is generally clearer and more concise than manually creating a list with another set of parentheses, especially when dealing with multiple elements or dynamic arguments. For example, using `(list ...)` can handle variables that might change at runtime, whereas manually constructed lists would require fixed syntax and wouldn't be as flexible. This clarity and flexibility are why `list` is often preferred for generating lists dynamically.",0.5267,[[0.20332189]],0.12533087262473033,0.2867242733699921,0.21374045801526717,0.07751937984496124,0.12213740458015268
"I think I understand why there is a danger in allowing closures in a language using dynamic scope.  That is, it seems you will be able to close the variable OK, but when trying to read it you will only get the value at the top of global stack.  This might be dangerous if other functions use same name in the interim.
Have I missed some other subtlety?
","Yes, that's the basic problem. The term ""closure"" is short for ""lexical closure"", though, which by definition captures its lexical scope. I'd call the things in a dynamically scoped language something else, like LAMBDA. Lambdas are perfectly safe in a dynamically scoped language as long as you don't try to return them.
(For an interesting thought experiment, compare the problem of returning a dynamically scoped lambda in Emacs Lisp to the problem of returning a reference to a stack-allocated variable in C, and how both are impossible in Scheme.)
A long time ago, back when languages with dynamic scope were much less rare than today, this was known as the funargs problem. The problem you mention is the upward funargs problem.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Given that this expression is evaluated only for its effect (printing a message), you should explicitly return a value (any value!) as the result of the let form:
(let ((x 1))
  (cond ((< x 2)  
         (display ""hooray"")
         (newline))
        (else 
         (display ""bummer"")
         (newline)))
  'ok)

Now we'll get:
hooray
'ok

 I'm surprised that you get a result at all. I get an error:
*** - PROGN: variable THE has no value
The following restarts are available:
USE-VALUE      :R1      Input a value to be used instead of THE.
STORE-VALUE    :R2      Input a new value for THE.
ABORT          :R3      Abort main loop

The reason is that strings in Common Lisp must be in double quotes: ""Return ..."". Single quotes are only used to prevent evaluation.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
","Your understanding is correct. One of the dangers of closures in a language with dynamic scope is that a closure can capture a variable's value at the time it was created, but when that closure is later executed, it will access the current value of the variable in the dynamic environment, not necessarily the one it captured. This can lead to unexpected behavior if the variable's value changes between the creation and execution of the closure. Another subtlety is that closures can also capture variables from outer scopes, which might be out of scope by the time the closure is executed, leading to an unbound variable error or other runtime issues.",0.5291,[[0.38693896]],0.15844798455167003,0.3159870584939902,0.33613445378151263,0.05084745762711864,0.15126050420168066
"I'd like to know if it's possible to and how to implement a module system.
Here's example of how it works: I have some folder (e.g. modules), this folder has a bunch of clojure files that export some variables (e.g. name and regex), All modules are loaded into one list so it's possible to iterate and modules can be removed from it.
","the simplest thing you could do, is to load all these files one by one with load-file. https://clojuredocs.org/clojure.core/load-file
otherwise you could precompile your plugins' namespaces and load them using some of the java's native techniques (which i don't know much about, but i guess there are some nice libs for that)
update:
for some directory named ""/my/path"" it could look like the following:
(run! #(load-file (.getAbsolutePath %))
      (rest (file-seq (java.io.File. ""/my/path""))))

notice, that the file seq traverses the directory recursively, and includes all the files (not only *.clj). Maybe you would have to filter them:
(run! #(load-file (.getAbsolutePath %))
      (filter
       #(clojure.string/ends-with? (.getName %) "".clj"")
       (rest (file-seq (java.io.File. ""/my/path"")))))

","If the file contents have been read in, then, assuming there have been no errors thrown, all the forms of the contents have been executed. If one of those is a DEFUN form, then the function will have been defined.
To be precise, examine the LOAD definition in the HyperSpec.
 According to the CLHS:
load sequentially executes each form it encounters in the file
named by filespec

which means that a file is a sequence of forms.
 Judging from the question, I think that you have a strange setup.  It seems to indicate that you are writing your functions directly at the REPL.  Don't do that.
The usual setup is to have an IDE (for example, Emacs with Slime) where you edit a source file, and then ""send"" top-level forms (like function definitions) to the REPL.
 AutoLISP does not support multiple threads - programs are executed in 'series' using a single processor thread. As such, this is unfortunately not possible.
 It's very easy. This is the base case:
(remove-nth 0 '(2 3)) ; => (3)

And the default case:
(remove-nth 1 '(1 2 3))         ; ==
(cons 1 (remove-nth 0 '(2 3)))

The only thing left for you to do is to actually implement it!
There is a third case. What if the list is nil? In the strictest sense you cannot do the job and you should signal an error or perhaps there isn't anything to do so it's ok to then have it as a base case that evaluates to '() so that (remove-nth 5 '(1 2)) ; ==> (1 2)
 In Python you create an object by calling the constructor, a function that has the same name as the class. The exact same applies in Hy.
(import sys)
(import [PySide.QtGui [QApplication]])

(setf app (QApplication sys.argv))

Notes:

You assign the object created with setf
Be sure to import all the necessary modules

","In Lisp, implementing a module system involves creating separate files for each module and then loading these files into your application. You can achieve this by organizing your code structure such that modules are stored in specific directories and then loaded at runtime. Here’s a basic approach to implement a simple module system in Common Lisp:\n\n1. **Directory Structure**: Create a directory named `modules` where each subdirectory represents a different module.\n2. **Loading Modules**: Write a function to load the modules from these directories. This can be done by reading files and evaluating their contents.\n3. **Exporting Variables**: Use `export` to make variables available outside the module.\n\nHere’s an example:\n\n1. Directory Structure:\n```\nsrc/\n└── modules/\n    ├── mod1.lisp\n    └── mod2.lisp\n```\n\n2. **mod1.lisp**\n```lisp\n(defun foo () \",0.5207,[[0.11509466]],0.09810241055930075,0.26513341544044944,0.18796992481203006,0.022727272727272728,0.11278195488721805
"I'm learning Lisp and i don't understand some examples they give in a course for explaning lists and atoms.
I understand :

(A B) : 1 list, 2 atoms
(A B C) : 1 list, 3 atoms

I don't understand  this part:

(A (B C)) : 1 list, 1 atom

After thinking a lot, I think that :

A is the atom and (B C) is the list, but i don't really understand why....

why the first and the last parenthesis are not considered as being one list ?
why don't we count B and C as atoms here ?


Thanks in advance for any enlightenment on this weird thing :)
","I'd say the answer is wrong. For consistency with the previous answers, it should have been:

(A (B C)) : 2 lists, 3 atoms

Here's why: there are three atoms in total: A B C. There's a nested list: (B C) and an outer list: (A (B C)), totaling two lists.
It'd be correct to state that there's ""1 list, 1 atom"" if the question were ""count the top-level elements inside the list"" - but that's not consistent with the first two examples, which take into account all the atoms and lists shown, including the outer list.
","As mentioned in first comment it is necessarily to use (list a b c) form.
 I'd say the answer is wrong. For consistency with the previous answers, it should have been:

(A (B C)) : 2 lists, 3 atoms

Here's why: there are three atoms in total: A B C. There's a nested list: (B C) and an outer list: (A (B C)), totaling two lists.
It'd be correct to state that there's ""1 list, 1 atom"" if the question were ""count the top-level elements inside the list"" - but that's not consistent with the first two examples, which take into account all the atoms and lists shown, including the outer list.
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
","In the expression (A (B C)), there are two lists: one top-level list (A (B C)) and a nested list ((B C)). There are three atoms: A, B, and C. The confusion might arise from how Lisp represents nested structures. When you see (A (B C)), it's important to recognize that the entire structure is a single list at the top level, which contains another list as one of its elements. Thus, we count (B C) as a single list containing two atoms B and C, rather than counting B and C separately as individual lists.",0.6198,[[0.5131097]],0.3166371895452439,0.3657040682827657,0.45,0.1919191919191919,0.31
"Are there any good implementations, documents, etc. of Actor-esque concurrency libraries in Common Lisp? CLiki is rather vague on this subject.
And no, I'm not using Clojure and I won't use it for this. 
","zeromq (www.zeromq.org) has bindings for Common Lisp. It doesn't quite support the actor model (named pipes rather than named actors) but it might be what you are looking for.
Cliki suggests cl-actors (http://www.cliki.net/cl-actors) but I have no experience with this.
","I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 On anything but Gentoo (which has a very well maintained Lisp overlay), I would use clbuild for now.  I have the hope that XCVB will be usable soon.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 There is an ASDF library called shut-it-down that provides a quit function that works by just having cases for the common CL implementations.
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
","Yes, there are several concurrency libraries available in Common Lisp that implement actor-based models. The knowledge base mentions some specific implementations and resources. For example, cl-actors has been modified to include a `send-receive` construct as you described. Additionally, the ASDF library 'shut-it-down' provides functions for quitting the environment which might be useful depending on your needs. It's also worth checking out other libraries like 'fiveam' for testing actors and 'alexandria' for utility functions that can enhance your concurrency code.",0.5613,[[0.2172925]],0.09988212239246229,0.2830188679245283,0.26865671641791045,0.045454545454545456,0.14925373134328357
"I want to create a function that receives 2 arguments and returns a function that receives himself a board. That function needs to check user input and make changes in the board according to the input. I have no problems with the user input and the changes i have to do to the board. My problem is with the function that returns a function. To do that i'm using a lambda. This is the code i'm working on:
(defun faz-jogador-manual (n_aneis peca)
#'(lambda (tabuleiro)
    (setf jogada (le-posicao))
    (let ((num_anel (first jogada))
        (posicao_anel (second jogada))
        (tab (copia-tabuleiro tabuleiro)))
    (tabuleiro-poe-peca tab peca num_anel posicao_anel))))

This function should return a function lambda, but when i call the function using:
(faz-jogador-manual 3 'X)

i get the following:
#<Closure (:INTERNAL FAZ-JOGADOR-MANUAL 0) [X] @ #x2112f462>

I don't know what i'm doing wrong, is it the call? is the function per se? I need help with this one.
","Common Lisp is a Lisp-2, which means that it has a separate namespace for functions and values; as a result, functions need to be treated slightly specially in this case.  (This is in contrast to most Lisps.)
When you return a function as a value, you can't just invoke it in the same way as if you had defined it with defun.  You need to use funcall or apply to do so.  You can do it like this:
;; insert an appropriate argument in place of tabuleiro for the inner function
(funcall (faz-jogador-manual 3 'X) tabuleiro)

If you want to understand this behavior in more detail, you can probably find lots of references online, like this one.
","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
","Your current code defines a function that returns a lambda closure. The output you're seeing (#<Closure (:INTERNAL FAZ-JOGADOR-MANUAL 0) [X] @ #x2112f462>) is correct because it represents the returned lambda function in its compiled form. To use this lambda as intended, you should assign it to a variable and then call it with the appropriate arguments. Here's how you can modify your code to achieve this:\n\n```lisp\n(defun faz-jogador-manual (n_aneis peca)\n  (lambda (tabuleiro)\n    (setf jogada (le-posicao))\n    (let ((num_anel (first jogada))\n          (posicao_anel (second jogada))\n          (tab (copia-tabuleiro tabuleiro)))\n      (tabuleiro-poe-peca tab peca num_anel posicao_anel))))\n\n;; Usage example:\n(let ((faz-jogador (faz-jogador-manual 3 'X)))\n  (funcall faz-jogador my-board))\n```\nIn this modification, `faz-jogador-manual` returns the lambda directly. You then create a variable `faz-jogador` to store the returned function and use `funcall` to invoke it with the argument `my-board`. This should solve your issue.",0.561,[[0.38031614]],0.14320175334722413,0.35456791085103373,0.3424657534246575,0.09655172413793102,0.15753424657534246
"Using MIT-Scheme 9.x, is there a way using the debugger or some other tool to inspect an anonymous compound-procedure (created by returning a lambda function), e.g. to find out exactly what code at what line it comes from?
For example, I'm currently doing something like:
(foo 2 3)

And I see an error message like:
;The procedure #[compound-procedure 65] has been called with 2 arguments; it requires exactly 0 arguments.

...where foo is doing some further dispatch (foo is not the problem here, it lies deeper).  In this example, I'd really want to know the internals of #[compound-procedure 65] as it's obviously not what I expected.  Does a Lisp/Scheme wizard out there know a way to get those details?  Thanks.
","There are some interesting debugging tools described on this page: Debugging Aids.
From the short experiment I tried, I think you can use the pp function to inspect the source of a compound procedure object:
1 ]=> (define (sum-squares x y) (+ (* x x) (* y y)))

;Value: sum-squares

1 ]=> (sum-squares 3)

;The procedure #[compound-procedure 13 sum-squares]
;has been called with 1 argument
;it requires exactly 2 arguments.
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

2 error> (pp #[compound-procedure 13 sum-squares])
(named-lambda (sum-squares x y)
  (+ (* x x) (* y y)))
;Unspecified return value

2 error> 

It appears that you can even get the source of lambda functions and compiled functions:
1 ]=> (define (make-acc-gen n) (lambda (i) (set! n (+ n i)) n))

;Value: make-acc-gen

1 ]=> (pp (make-acc-gen 0))
(lambda (i)
  (set! n (+ n i))
  n)
;Unspecified return value

1 ]=> display

;Value 15: #[compiled-procedure 15 (""output"" #x16) #x1a #x101b23bd2]

1 ]=> (pp  #[compiled-procedure 15 (""output"" #x16) #x1a #x101b23bd2])
(named-lambda (display object #!optional port environment)
  (let ((port (optional-output-port port 'display)))
    (unparse-object/top-level object port #f environment)
    ((%record-ref (%record-ref port 1) 14) port)))
;Unspecified return value

1 ]=> 

There's some other interesting reflection tools on the linked page. MIT Scheme also has a bunch of stuff for messing with environments as first class objects which can be useful for certain debugging tasks. Hope that helps!
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
 I can give you a couple of pointers, because this looks like homework:

The base case of the recursion is when the list is empty (null), and not when there are less than two elements in the list
Consider defining a helper function with an extra parameter, an ""accumulator"" initialized in the empty list. For each element in the original list, cons it at the head of the accumulator. When the input list is empty, return the accumulator

As an aside note, the above solution is tail-recursive.
","To inspect an anonymous compound-procedure (such as a lambda function) in MIT-Scheme or other Scheme implementations, you can use the `disassemble` procedure. This will disassemble the compiled code and show you the machine instructions that correspond to your lambda function. However, if the procedure is not compiled, it might just print out the lambda form itself.\n\nFor example, you could define a lambda function and then disassemble it:\n```scheme\n(define my-lambda (lambda () ...))\n(disassemble 'my-lambda)\n```\nThis will give you insights into what the procedure does internally. If you want more detailed information about the source code of the lambda, you might need to look at the actual source file where it was defined or use a debugger if your Scheme implementation supports one.\n\nMIT-Scheme also has some debugging tools like `trace` and `step`, which can help in tracing function calls. For example:\n```scheme\n(trace my-lambda)\n(my-lambda)\n(step (my-lambda))\n```\nThese commands will provide you with more detailed information about the execution of your lambda function.",0.5357,[[0.28582669]],0.08352247191046619,0.19452143309436687,0.31018518518518523,0.06511627906976744,0.12962962962962965
"I am pretty new to using CLOS. Here, I wrote one possible way of defining a Queue using CLOS:
(defclass Queue ()
    ((queue-size
        :reader queue-size
        :initarg :queue-size
        :initform (error ""Provide a queue-size when initialising a Queue"")
        :type number)
    (elements
        :accessor elements
        :initform (make-array queue-size :initial-element nil))
    (put-ptr
        :accessor put-ptr
        :initform 0
        :type number)
    (get-ptr
        :accessor get-ptr
        :initform 0
        :type number)))

As you can see, I use the value of the slot queue-size to make the array in the slot elements. But, unfortunately, this gives me the following error:
*** - DEFAULT-ELEMENTS: variable QUEUE-SIZE has no value

As I said, I am pretty new to CLOS. Is there any way I can still do this? Is it possible to overwrite some kind of init method? If yes, how do I do this?
","In CLOS you can't directly refer to slots as variables. Also you can't refer to to other slots of the object in initforms.
The example, simplified:
CL-USER 27 > (defclass queue () (size elements))
#<STANDARD-CLASS QUEUE 4020001AB3>

CL-USER 28 > (describe (make-instance 'queue))

#<QUEUE 40200040CB> is a QUEUE
SIZE          #<unbound slot>
ELEMENTS      #<unbound slot>

We'll now set the elements slot:
CL-USER 36 > (defclass queue () ((size :initarg :size) elements))
#<STANDARD-CLASS QUEUE 42E0A2DBFB>

For that we write a initialize-instance :after method.
The usual initializing happens and after that our method runs. WITH-SLOTS allows us to use certain slots like variables in our code. Here we access the slots size and elements:
CL-USER 37 > (defmethod initialize-instance :after ((q queue) &rest initargs)
               (with-slots (size elements) q
                 (setf elements (make-array size :initial-element nil))))
#<STANDARD-METHOD INITIALIZE-INSTANCE (:AFTER) (QUEUE) 402000ADD3>

Without the macro WITH-SLOTS, using the function SLOT-VALUE, it looks like this:
CL-USER 38 > (defmethod initialize-instance :after ((q queue) &rest initargs)
               (setf (slot-value q 'elements)
                     (make-array (slot-value q 'size) :initial-element nil)))

Example:
CL-USER 39 > (describe (make-instance 'queue :size 10))

#<QUEUE 402000BE0B> is a QUEUE
SIZE          10
ELEMENTS      #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)

","I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Some things are standard: get-internal-run-time and get-internal-real-time:
(defvar *my-timings* nil)
(let ((run (get-internal-run-time))
      (real (get-internal-real-time)))
  (multiple-value-prog1 (my-code)
    (push (cons (- (get-internal-run-time) run)
                (- (get-internal-real-time) real))
          *my-timings*)))

Others are not (space and GC count), you need to find the implementation-specific versions.
You might also consider using with-timing - it provides progress reports including ETA.
Incidentally, in your code, memory allocation (make-array) dwarfs length (which is slot access for an array).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

","The error you are encountering is because the `queue-size` slot is being referenced before it has been initialized. In CLOS (Common Lisp Object System), slots are not automatically initialized to their default values unless explicitly defined with an `:initform`. To fix this, you can provide a meaningful value for `:initform` or initialize the slot in the constructor using `initialize-instance`. Here’s how you could modify your class definition to include a meaningful default value for `queue-size` and ensure proper initialization of the queue elements array within the `initialize-instance` method:\n\n```lisp\n(defclass Queue ()\n  ((queue-size\n     :reader queue-size\n     :initarg :queue-size\n     :initform 10 ; Provide a default value here\n     :type number)\n   (elements\n     :accessor elements\n     :initform nil) ; Initialize to nil, it will be set later in initialize-instance\n   (put-ptr\n     :accessor put-ptr\n     :initform 0\n     :type number)\n   (get-ptr\n     :accessor get-ptr\n     :initform 0\n     :type number)))\n\n(defmethod initialize-instance :after ((queue queue) &key)\n  (unless elements\n    (setf (elements queue) (make-array (queue-size queue) :initial-element nil))))\n```\n\nIn this updated class, the `initialize-instance` method ensures that the `elements` slot is initialized with a properly sized array based on the value of `queue-size`. This should resolve the error you are encountering.",0.5953,[[0.57780508]],0.24493642180348252,0.4073895938969824,0.4479638009049774,0.11363636363636363,0.20814479638009048
"To complete an exercise, I need to check if an element is in a list or not. I know that there is the function member in lisp, but our instructor is very strict and doesn't let us use things that haven't yet been covered in the course.
What would be a way to check if an atom is in a list by using only cond, nil, car, not, cdr, +, equal, defun?

Edit:
After Doseke's comment; here is an attempt:
(defun presence (list item)
   (cond
      ((atom list) nil)
      ((equal (car list) item) t)
      ((consp list) (presence (cdr list) item))
      (t nil)
      )
   )

edit: I changed the title to make it match with my actual question
","Since you are limited in used features, it could be something like this, i guess:
(defun member-2 (x xs)
  (cond ((not xs) nil)
        ((equal x (car xs)) xs)
        (t (member-2 x (cdr xs)))))

","As mentioned in first comment it is necessarily to use (list a b c) form.
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 The message seems pretty clear to me: you are trying to get the first element of an empty list, which conflicts with your specification.
Based on this reference, it seems that first expects a non-empty list, whereas car returns nil when your input is nil.
Either you handle the nil case explicitely with an endp test or you use car instead of first.
 You need to loop over a list, and if an element is a list, recurse into the sublist, exactly as you would implement a deep search. The only difference is that, in order to produce the required output, you need to carry on the s-expression retracing the functions you used to get there.
Here is one possible implementation. Note that I have used the more traditional car and cdr instead of first and rest - they are equivalent.
(defun whereis (who obj &optional (sexp (list 'quote obj)))
  (cond
   ; we found the object - return the s-expr
   ((eq obj who) sexp)
   ; try car and the cdr
   ((and obj (listp obj)) 
    (or (whereis who (car obj) (list 'car sexp))
        (whereis who (cdr obj) (list 'cdr sexp))))))

then:
? (whereis 'waldo '(emerson ralph waldo))
(CAR (CDR (CDR '(EMERSON RALPH WALDO))))

? (whereis 'waldo '(mentor (ralph waldo emerson) (henry david thoreau)))
(CAR (CDR (CAR (CDR '(MENTOR (RALPH WALDO EMERSON) (HENRY DAVID THOREAU))))))

? (whereis 'thoreau '(mentor (ralph waldo emerson) (henry david thoreau)))
(CAR (CDR (CDR (CAR (CDR (CDR '(MENTOR (RALPH WALDO EMERSON) (HENRY DAVID THOREAU))))))))

? (whereis 'scotty '(beam me up . scotty))
(CDR (CDR (CDR '(BEAM ME UP . SCOTTY))))

? (whereis 'waldo '(emerson ralph))
NIL

If your element can appear more than once, you could also build a list of results:
? (whereis 'c '(a b c d c b a))
((CAR (CDR (CDR '(A B C D C B A)))) (CAR (CDR (CDR (CDR (CDR '(A B C D C B A)))))))

with this code:
(defun whereis (who obj)
  (let ((res nil)) ; the final result
    (labels
        ; sub-function: walks the whole list recursively
        ((sub (obj sexp)
           ; found it - add to result list
           (when (eq obj who) (setf res (cons sexp res)))
           ; try car and cdr
           (when (and obj (listp obj))
             (sub (cdr obj) (list 'cdr sexp))
             (sub (car obj) (list 'car sexp)))))
      ; call sub-function
      (sub obj (list 'quote obj)))
    res))

","Based on the provided context and your request for a completion of the length function, here is how you can fill in the blanks:\n\n(define (length lst)\n  (if (null? lst)       ; if the list is empty\n      0                  ; return 0\n      (+ 1               ; otherwise add 1 and\n         (length (cdr lst)))))) ; advance the recursion over the rest of the list\n\nThe key points are to use (null? lst) to check for an empty list, return 0 if true, and use (cdr lst) to move to the next element in the list. The (+ 1 ...) part ensures that each recursive call adds one to the length as it progresses through the list.",0.6117,[[0.02844338]],0.1031851623783762,0.32912664717891615,0.08163265306122448,0.0,0.05442176870748299
"i want to mark buffers, that have unsaved changes, in the tabbar tab bar in emacs. Also i want to assign F1 - F12 to the buffer and open them by pressing the according button.
But since i have no programming practice in lisp, i have no idea where to start. Also i got the feeling that learning lisp to know how to configure emacs on a low lwevel is an incredible usefull skill.
So my question is not really how to archieve that, but rather where to start looking. And maybe how to start learning Lisp.
Thanks
","You can also look at tabbar.el to try and figure out where the actual text of the bar is created (i.e. where you'll want to add the ""unsaved"" indicators).  To figure out if a buffer has unsaved changes, you can use the buffer-modified-p function.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
","To get started with customizing Emacs using Lisp, you can follow these steps:\n\n1. **Understand Basic Emacs Lisp (Elisp):** Start by familiarizing yourself with the basics of Elisp, such as variables, functions, conditionals, and loops.\n2. **Read the Emacs Lisp Intro:** Use `C-h i m Emacs Lisp Intro` to access the official documentation on Emacs Lisp.\n3. **Experiment in an Interactive Shell:** Use `M-x eval-expression` to test small snippets of Elisp code interactively.\n4. **Learn About Key Bindings and Hooks:** Understand how to bind keys to functions using `global-set-key` or define hooks for specific modes.\n5. **Read the Documentation for Specific Features:** For example, you can learn about buffer management with `C-h f save-some-buffers` or key bindings with `C-h k F1`.\n\nRegarding your specific goal of marking buffers with unsaved changes and assigning F1-F12 to open them:\n\n- You can use the function `buffer-modified-p` to check if a buffer has unsaved changes.\n- To bind keys to specific buffers, you might want to look into using `global-set-key` in combination with functions that switch between buffers based on their names or properties.\n\nHere is a simple example to get you started:\n```lisp\n(defun my-mark-buffer ()\n  (interactive)\n  (when (buffer-modified-p)\n    (add-to-list 'my-unsaved-buffers (current-buffer))))\n(global-set-key (kbd \",0.5513,[[0.35597455]],0.07752543835463951,0.2821522309711286,0.21754385964912284,0.08480565371024734,0.14736842105263157
"The following code is intended to count down from the specified wait time and then evaluate the supplied form:
(defun wait (seconds form)
       (let ((end (+ (get-universal-time) seconds)))
         (do ()
          ((>= (get-universal-time) end)
           (eval form))
        (sleep 1))))

If I run:
(wait 5 (format t ""output""))

The result is that ""output"" will be sent to stdout before counting down. After outputting ""output"" the program still counts down as usual.
I get the expected results, in which ""output"" is sent to stdout AFTER the countdown is complete, with the following code:
(defun wait (seconds form)
       (let ((end (+ (get-universal-time) seconds)))
         (do ()
          ((>= (get-universal-time) end)
           (format t ""output""))
        (sleep 1))))

Why would the call to EVAL in the DO loop be evaluating when the DO loop is declared, but directly inserting the form being evaluated causes it to wait until result time?
","First law of Lisp programming for beginners: no, you don't need eval.
Your function does not get a form (foo), but the result of evaluating (foo). All arguments to functions are evaluated BEFORE the function will be called. Lisp does not call a function with the forms of the arguments, but with the results of evaluating the arguments.
Your code
(wait                   ; function wait
  5                     ; argument expression 1
  (format t ""output""))  ; argument expression 2

What happens?

wait is a function, get it.
evaluate 5 -> 5
evaluate (format t ""output"") -> NIL + output as a side effect
call the function wait with the arguments 5 and NIL

Improvement: pass a function
If you don't want to run the argument in the call, create a function (lambda () (foo)), which will be evaluated to a function object, pass that to a variable delayed-function, and call it with (funcall delayed-function).
What happens here?
(wait
  5
  (lambda ()
    (format t ""output"")))


wait is a function, get it.
evaluate 5 -> 5
evaluate (lambda () (format t ""output"")) -> a function object
call the function wait with the arguments 5 and the function object

Now your function wait needs to do what it wants and call the passed function object at the right place - using FUNCALL.
","Add a call to 'sit-for just before the call to 'live, e.g.
(defun show-life ()
  (interactive)
  (switch-to-buffer ""*Life-Window*"")    ; show how life goes on while living
  (sit-for 0)                           ; perform redisplay
  (live))                               ; it takes 70 years to finish and return!

And, if you want to see the results of 'live, it should periodically call 'sit-for as well.
The doc string for 'sit-for is:

sit-for is a compiled Lisp function in
  `subr.el'. (sit-for seconds &optional
  nodisp)
Perform redisplay, then wait for
  seconds seconds or until input is
  available. seconds may be a
  floating-point value. (On operating
  systems that do not support waiting
  for fractions of a second,
  floating-point values are rounded down
  to the nearest integer.)
If optional arg nodisp is t, don't
  redisplay, just wait for input.
  Redisplay does not happen if input is
  available before it starts.
Value is t if waited the full time
  with no input arriving, and nil
  otherwise.

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You never assign the read input to your variables:
(defun func ()
  (print ""Enter first integer"") 
  (finish-output)
  (let ((a (read)))
    (print ""Enter second integer"")
    (finish-output)
    (let ((b (read)))
      (print (+ a b)))))

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 This is an often asked question. There are possibly duplicates of this on Stackoverflow.
The output can be buffered.
You then need to call the standard Common Lisp function FINISH-OUTPUT to force the IO system to write any pending output.
After that, read.
 You got rid of the msg parameter, but you were still trying to use it. Use let to bind a local variable to that value.
(defun timed-notification()
  (interactive)
  (let ((msg ""Take a break, time's up!""))
    (run-at-time 25 nil (lambda (mess) (terminal-notifier-notify ""pomodoro"" mess)) msg)))

","The issue with your original `wait` function lies in the timing of when `(eval form)` is executed. In the first version, you are evaluating `form` immediately after starting the loop, which means that the output from `format t ",0.4855,[[0.44831769]],0.0012392705620958508,0.07746430794833821,0.19512195121951217,0.03278688524590164,0.11382113821138211
"I have this:
(loop for i below x
            do (update-world)
            if (zerop (mod i 1000))
            do (princ #\.))

It is working, except that all the princ invokations arrive at once, at the end. The idea here is that they are a progress indicator, printing a period to the screen every 1000 iterations. This is from the Land of Lisp book, and I'm wondering if expecting printing in the middle of a loop is not a portable expectation?
","Add a (finish-output) after the princ.
http://clhs.lisp.se/Body/f_finish.htm
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You will somehow need to print the whitespace yourself.  Simple extension of your code:
(loop for i from 1 to 5
      do (princ i)
         (princ #\space))

(Note that I used princ instead of prin1.)
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
","The issue you're encountering with `princ` invocations arriving at once is due to how Emacs Lisp handles output buffering. By default, Emacs buffers output for efficiency, and the characters are only printed when the buffer is flushed or reaches a certain size. To ensure that each `princ #\\.` character is printed immediately, you can flush the buffer after each invocation. You can do this by adding `(force-output)` after your `princ` call. Here's how you can modify your loop:",0.4673,[[0.18157451]],0.023052668632359826,0.2453780856886471,0.1263157894736842,0.021505376344086023,0.08421052631578949
"Suppose we have a function with the following structure:
def f():
    # ...
    # some computations
    # ...
    if something_is_wrong_with_previous_computations:
        return None
    # ...
    # some other computations
    # ...
    if something_is_wrong_with_previous_computations2:
        return some_variable
    #...
    return result

As I see it, using return statement in the middle of a function is not functional at all. If we were in some lispy language we would have the let (then computations could be written with let*) statement, which would help us deal with these situations with ease. Unfortunately, we don't have it here. What should we do?

Simulate let with creating lots of nested functions and calling them in place?
Use something like Maybe monad or another complex stuff like that?
Don't waste our time and write it imperatively?
Something else?

","A return statement anywhere in a function is not functional.
In Python, you have no choice.
The Lisp code
(defun sgnum (x)
  (cond
    ((< x 0) -1)
    ((zerop x) 0)
   (t 1)))

turns into Python as
def sgnum(x):
  if x < 0:
    return -1
  elif x == 0:
    return 0
  else:
    return 1

In Lisp, we know we have deviated from functional coding when we use variable assignment, or the ""program feature"": an explicit progn construct, or an implicit equivalent, or any of is cousins like prog or prog1. A functional function in Lisp always has a body which is made up of a single expression (or possibly no expressions at all).
You can redefine what you mean by ""functional coding"" in Python. How about these
rules:

Every statement in a ""functional function"" must be a single statement; it cannot be followed by another statement. Thus, the whole body of a function is a single statement, and in it are embedded single statements.

No statement in the function may allow control to fall through it. Every statement must return. Thus return is not only considered ""functional"" but essential to achieving this goal.

A variable may be defined, but not redefined. Parallel, mutually exclusive control flows may assign the same variable different values, but no variable can be assigned more than once in the same control flow.


With these kinds of rules, you can get the program to have a control flow graph resembling that a program in the pure Lisp style: a control graph that is basically a tree of decisions with embedded calculations and variable binding, at the leaves of which are values to be returned.
Speaking of variable binding, we should probably have a fourth rule:

A statement may be preceded by a sequence of fresh variable assignments that contain no side effects. Such a sequence, together with the statement which follows it, counts as one statement.

Arguably also a fifth one:

No statement must be used which evaluates any contained expression or statement more than once.

Otherwise we permit loops, which are not functional. This is tricky because some looping constructs are relatively well behaved, like implicitly stepping a dummy variable over the elements of a list.  The only way you can tell it's not functional is that a lexical closure captured in the loop will easily reveal there is only one variable being mutated and not a fresh variable being bound for each iteration.
According to these rules, sgnum is ""functional"": it contains just one if/elif/else statement, which does not allow control to fall through it: every branch returns:
This version of sgnum is not ""functional"" any more:
def sgnum(x):
  if x < 0:
    return -1
  if x == 0:
    return 0
  return 1

It contains three statements in sequence. Whereas the following is ""functional"" even though it also consists of three statements:
def distance(x0, y0, x1, y1):
  xd = x1 - x0
  yd = y1 - y0
  return math.sqrt(xd * xd + yd * yd)

These meet the rules. The first two statements bind fresh variables, meeting rule 3, so are permitted by 4 to precede a statement. The return statement meets rules 1 and 2. This is very similar to:
(defun distance (x0 y0 x1 y1)
  (let ((xd (- x1 x0))
        (yd (- y1 y0)))
    (sqrt (+ (* xd xd) (* yd yd)))))

Lastly, note how our rules are at odds with the ancient programming advice of ""have only one exit point in a function"". That little tidbit you may find in some coding conventions is quite anti-functional. To achieve a single point of return in a nontrivial function requires imperative style control flows through multiple statements and/or variable assignments. From the functional point of view, it is a myopic, silly rule; but it makes sense in those contexts where it is recommended, because it can help improve very poorly structured imperative code.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","In Lisp, you can handle this scenario without explicitly using a let-like construct or monads. Instead, you can structure your function to use local variables and return values appropriately. Here's an example of how you could refactor the given function in a more functional style using auxiliary functions and returning intermediate results:\n\n```lisp\n(defun find-remove-third (x test-list)\n  (let ((third-element (funcall (fifth 'car cadr caddr fourth) test-list)))\n    (if (eql x third-element)\n        (values (remove-if #'(lambda (elt) (eql elt third-element)) test-list) third-element)\n        nil)))\n\n(defun fifth (&rest functions)\n  (lambda (list) ((apply #'funcall (cons 'nthcdr (mapcar #'position (reverse functions)))) list)))\n\n(defun find-third-and-remove (x &optional (test-list *test-list*))\n  (multiple-value-bind (new-list removed-element)\n      (find-remove-third x test-list)\n    (setq *test-list* new-list)\n    removed-element))\n```\n\nIn this example, `find-remove-third` is an auxiliary function that performs the main logic and returns a list and the element if found. The `fifth` function constructs a lambda to select elements at specific positions in the list. The `find-third-and-remove` function calls `find-remove-third` and updates the global variable `*test-list*`. This approach avoids using return statements in the middle of the function and keeps the logic more functional.\n\nIf you prefer not to use global variables, you can pass additional parameters to maintain state across function calls.",0.548,[[0.25813462]],0.05810290655570492,0.15049715627888594,0.2219730941704036,0.038202247191011236,0.10762331838565022
"I'm trying to understand the view that procedures and data are virtually the same in lisp. SICP says that:

the values of numerals are the numbers that they name, 
the values of built-in operators are the machine instruction sequences that carry out the corresponding operations, and 
the values of other names are the objects associated with those names in the environment. 

The second stipulation says that ""the values of built-in operators are the machine instruction sequences that carry out the corresponding operations."" if I wish to change the values thereby changing the machine instructions, like this:
  (define + 2)

  (* + 3) ;6

it works fine.
Now, the first case stipulates that ""the values of numerals are the numbers that they name"". If I type
  2

The value is the representation of 2 that gets outputted. Now, if I wish to change it, like this:
  (define 2 +) ;bad syntax

Why is that?
","In any definition of a language, you need a distinction between symbols (if you have symbols) or names, and literals (in languages which only have literals, some of which code for instructions, this is not necessary.)
In the lisp in your example, 2 and 3.1415 are literals - + may be a symbol. Thus, it makes sense that you can re-assign a symbol, or name, to point somewhere else. Literals, however, will always be data. They are distinct from names.
You could define a language where literals are, just like +, symbols mapped to a default value, able to be re-mapped if you wish. An example of such a language might be the C pre-processor.
EDIT: More generally, you comment was about how ""code is data"" in lisp. Your example is a bad example of this feature - it is a question which concerns the parser or grammar of the language and its tokens.
A better example would be the following:
(+ 2 3)

This expression is both an executable statement, and a data structure. Namely it can code for ""a function invocation which returns 5"" or, if prefixed by a ""do not evaluate me straight away '"" the pair structure
(+ . (2 . (3 . NIL)))

which is the standard linked list structure found in lisp implementations. You can pass this data structure around in code, execute it later with something like the EVAL function, or (most powerfully), edit it so that it does something else and then execute it.
This is possible because lisps are homoiconic - the source code works both as code and data.
","The special operator quote prevents evaluation of your variables.
You need to call a function (which evaluates its arguments), e.g., list:
(list num str)
==> (9 ""Hello"")

 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
 The interpreter always outputs the value of the last expression.
print also returns the parameter as a value, ""Hi!"" in your case.
That's why you see it twice.  
(print ""Hi!"") 

will give the same result.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 If it's capable of modifying the list passed to it, then it's destructive.
If a function takes a list via a symbol, it should be automatically assumed to be destructive, no?  Otherwise why not just take the list itself?
 You can use ""v"" on a frame to jump to the definition of the function in the debugger.
In this case, the function sb-kernel:two-arg-> sounds like a specialized version of > that is called when there are exactly two arguments provided. If the arguments are 1 and NIL, you'll get an error because NIL is not a number.
I'm not sure how you'd figure this out yourself, except by practicing and asking questions.
","In Lisp, numerals and symbols are treated differently. When you enter just a numeral like `2`, it is evaluated as a number, not as a symbol or name that can be redefined. On the other hand, symbols such as `+` can be redefined because they represent names in the environment. Redefining `2` directly with `(define 2 +)` results in an error due to bad syntax because `2` is being used incorrectly here. To change the behavior associated with a symbol, you need to redefine it properly, like this: `(define + *)`. However, doing so changes how the symbol `+` behaves globally and can lead to unexpected results in your code.",0.5562,[[0.4486811]],0.06542524639190762,0.1873664838081755,0.3487738419618529,0.049315068493150684,0.14713896457765668
"It seems my understanding of macros is incomplete.
How do I pass arguments to macros, and call them from functions.
The seemingly simple code below code doesn't work.
(defmacro bar [arg]
  (println (symbol? arg)))

(defn foo [arg]
  (bar arg))

(foo 'baz) => nil

","The macro is being evaluated when you define foo. If you define the foo function in the repl you notice that Clojure prints true.
user=> (defmacro bar [arg]
         (println (symbol? arg)))
#'user/bar
user=> (defn foo [arg]
         (bar arg))
true ;  <= This is the print from your macro 
     ;     (it prints true, because arg is a symbol)
#'user/foo

You need to quote the body of the macro, otherwise it will be evaluated and because its return value is nil, foo will simply return nil.
(defmacro bar [arg]
   `(println (symbol? ~arg)))

","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 ? (defun foo (a b) (+ a 2))
;Compiler warnings :
;   In FOO: Unused lexical variable B
FOO

? (defun foo (a b)
    (declare (ignore b))
    (+ a 2))
FOO

 Here's one way to do it:
(defun foo (arg)
  (interactive ""p"")
  (message ""foo %s"" arg))

(defun bar (arg)
  (interactive ""p"")
  (message ""bar %s"" arg))

(defmacro wrap (fg f g)
  `(defun ,fg (arg)
     (interactive ""p"")
     (message ""%s"" arg)
     (if (= 1 arg)
         (funcall ,g 1)
       (funcall ,f (/ arg 4)))))

(wrap baz #'foo #'bar)

Now a plain baz will call bar. With C-u
it will call foo, dividing the given arg by 4.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
","In Lisp, macros are expanded at compile time and do not evaluate their arguments. To pass arguments to a macro and call it from a function, you need to ensure that the macro body is quoted so that it isn't evaluated before being passed to the macro. The issue with your code is that the argument `arg` inside the macro `bar` is not being used as intended because macros are expanded in their context without evaluating the arguments. Here's how you can correct it:\n\n```lisp\n(defmacro bar (arg)\n  `(println ',arg))\n\n(defn foo [arg]\n  (bar arg))\n\n(foo 'baz) ;; This will print: (Baz)\n```\nNotice the use of `',arg` to quote and refer to the symbol. Now, when `foo` calls `bar`, it passes the symbol `'baz`, and the macro expands to `(println 'baz)` which prints the symbol `Baz`. ",0.6092,[[0.57503735]],0.1948798348494801,0.38080658284023666,0.4915254237288135,0.08547008547008546,0.23728813559322032
"I have a file that looks like this:
A B C D E
0 8 6 12 5
8 0 10 8 9
6 10 0 7 11
12 8 7 0 6
5 9 11 6 0

I don't know ahead of time how many rows and columns there will be. I would like to read the top line, which will let me know the number of rows to expect . I found lisp's (read <stream>) function which, in a loop, can parse each of the characters as symbols. I have not found a way, however, to limit the loop to only reading the first line and stopping there. The solution I'm trying to make work would be something like 
(with-open-file (stream ""/home/doppler/tmp/testcase1.txt"")
  (setf line (read-line stream))
  (when line
    (loop for symbol = (read line nil)
         while symbol do (print symbol))))

The problem with this is that (read-line stream) returns a string which cannot be parsed by (read line nil) to extract the symbols (s-expressions). 
How can I either convert the string line to a stream, or, if possible, extract the symbols directly from the string?
","You can either use the string as a stream by using the with-input-from-string macro, or use read-from-string in a loop.  You may also be interested in the read-delimited-list function, although you would have to add some kind of delimiter character to the end of the string before using it.
","Use with-input-from-string. 
(with-input-from-string (s ""4 3 2"")
  (let ((a (read s))
        (b (read s))
        (c (read s)))
    (format t ""~a, ~a, ~a~%"" a b c))) 

You could also just read from a file, but reading from a string is much easier for making different test cases.
 You can either use the string as a stream by using the with-input-from-string macro, or use read-from-string in a loop.  You may also be interested in the read-delimited-list function, although you would have to add some kind of delimiter character to the end of the string before using it.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 read-char will return the next available character, and read-line will return an entire line of input as a string. You can use coerce to change a string to a list of characters, e.g.
(coerce ""foo"" 'list) => (#\f #\o #\o)

","To read only the first line of a file and then parse it into symbols, you can convert the string returned by (read-line) into a stream using with-input-from-string. Here is how you can do it:\n\n(with-open-file (stream \",0.6152,[[0.42311553]],0.2087842908013378,0.30790120915873426,0.396039603960396,0.12121212121212122,0.25742574257425743
"This is my function:
(defun MyFunction(input)
  (let ((NEWNUM (find input num)))
    (if (find input num)              //if this 
      (setq num NEWNUM) (FUNCT2)      //then execute both of these
    (list 'not found))))              //else output this

So after the if statement I want to be able to execute (setq num NEWNUM) followed by (FUNCT2) in order to set a new variable and then call a function.  Any ideas on how to do this?
","To do several things in sequence, you want progn.
(defun MyFunction(input)
  (let ((NEWNUM (find input num)))
    (if (find input num)              //if this 
      (progn 
        (setq num NEWNUM)
        (FUNCT2))      //then execute both of these
    (list 'not found))))              //else output this

","To do several things in sequence, you want progn.
(defun MyFunction(input)
  (let ((NEWNUM (find input num)))
    (if (find input num)              //if this 
      (progn 
        (setq num NEWNUM)
        (FUNCT2))      //then execute both of these
    (list 'not found))))              //else output this

 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 If you just want to mutate the argument structure object:
(defun dec (s)
  (decf (first (spider-values s)))  ; mutates the list of values
  (pop (spider-continuation s))
  s)

 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

","Your original code is almost correct, but there should be no space between the `setq num NEWNUM` and `(FUNCT2)` lines. In Lisp, you can chain expressions by placing them on consecutive lines within the `if` statement. Here is your corrected function:\n\n```lisp\n(defun MyFunction(input)\n  (let ((NEWNUM (find input num)))\n    (if (find input num)              ; if this\n        (progn                        ; then execute both of these\n          (setq num NEWNUM)\n          (FUNCT2))                   \n      (list 'not found))))            ; else output this\n```\nNote that I've wrapped the two expressions in `progn` to ensure they are evaluated sequentially.",0.7824,[[0.56594599]],0.3808054345480895,0.7084632323895395,0.4963503649635037,0.32592592592592595,0.40875912408759124
"Basically, the title says it all: In Common Lisp, why is the null predicate called null. not nullp (to conform to other predicates such as evenp or oddp)? Is there a special reason for this?
","First of all, null is not the only one. See atom.
Second, I think these predicates are fundamental ones and thus, very old. I don't think the 'end with p' agreement was introduced from the very beginning of LISP.
Also interesting info on the topic:

By convention, the names of predicates usually end in the letter p (which stands for 'predicate'). Common Lisp uses a uniform convention in hyphenating names of predicates. If the name of the predicate is formed by adding a p to an existing name, such as the name of a data type, a hyphen is placed before the final p if and only if there is a hyphen in the existing name. For example, number begets numberp but standard-char begets standard-char-p. On the other hand, if the name of a predicate is formed by adding a prefixing qualifier to the front of an existing predicate name, the two names are joined with a hyphen and the presence or absence of a hyphen before the final p is not changed. For example, the predicate string-lessp has no hyphen before the p because it is the string version of lessp (a MacLisp function that has been renamed < in Common Lisp). The name string-less-p would incorrectly imply that it is a predicate that tests for a kind of object called a string-less, and the name stringlessp would connote a predicate that tests whether something has no strings (is ``stringless'')!

Source: http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node69.html
","The rule is that one-word predicate names end in just P, while multi-word predicate names end in -P.  The reason for the former is mostly historical; the reason for the latter is that a name like input-streamp would wrongly suggest that the question being asked is “is this input a stream?” or something like that.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 This is per the specification. A LIST is either a CONS, or a symbol NIL (which is the only object of type NULL), which means that both of those types are specializations of LIST, and hence their equivalent system classes inherit from LIST.
 Courtesy of Paul Graham, here's a Common Lisp implementation of John McCarthy's original LISP:
It assumes quote, atom, eq, cons, car, cdr, and cond, and defines null, and, not, append, list, pair, assoc, eval, evcon and evlis.
 What you are seeing is the output being concatenated for brevity. The actual list is correct and not affected, but because it would be too long to print to the output, the lisp REPL shortens it when printing and uses # to indicate that it has done so.
 check-exn needs a function of no arguments – a thunk – it can call which should raise the exception.  So the right incantation would be
(check-exn exn:fail? (thunk (string-last """")))

It must be passed a thunk because otherwise the default evaluation order of Racket would mean that the exception is raised before the function is called, so it never gets to catch it.
","In Common Lisp, the name 'null' is used for the predicate that checks if something is nil. The naming choice was likely influenced by historical reasons and possibly the desire to have a single-word name for this specific predicate. In contrast, multi-word predicate names end in -P (e.g., evenp, oddp), which helps avoid ambiguity, as seen with 'input-streamp'. Thus, 'null' is used instead of 'nullp' to maintain consistency and clarity.",0.549,[[0.49187119]],0.025907630293450168,0.1329579744197612,0.23880597014925373,0.06606606606606606,0.13731343283582087
"Most people agree that LISP helps to solve problems that are not well defined, or that are not fully understood at the beginning of the project.
""Not fully understood"""" might indicate that we don't know what problem we are trying to solve, so the developer refines the problem domain continuously. But isn't this process language independent?
All this refinement does not take away the need for, say, developing algorithms/solutions for the final problem that does need to be solved. And that is the actual work. 
So, I'm not sure what advantage LISP provides if the developer has no idea where he's going i.e. solving a problem that is not finalised yet.
","In AI (Artificial Intelligence) historically Lisp was seen as the AI assembly language. It was used to build higher-level languages which help to work with the problem domain in a more direct way. Many of these domains need a lot of 'knowledge' for finding usable answers.
A typical example is an expert system for, say, oil exploration. The expert system gets as inputs (geological) observations and gives information about the chances to find oil, what kind of oil, in what depths, etc. To do that it needs 'expert knowledge' how to interpret the data. When you start such a project to develop such an expert system it is typically not clear what kind of inferences are needed, what kind of 'knowledge' experts can provide and how this 'knowledge' can be written down for a computer.
In this case one typically develops new languages on top of Lisp and you are not working with a fixed predefined language.
As an example see this old paper about Dipmeter Advisor, a Lisp-based expert system developed by Schlumberger in the 1980s.
So, Lisp does not solve any problems. But it was originally used to solve problems that are complex to program, by providing new language layers which should make it easier to express the domain 'knowledge', rules, constraints, etc. to find solutions which are not straight forward to compute.
","Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 TL;DR: It depends.
Can the commonality, or a subset, be abstracted into a function (or functions), with only the more dynamic bits defined through macros? When possible, it's best to make the macro-y parts as limited in scope as possible.
What's the nature of the functions/macros? If they're part of a well-documented system aspect, it doesn't really matter where they come from.
Are they poorly-understood, and do they require frequent inspection to understand or verify behavior? If so, then leaving them as real functions may make more sense. If they're not, and are more or less ""stock"" system aspects, do whatever is cleaner.
Are the functions/macros maintained by everybody, or by someone more focused on an underlying system implementation? If they're mostly consumed, it matters less how/where/when they're implemented.
 The problem consists of two subproblems: parsing and symbolic manipulation. It seems to me the answer boils down to two possible solutions.
One is to implement everything from scratch: ""I do recommend creating the full expression tree if you want to retain maximum flexibility for handling tricky cases."" - proposed by Rex. As Sven points out: ""any of the high-level languages you listed are almost equally suited for the task,"" however ""Python (or any of the high-level languages you listed) won't take away the complexity of the problem.""
I have received very nice solutions in Scala (many thanks for Rex and Daniel), a nice little example in Python (from Sven). However, I am still interested in Lisp, Haskell or Erlang solutions.
The other solution is to use some existing library/software for the task, with all the implied pros and cons. Candidates are Maxima (Common Lisp), SymPy (Python, proposed by payne) and GiNaC (C++).
 I think, they should have used macros for the sake of example solely... because constructing the lambda around cl-ppcre: calls can indeed be completed during the reading phase, provided that the reader macro doesn't make use of any other form than the string, that follows the macro character. In general, the golden rule states, that macros should be avoided in cases when an ordinary function can be used. Sometimes (for example, when it's necessary to control the evaluation of the arguments) macros are inevitable, but it this particular case function is sufficient.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
","The use of Lisp (or any other programming language) can indeed help in refining and exploring potential solutions for problems that are initially ill-defined. However, the specific advantages of using Lisp in such scenarios often lie in its support for functional programming paradigms, macros, and higher-order functions, which facilitate more flexible and concise code development. For instance, in the provided context, abstracting common operations into functions or macros can enhance readability and maintainability. The decision to use macros versus functions should be based on the dynamic nature of the problem and whether it requires control over evaluation. In Lisp, you have the flexibility to write custom macros that can manipulate code at read-time or expand during compilation, which might not be as straightforward in other languages. This capability is particularly useful for symbolic manipulation tasks.",0.55,[[0.36163699]],0.10489635374261583,0.23626444617241008,0.3232876712328767,0.027548209366391182,0.12602739726027398
"I am trying to learn lisp, using emacs dialect and I have a question.
let us say list has some members, for which predicate evaluates to false.  how do I create a new list without those members?  something like { A in L: p(A) is true }. in python there is filter function, is there something equivalent in lisp?  if not, how do I do it?
Thanks
","These functions are in the CL package, you will need to (require 'cl) to use them:
(remove-if-not #'evenp '(1 2 3 4 5))

This will return a new list with all even numbers from the argument.
Also look up delete-if-not, which does the same, but modifies its argument list.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

 To get the same result for an empty list in Clojure as you do in Common Lisp, use the empty? function. This function is in the core library: no imports are necessary. 
It is also a predicate, and suffixed with a ?, making it a little clearer what exactly you're doing in the code.
=> (empty? '())
true
=> (empty? '(1 2))
false
=> (empty? nil)
true

As j-g faustus already noted, seq can be used for a similar effect.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 This is a result of using a constant list in the initializer:
(let ((myList '(0 0 0 0 0 0)))

Change that line to:
(let ((myList (list 0 0 0 0 0 0)))

and it will behave as you expect.  The first line only results in an allocation once (since it's a constant list), but by calling list you force the allocation to occur every time the function is entered.
edit:
This may be helpful, especially towards the end.  Successful Lisp
The answer to this question may also be helpful.
This uses the loop keyword collecting which collects the results of each iteration into a list and returns the list as the value of the loop.
","In Lisp, you can achieve this using the `remove-if` function. Given a list and a predicate, `remove-if` returns a new list with all elements that satisfy the predicate removed. Here's an example: \n\n```\n(remove-if 'p my-list)\n``` \nThis will create a new list without the members for which the predicate evaluates to true. If you want to remove elements where the predicate is false, simply negate the predicate within `remove-if`. For instance, if you have a list of numbers and you want to keep only even numbers (i.e., remove odd numbers), you can use: \n\n```\n(remove-if 'oddp my-list)\n```",0.566,[[0.39381039]],0.12012729306799423,0.3703451383256735,0.2909090909090909,0.08588957055214723,0.19393939393939394
"could you please help me to solve a tricky homework about nested list? 
Basically anytime the predicate evenp is true , I should remove the element from the list (or from the nested list) keeping the structure of the whole list.
(Nopred 'evenp '(1 S d ((4)) (7) ((((8)))) u))

It should return 
(1 S d (()) (7) (((()))) u)

This is the function I wrote
(Defun nopred (f list)
  (Cond ((null list))
        ((Symbolp (car list)) (cons (car list) (nopred f  (cdr list)))
         ((Listp  (car list)) (cons (nopred f ( car list)) (nopred f (cdr list))))
         ((Funcall f (car list)) (nopred f (cdr list)))
         (T (cons (car list) (nopred f (cdr list))))))

I tried to solve with this code but it doesn't work, it does not remove the element when evenp is true and it returns values like 
((((5 .T ) .).).) 

","You need to return NIL in the (null list) case. When you don't have a return value in the matching COND clause, it returns the value of the condition, and (null list) returns T.
You also had some typos in the posted code: (cdr l) should have been (cdr list), and there was a missing ) at the end of that line.
(defun nopred (f list)
  (cond ((null list) nil)
        ((symbolp (car list)) (cons (car list) (nopred f  (cdr list))))
        ((listp  (car list)) (cons (nopred f ( car list)) (nopred f (cdr list))))
        ((funcall f (car list)) (nopred f (cdr list)))
        (t (cons (car list) (nopred f (cdr list))))))

With these corrections I get the correct result:
(1 S d (nil) (7) (((nil))) u)

","Check the order of the arguments of the function mod. It should be:
(= (mod (car list) 2) 0)

To avoid this mistake, you can use the function evenp instead.
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 I don't understand why your function takes 2 arguments when it's going to rearrange one list.
Your t case is almost correct, but you've practically turned it inside out - it should be
(cons (car x) (Func1 (cdr x)))

That is, a list where the car is the same as in the input, and the cdr is the result of flattening the cdr of the input.
The listp case looks like it's suffering from a similar form of ""inside-out-ness"".
Apart from the inexplicable y you have all the right bits but in the wrong order, except that it needs two Func1 calls - one for the car and one for the cdr.  
I'll leave the rearrangement of the bits in that case as an exercise.
","Your current function `nopred` does not correctly handle nested lists. The key issue is that it only checks and processes the first element of each sublist without properly recursing into them. Here's a corrected version of your function using a more recursive approach, similar to how you should use `car` and `cdr` for nested structures in Lisp:\n\n```lisp\n(defun nopred (f list)\n  (if (null list) \n      nil\n      (let ((head (first list)) (tail (rest list)))\n        (if (atom head)\n            (if (funcall f head) \n                (nopred f tail) \n                (cons head (nopred f tail)))\n            (cons (nopred f head) (nopred f tail))))))\n```\n\nIn this version, `first` and `rest` are used to handle both atoms and lists recursively. The function checks if the current element is an atom or a list, applies the predicate `f`, and processes accordingly while maintaining the structure of the nested list.",0.6401,[[0.43364091]],0.28079751746611176,0.40006289308176096,0.36363636363636365,0.08058608058608058,0.21818181818181817
"Given 2 lists, I want to ensure that they are the same size, I'm having a tough time with this code. Should I be using variables to do this?
(defun samesize (list1 list2)
  (cond (;logic here) T))

","Both Common Lisp and elisp have length:
(defun samesize (list1 list2)
  (= (length list1) (length list2)))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 Start by defining a function that determines whether one list is less than another.  The following example assumes that the lists can only contain numbers:
(defun list< (a b)
  (cond ((null a) (not (null b)))
        ((null b) nil)
        ((= (first a) (first b)) (list< (rest a) (rest b)))
        (t (< (first a) (first b))) ))

Armed with this function, you can now sort the list of lists.
(sort (copy-seq list) #'list<)

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 An example: if list is (3 3 5 6 6 6 9), the loop will examine each list element in turn, and set these hash keys to t: 3, 5, 6, and 9.  Since 3 and 6 are duplicated in the list, no new hash key will be created for those elements.  Finally hash-table-count returns the number of keys in the hash table, i.e. 4.
","To ensure that two lists are the same size in Lisp, you can use the length function and compare their results. Here's an example of how you might implement this using your provided function structure:\n\n```lisp\n(defun samesize (list1 list2)\n  (and (= (length list1) (length list2)) t))\n```\nThis function will return T if both lists are the same size, and NIL otherwise. If you want to use variables for clarity or reusability, you can certainly do so like this:\n\n```lisp\n(defun samesize-with-variables (list1 list2)\n  (let ((len1 (length list1))\n        (len2 (length list2)))\n    (and (= len1 len2) t)))\n```\nThis version uses let to bind the lengths of the lists to variables, making it a bit more readable.",0.5702,[[0.39205579]],0.08732915899366367,0.3113419618528611,0.16783216783216784,0.08510638297872342,0.15384615384615385
"I'm porting some of my python scripts to Common Lisp. I need to get list of files in some directory and print each file's content by lines.
This code shows me all filenames. But lines are printed only for last file. Why?
Also, what is the best way ti iterate by file lines?
Thanks.
(dolist (file (directory (make-pathname :name :wild
                                        :type :wild
                                        :defaults ""path\\to\\files\\"")))
  (print file)
  (with-open-file (stream file)
    (do ((line (read-line stream) (read-line stream)))
        (nil t)
      (print line))))

","I would propose to write a function which prints a file given a pathname and a stream.
You iterate with DO. That's okay, but I would use something like LOOP which allows slightly easier to read code.
Your DO is an endless loop. You might want to end the loop when the EOF is reached.
READ-LINE generates an error when it reads past the end of the file. Thus your code signals an error on the end of the first file. This error causes your code to only print the first file.
You need to call READ-LINE such a way that you test for EOF and end the iteration then. See the arguments to READ-LINE. Alternatively you can catch the EOF error, but the other solution is slightly easier.
","(setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 Here's how:

Click on the ""run"" button, as you discovered
Press Esc  + p

And this is the relevant page in the documentation.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 Well, the answer is a bit more obvious than anticipated. The last argument that can be passed into getfiled will change the File Explorer from ""Open"" to ""Save As.""
;; Opens exsisting file
(getfiled ""Title"" ""test.txt"" """" 0)

;; Saves file
(getfiled ""Title"" ""test.txt"" """" 1)

Reference 1: help.solidworks.com
Reference 2: help.autodesk.com
Reference 3: docs.autodesk.com
 You don't need eval here; use begin instead to group those definitions together into a list; i.e., the template to be expanded should be of the form:
`(begin 
   ,@(map ...)
   (define ...)
   (define ...)
   ...)

Edit:
Change for-each to map as suggested by OP.
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

","The issue you're encountering is due to the `do` loop condition. The condition `(nil t)` will always evaluate to true, causing an infinite loop for all but the last file. Instead, you should use a `loop` or `dolist` with proper iteration over lines. Here's how you can do it using `dolist` and `read-line` correctly:",0.5395,[[0.45027596]],0.06511229567218467,0.19234644320638009,0.32631578947368417,0.031914893617021274,0.15789473684210525
"I want to save a reference (pointer) to a part of some Data I saved in another variable:
(let ((a (list 1 2 3)))
  (let ((b (car (cdr a)))) ;here I want to set b to 2, but it is set to a copy of 2
    (setf b 4))
  a) ;evaluates to (1 2 3) instead of (1 4 2)

I could use macros, but then there would ever be much code to be executed if I want to change some Data in the middle of a list and I am not very flexible:
(defparameter *list* (create-some-list-of-arrays))
(macrolet ((a () '(nth 1000 *list*)))
  (macrolet ((b () `(aref 100 ,(a))))
    ;; I would like to change the macro a here if it were possible
    ;; but then b would mean something different
    (setf (b) ""Hello"")))

Is it possible, to create a variable as a reference and not as a copy?
","cl-user> (let ((a '(1 2 3)))
           (let ((b (car (cdr a))))
             (setf b 4))
           a)
;Compiler warnings :
;   In an anonymous lambda form: Unused lexical variable B
(1 2 3)

A cons cell is a pair of pointers. car dereferences the first, and cdr dereferences the second. Your list is effectively 
  a -> [ | ] -> [ | ] -> [ | ] -> NIL
        |        |        |
        1        2        3

Up top where you're defining b, (cdr a) gets you that second arrow. Taking the car of that dereferences the first pointer of that second cell and hands you its value. In this case, 2. If you want to change the value of that pointer, you need to setf it rather than its value.
cl-user> (let ((a '(1 2 3)))
           (let ((b (cdr a)))
             (setf (car b) 4))
           a)
(1 4 3)

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
","In Lisp, variables do not store references to objects like pointers in some other languages. Instead, setting a variable creates a new binding for that name, which can be confusing when you expect changes to persist across different scopes. If you want to modify a part of a list or structure directly, you need to use functions that operate on the data destructively.

For example, if you have a list `(1 2 3)` and you want `b` to refer to the second element, you can do:

```lisp
(let ((a (list 1 2 3)))
  (let ((b (car (cdr a))))
    ;; b is now 2
    (setf (car (cdr a)) 4) ; Modify the list destructively
    a)) ; Now a is (1 4 3)
```

In this case, `a` and `(cdr a)` share references to the same elements, so modifying one affects the other. However, be cautious with such operations as they can lead to unexpected behavior if not managed properly.

If you need to create a 'reference' in a more flexible way, you might consider using a structure or a custom class where you can explicitly manage references and mutations.",0.622,[[0.41324796]],0.30729336587165645,0.3498166714743557,0.4076433121019108,0.16025641025641024,0.2038216560509554
"I am writing a very simple lisp code for the recursive factorial function. When called using a number, it works fine. However, when I try to call it using something that is not a number (ex. a) I get the following error:
Error: Attempt to take the value of the unbound variable `A'.
  [condition type: UNBOUND-VARIABLE]
However, this is supposed to be caught in my code. Here is my code:
(defun FactorialRec (num)
   (cond                                                  
      ((not(numberp num))
         (princ ""Argument must be a number."")
         (terpri)
         ())
      ((equal num 1) ;base case                                                       
         1)
      ((<= 1 num) (* num(FactorialRec (- num 1))))
   )
)

I do not know why the numberp is not catching this. Any ideas? Thanks.
","Break 2 [6]> (FactorialRec ""A"")
Argument must be a number.

It works on my machine. So I think you were passing A but not ""A""?
","You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 The error is really in the lexer. Your parentheses end up as the last ""."" in the lexer, and don't show up as parentheses in the parser.
Add rules like
\)     { return RPAREN; }
\(     { return LPAREN; }

to the lexer and change all occurences of '(', ')' to LPAREN and RPAREN respectively in the parser. (also, you need to #define LPAREN and RPAREN where you define your token list)
Note: I'm not sure about the syntax, could be the backslashes are wrong.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 It is a parenthesis issue. It happens quite a lot when beginning with scheme.
I recommend that you indent your code correctly, it will make it more readable and much less error prone.
(define func
  (lambda (N lst)
    (if (eq? N 0)         
        0 
        (+ (car lst) 2))))

The extra () you had was translated to a function call
","The issue lies in how you are handling the case where `num` is not a number. In Lisp, when you encounter an unbound variable like 'a', it tries to evaluate it, which fails if it hasn't been defined. Your condition check using `(not (numberp num))` should work correctly as long as the function isn't calling itself with undefined variables directly. However, your recursive call `(* num(FactorialRec (- num 1)))` might be causing issues because of the extra parentheses around 'num'. This could be interpreted as a function call instead of multiplication. Try removing those extra parentheses to fix the issue.",0.5105,[[0.11365524]],0.038276619647325635,0.24344569288389514,0.15873015873015875,0.03225806451612903,0.09523809523809523
"So, I've been trying to wrap my head around the idea of clojure's code-as-data approach and it is definitely a bit confusing. It seems a lot like they are simply higher order functions of the sort. Is there a difference between these two concepts?
","Code-as-data is a big step further. HOF gives you code-as-data in the sense that you can pass executable blocks into other executable blocks, and compose them. But you can't manipulate the structure of the blocks themselves. It's kind of like working with objects that have only one method (call the function) but otherwise leak no data.
In full generality, code-as-data implies the code works like any other data structure in your environment, with contents you manipulate programatically. The homoiconicity @coredump mentioned greatly facilitates this because you can employ the exact same operations and transformations to a code block that you can apply to any other native data structure. But homoiconicity isn't strictly required. A lot of non-homoiconic languages provide metaprogramming features that let you achieve similar results, like Scala's macros and quasiquotes (for compile-time code manipulation) and toolboxes (for run-time complilation) or Python's ast.
","Clojure, at any rate, simply has no need for caddaadr and friends, because nobody builds data structures out of just cons cells. The language does have combinations of any two of first and next, named ffirst, fnext, nnext, and nfirst, which were added very early on I suppose because it was assumed we'd want something like cadr, but I never see them used in real life.  Instead destructuring is used quite often.
On the rare occasions where you need to reach deeply into a structure built of nested sequences, destructuring often still produces readable code but also writing it out longhand is no great burden. It's also a good hint to you that maybe you should abstract thing a bit more rather than working with so many layers of primitive combinators directly.
 Yes, it's possible. The easiest way would be to simply redefine the class. You do that by issuing another call to DEFCLASS. If you want to do more complicated things, you have to resort to the MOP (MetaObject Protocol). Essentially everything you'd ever want to do is possible using the MOP, but I would need more detailed information as to what it is you're trying to do in order to explain it further.
 My assumption is that ""thread-id"" is some sort of procedure. 
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 For anonymous recursion, you're going to need a fixed-point combinator, the most famous of which is known as the Y combinator. Richard Gabriel's ""Why of Y"" is a good article which derives and justifies Y in Scheme.
 TL;DR: It depends.
Can the commonality, or a subset, be abstracted into a function (or functions), with only the more dynamic bits defined through macros? When possible, it's best to make the macro-y parts as limited in scope as possible.
What's the nature of the functions/macros? If they're part of a well-documented system aspect, it doesn't really matter where they come from.
Are they poorly-understood, and do they require frequent inspection to understand or verify behavior? If so, then leaving them as real functions may make more sense. If they're not, and are more or less ""stock"" system aspects, do whatever is cleaner.
Are the functions/macros maintained by everybody, or by someone more focused on an underlying system implementation? If they're mostly consumed, it matters less how/where/when they're implemented.
","While Clojure's code-as-data approach and higher-order functions share some similarities, they are distinct concepts. Code-as-data refers to treating code as a data structure that can be manipulated at runtime. For example, you can create and pass around functions as arguments or return them from other functions. Higher-order functions, on the other hand, are functions that take one or more functions as arguments or return a function as their result. Clojure's code-as-data approach allows for this kind of behavior but also enables other powerful features like macros, which can transform data into executable code at compile time. In summary, higher-order functions are a subset of the capabilities enabled by Clojure's code-as-data paradigm.",0.58,[[0.41161472]],0.1941760974068772,0.3172542787072723,0.42402826855123676,0.0782918149466192,0.18374558303886926
"In R5RS Scheme how do you display multiple parameters, with a single call? my implementation below works, but adds extra parentheses and spaces.
#!/usr/bin/env racket
#lang r5rs
(define (display-all . rest) (display rest))
(display-all ""I "" ""have "" ""a "" ""lovely "" ""bunch "" ""of "" ""coconuts\n"")

results in
owner@K53TA:~$ ./Template.ss
(I  have  a  lovely  bunch  of  coconuts
)

","Simplest:
(define (display-all . vs)
  (for-each display vs))

Note the use of for-each instead of map - for-each is the same thing but assumes you're only calling the function for side-effects, so instead of returning a list of results (using map with display would return a list of voids) it just returns void.
This can get annoying if you want to display non-string things and have spacing between them, for instance if you want (display-all 12 ""bananas"") to display the string ""12 bananas"" you have to manually turn the number into a string and add the space yourself. It would be easier to just add spaces in-between elements of the list:
(define (insert-between v xs)
  (cond ((null? xs) xs)
        ((null? (cdr xs)) xs)
        (else (cons (car xs)
                    (cons v (insert-between v (cdr xs)))))))

(define (display-all . vs)
  (for-each display (insert-between "" "" vs)))

Now calling this:
(display-all ""blah"" 4 ""bloo"")

does what you'd expect. If you don't want the spaces inserted automatically, you can specify another argument as the separator object and use it however you need. Here's a version that accepts a separator object:
(define (display-all sep . vs)
  (for-each display (insert-between sep vs)))

This approach would make more sense in a version of scheme that supports optional and keyword arguments however, so you could default it to either a space or the empty string and not interfere with the rest-args.
","
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 Given that this expression is evaluated only for its effect (printing a message), you should explicitly return a value (any value!) as the result of the let form:
(let ((x 1))
  (cond ((< x 2)  
         (display ""hooray"")
         (newline))
        (else 
         (display ""bummer"")
         (newline)))
  'ok)

Now we'll get:
hooray
'ok

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Iterate over your list and store each pair's car into a list in an assoc that looks like this:
original: ((2 . 1) (3 . 2) (1 . 2) (5 . 1) (6 . 3))
new:      ((1 . (2 5))
           (2 . (3 1))
           (3 . (6))

Then sum together all the cdrs and flip each pair to get this:
          ((7 . 1) (4 . 2) (6 . 3))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 In your example, the hostname is only the www.w3.org portion -- not including the scheme (http or https) nor any path. So for example this does work:
(http-conn-open ""www.w3.com""
                #:ssl? #t)

To make a post request, you could do this:
#lang racket

(require net/http-client)

(define-values (status headers in)
  (http-sendrecv ""www.w3.com""
                 ""/""
                 #:ssl? #t
                 #:version ""1.1""
                 #:method ""POST""
                 #:data ""Hello""))
(displayln status)
(displayln headers)
(displayln (port->string in))
(close-input-port in)

In Racket, a function can return multiple values. http-sendrecv returns three, and the define-values assigns each one to a variable.
net/http-client provides other functions to let you make a connection to a host, make multiple requests on that connection, then close the connection.
","In R5RS Scheme, you can use (for-each display rest) within your display-all function to avoid extra parentheses and spaces. This will apply the display function to each element in the list of parameters.",0.5222,[[0.46097108]],0.00020792133768276163,0.05691617799241118,0.17667844522968196,0.042704626334519574,0.10600706713780919
"I need to write a non-recursive version of the function sum-squares and Use a do-loop that is based on the length of the argument list.
","Here's how it's done generally:
(defun sum-squares (list) (loop for x in list
              for y = (* x x)
              summing y into total
              finally (return total)))

A do loop solution is even simpler, but not half as elegant:
(defun sum-squares (list)
         (let ((sum 0)) (do ((i 0 (1+ i)))
              ((>= i (length list)))
            (setq sum (+ sum (* (nth i list) (nth i list)))))
              sum))

","If you're using nth to traverse a list, you're doing it wrong. In this case, you might want to write a summing function:
(defun sum (items)
  (reduce #'+ items))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Here's how it's done generally:
(defun sum-squares (list) (loop for x in list
              for y = (* x x)
              summing y into total
              finally (return total)))

A do loop solution is even simpler, but not half as elegant:
(defun sum-squares (list)
         (let ((sum 0)) (do ((i 0 (1+ i)))
              ((>= i (length list)))
            (setq sum (+ sum (* (nth i list) (nth i list)))))
              sum))

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
","To write a non-recursive version of the `sum-squares` function using a `do-loop` that is based on the length of the argument list, you can use the following code:\n\n```\nlisp\n(defun sum-squares (list)\n  (let ((sum 0))\n    (do ((i 0 (1+ i)))\n        ((>= i (length list)) sum)\n      (setq sum (+ sum (* (nth i list) (nth i list)))))))\n```\n\nThis function initializes `sum` to 0 and uses a do loop that iterates from index 0 up to the length of the list, adding the square of each element to `sum`. The loop finally returns the accumulated sum.",0.707,[[0.46297414]],0.4163449558862018,0.49542399906805396,0.44047619047619047,0.2891566265060241,0.369047619047619
"Clojure/ClojureScript does not have reader macros. I personaly think it is a huge loss as I'm specifially interested in hacking with the syntax. Is there way to develop websites using a lisp with reader macros?
","Common Lisp has Parenscript, that allows you to generate JavaScript from Lisp syntax, and be able to use reader macros.
You can also hook it with slime-proxy and swank-js to have a fully interactive experience.
","Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 On anything but Gentoo (which has a very well maintained Lisp overlay), I would use clbuild for now.  I have the hope that XCVB will be usable soon.
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 No.  Macros cannot change the lexical syntax of the language.  That requires read-macros, which Clojure doesn't have.
 The code as you pasted is fine.
The behavior you describe is indicative of lisp choking on a non-ascii character.
Please copy the code into Emacs and find the offending character using, e.g., 
(defun my-search-for-non-acsii ()
  (interactive)
  (skip-chars-forward ""\000-\177""))

 Lispbox doesn't access .emacs init files. You can resolve this by editing the .sh file in the app bundle and removing the ""no init"" line that it passes to the emacs startup. 
","While Clojure and ClojureScript do not have reader macros like Common Lisp does, you can achieve similar functionality through other means. For instance, you could use a custom reader function or write a macro that processes the input before it is evaluated. Additionally, you can use tools like `clojure.java.shell` to run shell commands that process your code with a different lisp implementation that supports reader macros, such as SBCL or CLISP. This approach allows you to leverage reader macros while still developing websites using Clojure/ClojureScript.",0.5749,[[0.330055]],0.11274165182743565,0.3156708004509583,0.28800000000000003,0.0813008130081301,0.16
"CL-USER> *mylist*
((RED . 5) (RED . 4) (RED . 3) (BLUE . 5) (RED . 2) (BLUE . 4))
CL-USER> (assoc 'blue *mylist*)
(BLUE . 5)
CL-USER> (find 'blue *mylist* :key #'car)
(BLUE . 5)

It would seem to me that assoc is just a particular case of find, is this true or am I missing some extra functionality from assoc that is not apparent here?
","From clhs.lisp.se/Body/f_assocc.htm:

The two expressions
(assoc item list :test fn)

and
(find item list :test fn :key #'car)

are equivalent in meaning with one exception: if nil appears in alist in place of a pair, and item is nil, find will compute the car of the nil in alist, find that it is equal to item, and return nil, whereas assoc will ignore the nil in alist and continue to search for an actual cons whose car is nil. 

","Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
","Your observation is correct. `assoc` and `find` are both functions used for searching lists of key-value pairs (cons cells), but they have some differences in their behavior and usage scenarios.\n\n`assoc` is specifically designed to work with association lists where keys are typically atoms or symbols, and it performs a linear search on the car of each cons cell. It also has an optional :test argument, which defaults to 'eql', meaning it compares the keys using the `eql` function (which can distinguish between different objects that have the same printed representation).\n\nOn the other hand, `find` is more general and works with any list of elements. By default, it uses `'equalp` for comparing elements, which means it can handle comparisons for compound data structures like lists.\n\nIn your example, you are using symbols as keys, so both `assoc` and `find` could be used interchangeably in this case. However, if the keys were more complex objects (e.g., lists or arrays), `assoc` might require a custom test function to work correctly, while `find` would handle it with its default behavior.\n\nSo, while `assoc` can be considered a specialized version of `find` for association lists, they do serve slightly different purposes and might have subtle differences in how they interact with the data.",0.5101,[[0.31604972]],0.07360111017800519,0.2951780081117621,0.271523178807947,0.02,0.12582781456953643
"I have heard that the active symbol table is accessible within the Common Lisp runtime. Have I misunderstood?
","'Symbol tables' are called 'packages' in Common Lisp. See for example: Introduction to Packages, CL HyperSpec.
Several operations over packages are available in Common Lisp: The Packages Dictionary.
Symbols can be members of packages (being 'interned').
The variable *package* holds a package as a value, which is used by several operations that use a package as a default. An example is the 'reader', which by default does a look up in the package of *package*.
","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
","In Common Lisp, the active symbol table (i.e., the global environment) can indeed be accessed during runtime. Symbols are objects that have a place in this environment where they can store various types of information such as function definitions, variable values, and more. You can use functions like FIND-SYMBOL to look up symbols and inspect their properties or bindings.",0.5695,[[0.22659796]],0.11458151660864363,0.27256740914419697,0.3235294117647059,0.07462686567164178,0.19117647058823528
"I'm trying to write a macro to return a variable's name and value in common lisp. How do I return the name and value of a variable in a LISP macro? 
So something like 
(RETURNVAL (x)) 
would return 
x has value 5
","(defmacro returnval (x)
  `(format t ""~a has value ~a."" ',x ,x))


CL-USER> (defparameter *forty-two* 42)
*FORTY-TWO*
CL-USER> (returnval *forty-two*)
*FORTY-TWO* has value 42.
NIL
CL-USER> (let ((x 5))
           (returnval x))
X has value 5.
NIL

If you really want that extra set of parens around the form, you can do that, too:
(defmacro returnval ((x))
  `(format t ""~a has value ~a."" ',x ,x))


CL-USER> (returnval (*forty-two*))
*FORTY-TWO* has value 42.
NIL
CL-USER> (let ((x 5))
           (returnval (x)))
X has value 5.
NIL

","Generally return a list of depths. So, if an item is found, then return the list of the single depth. If you branch to the first and rest of the list, then don't 'cons', but 'append'.
Note also that your code does not find all depths.
CL-USER 6 > (search-node '(6 (6)) 6)
0

 Use the macro CHECK-TYPE:
CL-USER 9 > (let ((n ""10""))
              (check-type n integer))

Error: The value ""10"" of N is not of type INTEGER.

 read-char will return the next available character, and read-line will return an entire line of input as a string. You can use coerce to change a string to a list of characters, e.g.
(coerce ""foo"" 'list) => (#\f #\o #\o)

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 If macro-function returns non-NIL, then it is a macro.
CL-USER 1 > (defmacro foo (bar) bar)
FOO

CL-USER 2 > (macro-function 'foo)
#<anonymous interpreted function 40600108FC>

Note that this works for typical global macros. There are also local&lexical macros, symbol macros, ...
 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

","To create a macro that returns both the name and value of a variable in Common Lisp, you can define a macro called `RETURNVAL` that uses the `SYMBOL-VALUE` function to retrieve the value of the symbol. Here is an example implementation:\n\n```lisp\n(defmacro returnval (symbol)\n  `(progn\n     (format t \",0.5083,[[0.19539234]],0.06031738654112208,0.15499037142480923,0.23129251700680273,0.041379310344827586,0.16326530612244897
"I have been trying to write the results by setting *trace-output* to file-generated stream like this
(setf *trace-output* (open ""log.txt""))

but this fails with Error: Unexpected end of file on #<BASIC-FILE-CHARACTER-INPUT-STREAM.
So, the question is - is there any way to write results of trace to file ?
","(setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
","TRACE works by redefining the function to something that prints the trace messages and then calls the original function. But you're not normally allowed to redefine built-in functions, so you get this error.
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 This is an often asked question. There are possibly duplicates of this on Stackoverflow.
The output can be buffered.
You then need to call the standard Common Lisp function FINISH-OUTPUT to force the IO system to write any pending output.
After that, read.
 It's the expected behavior, because stream-map returns a stream as its output. To get its contents you have to evaluate or force the result, for instance using stream->list on the stream:
(stream->list (remove-newlines2 (file->stream ""text-source-file"")))

 The process shown in your code is recursive - you can see that at each call, in the else part there's an operation still pending: an addition. Typically, an iterative process passes the answer around as a parameter (the accumulator) in such a way that the recursive call is in tail position - that is, it's the last thing we do, with no pending operations left.
In your stack trace it's obvious that a recursive process is occurring, the calls to the * procedure pile up to a certain point, and then start to go back - it looks like a triangle. Compare it with this, a truly iterative multiplication; here we don't see the triangle shape when running trace, and the procedure runs in a constant amount of space:
(define (mul a b)
  (define (iter count acc)
    (if (zero? count)
        acc
        (iter (- count 1) (+ acc a))))
  (iter b 0))

(trace mul)
(mul 343 799)

>(mul 343 799)
<274057
274057

 The only way is running under gdb and setting a break in SP_ueber and using call back_trace_out(0,0) when the breakpoint is reached.
","To redirect the output of tracing to a file in Common Lisp, you need to ensure that the stream is opened for output and that any buffered data is flushed. You can do this by using `:direction :output` instead of `:direction :input`, and then calling `finish-output` after setting `*trace-output*`. Here's how you can do it:

```lisp
(setf *trace-output* (open ",0.5766,[[0.32227325]],0.12045157913872524,0.4203728683231351,0.28205128205128205,0.10526315789473685,0.1282051282051282
"I'm having a little trouble with an assignment. I have to create a procedure that requests a list of lists and an element and proceeds to add the element to the first position in every sublist. I managed to do that and it looks like this: 
(define (add-element lst elem)
   (foldr cons lst (list elem)))

(define (insert-first lst1 x)
  (cond
   [(empty? lst1) empty]
   [else (local [(define insert (add-element(first lst1) x))]
        (cons insert (insert-first (rest lst1) x)))]))

So if you were to type (insert-first '((a b) (c d)) you'd end up with (list (list 'x 'a 'b) (list 'x 'c 'd))
Only problem is that I'm required to code the procedure using map and local. The latter one I think I accomplished but I can't for the life of me figure out a way to use map.
","(define (insert-first elt lst)
  (map (lambda (x)
         (cons elt x))
       lst))

then
(insert-first 'x '((a b) (c d)))
=> '((x a b) (x c d))

","You don't need eval here; use begin instead to group those definitions together into a list; i.e., the template to be expanded should be of the form:
`(begin 
   ,@(map ...)
   (define ...)
   (define ...)
   ...)

Edit:
Change for-each to map as suggested by OP.
 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 If I understood correctly, you can combine reduce and append to flatten the list before returning it.  
Example:  
(reduce 'append '((1) (2) (3)))

Output:  
(1 2 3)

In your case this might work:
(reduce 'append (mapcar 'recursive-function L))

 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

","You can achieve this using `map` by defining a local helper function that adds an element to the beginning of each sublist. Here's how you can do it:\n\n```lisp\n(define (insert-first lst1 x)\n  (map (lambda (sublist) (cons x sublist)) lst1))\n\n;; Example usage:\n(insert-first '((a b) (c d)) 'x)\n```\nThis will give you the desired output: `((x a b) (x c d)).`\nUsing `map` directly applies the lambda function to each sublist in `lst1`, effectively adding the element `x` at the beginning of each sublist.",0.6311,[[0.16433309]],0.23928741241560936,0.5831709297872042,0.34710743801652894,0.21848739495798317,0.3140495867768595
"I have the following filter function that filters out a list, x, that doesn't satisfy the function f.
For example, I call (filter 'evenp '(0 1 2 3)) and get back (NIL 1 NIL 3). But this is exactly my problem. How do I make it so that I just get back (1 3) ?
(defun filter (f x)
    (setq h (mapcar #'(lambda (x1)
                        (funcall f x1))
                    x))
    (mapcar #'(lambda (a b)
                (cond ((null a) b)))
            h x))

i.e. the problem is right here: (lambda (a b) (cond ( (null a) b)  )  ) In my cond I don't have a t , or else statement, so shouldn't it just stop right there and not return nil ? How do I make it ""return"" nothing, not even nil, if the (cond ( (null a) b) ) isn't satisfied?
Much appreciated. :)
","Based on this question it would be:
(remove-if #'evenp '(0 1 2 3))

","You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The function is applied to each key-value tuple of the incoming map. The [[k v]] destructures the tuple, so that in the first case, k will have the value :a, and v the value {:x (1 2) :y (3 4)}. 
The for loop the iterates through tuples in v, destructuring again, so that in the first case, k2 will be :x and v2 will be (1 2).
This is passed to concat, so that our first entry will be (:a :x 1 2)
","The issue with your current filter function is that when `a` is null, it returns `b`, but you want to return only the elements of `x` that satisfy the predicate `f`. To achieve this, you can modify the filter function to collect and return only the elements from `x` that satisfy the condition instead of processing them through mapcar twice. Here's a revised version of your filter function:\n\n```lisp\n(defun filter (f x)\n  (remove-if-not f x))\n```\n\nThis `remove-if-not` function directly returns a list of elements from `x` for which the predicate `f` is true, effectively filtering out the ones that do not satisfy the condition. This should give you the desired output when calling `(filter 'evenp '(0 1 2 3))`, resulting in (0 2) instead of (NIL 1 NIL 3).",0.503,[[0.08223]],0.05355045630253933,0.2972920623476684,0.11612903225806451,0.06535947712418301,0.1032258064516129
"So i started learning Lisp yesterday and started doing some problems.
Something I'm having a hard time doing is inserting/deleting atoms in a list while keeping the list the same ex: (delete 'b '(g a (b) l)) will give me (g a () l).  
Also something I'm having trouble with is this problem.
I'm suppose to check if anywhere in the list the atom exist.
I traced through it and it says it returns T at one point, but then gets overriden by a nil.
Can you guys help :)?
I'm using (appear-anywhere 'a '((b c) g ((a))))
at the 4th function call it returns T but then becomes nil.
(defun appear-anywhere (a l)
  (cond
   ((null l) nil)
   ((atom (car l))
    (cond
     ((equal (car l) a) T)
     (T (appear-anywhere a (cdr l)))))
   (T (appear-anywhere a (car l))(appear-anywhere a (cdr l)))))

","Let's look at one obvious problem:
(defun appear-anywhere (a l)
  (cond
   ((null l) nil)
   ((atom (car l))
    (cond
     ((equal (car l) a) T)
     (T (appear-anywhere a (cdr l)))))
   (T (appear-anywhere a (car l))(appear-anywhere a (cdr l)))))

Think about the last line of above.
Let's format it slightly differently.
(defun appear-anywhere (a l)
  (cond
   ((null l) nil)
   ((atom (car l))
    (cond
     ((equal (car l) a) T)
     (T (appear-anywhere a (cdr l)))))
   (T
    (appear-anywhere a (car l))
    (appear-anywhere a (cdr l)))))

The last three lines: So as a default (that's why the T is there) the last two forms will be computed. First the first one and then the second one. The value of the first form is never used or returned.
That's probably not what you want.
Currently your code just returns something when the value of a appears anywhere in the rest of the list. The first form is never really used.
Hint: What is the right logical connector?
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The message seems pretty clear to me: you are trying to get the first element of an empty list, which conflicts with your specification.
Based on this reference, it seems that first expects a non-empty list, whereas car returns nil when your input is nil.
Either you handle the nil case explicitely with an endp test or you use car instead of first.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 nconc is a destructive operation that alters its first argument by changing its tail. In this case, it means that the constant list '(oh my) gets a new tail.
To hopefully make this clearer. It's a bit like this:
; Hidden variable inside exclaim
oh_my = oh → my → nil

(exclaim '(lions and tigers and bears)) =
    lions → and → tigers → and → bears → oh_my

(nconc * '(goodness)) destructively appends goodness to the last result:
    lions → and → tigers → and → bears → oh → my → goodness → nil
so now, oh_my = oh → my → goodness → nil

Replacing '(oh my) with (list 'oh 'my) fixes this because there is no longer a constant being shared by all and sundry. Each call to exclaim generates a new list (the list function's purpose in life is to create brand new lists).
",Answer not found.,0.329,[[0.01370398]],7.248559300526378e-37,0.004465282429113641,0.011428571428571429,0.0,0.011428571428571429
"In Common Lisp, I need to capture user input in the form of a list of reals. This list is terminated by two zeros in a row. For example, 5.0 0 6.0 3 2.0 5 1.0 7 13.0 8 0 0 should return the list (5.0 0 6.0 3 2.0 5 1.0 7 13.0 8). 
I've come across the function read-delimited-list, which takes a single character as an ending point. I can stop at a single zero, but I'm not sure how to expand this function, and I don't know of another function that takes a delimited string instead of a char. 
EDIT Thanks to the accepted answer, I've developed the following:
(butlast (loop for y = -1 then x for x = (read stream) until (and (= 0 x) (= 0 y))
    collect x)))

It seems a bit more readable to me (and at this point I'm openly admiting that my Lisp eyes are only 3 days old), and I'm not sure about performance implications (does collect append or reverse the list after the loop exits scope? is there an easier way to chop off the last element, or simply not append it?).
","For such simple case you can just use read in a loop, collect the results read so far and stop, when the last two are zeros.
(defun read-double-zero-terminated-list (stream)
  (do* ((prev -1 val)
        (val (read stream) (read stream))
        list)
       ((and (zerop prev) (zerop val)) (reverse (cdr list)))
     (push val list)))

read-delimited-list is intended for the cases of creating specialized syntax, so it's probably overkill here.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 This is a result of using a constant list in the initializer:
(let ((myList '(0 0 0 0 0 0)))

Change that line to:
(let ((myList (list 0 0 0 0 0 0)))

and it will behave as you expect.  The first line only results in an allocation once (since it's a constant list), but by calling list you force the allocation to occur every time the function is entered.
edit:
This may be helpful, especially towards the end.  Successful Lisp
The answer to this question may also be helpful.
This uses the loop keyword collecting which collects the results of each iteration into a list and returns the list as the value of the loop.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
","To capture user input in the form of a list of reals terminated by two zeros in a row in Common Lisp, you can use the `loop` macro. Your approach is quite close and actually works well. The key part is to ensure that the loop correctly handles the termination condition using two consecutive zeros. Here's your solution with some minor adjustments for clarity and performance optimization:\n\n```lisp\n(let ((input-list '()))\n  (loop for x = (read stream) then y until (and (= 0 x) (= 0 y)) do\n    (setq y x)\n    (push x input-list))\n  (butlast input-list))\n```\n\nThis code reads the numbers into a list and uses `push` to add them in reverse order. The `butlast` function is then used to remove the last element, which should be the first zero. This approach avoids appending elements at the end of a growing list and directly constructs the final list in the desired order.\n\nIf you prefer using `loop` for its readability, your original solution with some modifications can also work:\n\n```lisp\n(butlast (loop for x = -1 then y for y = (read stream) until (and (= 0 y) (= 0 x)) collect x))\n```\n\nThis version ensures that the loop correctly handles the termination condition and constructs the list as intended.",0.5767,[[0.39728082]],0.12024417995917167,0.3647276087601342,0.25938566552901027,0.041237113402061855,0.13651877133105803
"So I am looking to sum up the numbers between zero and one hundred million. This code works extremely well for ten million, executing on my machine in about 3 seconds. However as soon as I attempt to sum up to one hundred million, it freezes my computer along with never finishing. I have waited for this code to finish for five minutes and yet it still will not finish.
#lang racket/base

(require (only-in racket/list range))

(let ([theList (range 0 100000000)]) (time (apply + theList)))

","You can use for/sum:
(for/sum ([i (in-range 100000000)])
  i)

Like all of the for/xxx variations, for/sum is essentially implemented in terms of for/fold (which Chris Jester-Young explained). In other words for/sum is a convenience wrapper around for/fold.
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 You got rid of the msg parameter, but you were still trying to use it. Use let to bind a local variable to that value.
(defun timed-notification()
  (interactive)
  (let ((msg ""Take a break, time's up!""))
    (run-at-time 25 nil (lambda (mess) (terminal-notifier-notify ""pomodoro"" mess)) msg)))

 Well, considering that (fib n) causes n-1 calls to fib-helper, your solution runs in linear time.  fib-helper only calls itself once for each iteration, and each iteration is a tail call, so your program runs in constant space.
This means that a call to (fib 1000) should only take about ten times the CPU time of (fib 100) while taking up the same amount of memory.
","The issue you are encountering is due to memory constraints. When generating a list of numbers from 0 to 100 million using Racket's `range` function and then trying to sum them up with `(apply + theList)`, Racket attempts to create an extremely large list in memory, which quickly exceeds your system's available RAM, leading to the computer freezing.",0.4857,[[0.09655143]],0.04949090432330787,0.225022502250225,0.19047619047619047,0.0,0.1142857142857143
"I want to override some basic function, let's say save-buffer (even if it does not make sense, it's for the sake of clarity), and give it a new definition. But I want all the original behaviors to be callable by adding a C-u.
So,

C-x C-s become my new definition of save-buffer.
C-u C-x C-s would call the original C-x C-s (without argument)
C-u C-u C-x C-s would be same same as calling the original C-x C-s with one C-u

and so on: always ""one less"" C-u...
Right now, I test for the value of arg. If nil, I execute my new defintion; otherwise, I call-interactively save-buffer (for the example). But, then, save-buffer is called with one C-u argument. I don't see how to do the ""-1"" C-u part.
","Here's one way to do it:
(defun foo (arg)
  (interactive ""p"")
  (message ""foo %s"" arg))

(defun bar (arg)
  (interactive ""p"")
  (message ""bar %s"" arg))

(defmacro wrap (fg f g)
  `(defun ,fg (arg)
     (interactive ""p"")
     (message ""%s"" arg)
     (if (= 1 arg)
         (funcall ,g 1)
       (funcall ,f (/ arg 4)))))

(wrap baz #'foo #'bar)

Now a plain baz will call bar. With C-u
it will call foo, dividing the given arg by 4.
","The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

","To achieve the desired behavior where `C-x C-s` calls your new definition of `save-buffer`, and additional `C-u` arguments call the original `save-buffer` with one less `C-u` argument, you can define a wrapper function that checks for the presence of `C-u` (i.e., non-nil prefix argument) and then either execute your custom logic or call the original `save-buffer`. Here's how you can do it in Emacs Lisp:\n\n```lisp\n(defun my-save-buffer (&optional arg)\n  \",0.516,[[0.11444813]],0.062158920437312,0.20442468552754212,0.2012578616352201,0.03821656050955413,0.11320754716981132
"I'm having problems with auto indentation in vim while programming in lisp.
My .vimrc had the following settings for tabs:
set noexpandtab
set autoindent
set softtabstop=0
set shiftwidth=8
set tabstop=8

When I type (if <enter> in insert-mode, a new line is created with an indentation of two spaces.
None of my settings say anything about two spaces, so why don't I get a tab?
What setting can I use to change the indentation while in insert-mode?
Thanks in advance!
Update:
Thanks for the answers, the settings are not overwritten.
It has to do with the ""default lisp indenting"".
In the :help lisp it says something about changing the p flag in
cpoptions. This is what it says in the help for the cpoptions flags:
p - Vi compatible Lisp indenting.  When not present, a slightly better algorithm is used.

Setting it does change the indent to one space instead of two spaces.
Still not sure how to change this to something else though.
","Looks like this is two-space indentation is a hard coded behavior of :set lisp mode which ignores shiftwidth.
We can trace this to the source code which contains a hard-coded amount += 2; increment statement.
It's that way for a good reason; it has come to be the predominant way of writing Lisp.
As I wrote this answer, I peeked at samples of source code the following projects (all Lisp or Lisp-like languages):

Steel Bank Common Lisp (SBCL);
Clozure Common Lisp (CCL);
GNU Emacs;
Clojure;
GNU Guile;
Racket;
and GNU CLISP.

I did not spot a single example of anything but two-space indentation! With two-space indentation, you are in good/large company. You might as well get used to that; even if you somehow get Vim to follow your way, if you upstream anything into anyone's Lisp project, you will likely have to reformat.
Now, I have seen Lisp code using four-space indentation, like in very old code bases and some books.
By the way, sometimes you see if indented like this:
(if (condition)
    (then)
    (else))

This may happen where indentation is four spaces, but I'm referring situations when this is alignment, and not four space indentation. This formatting is, of course, standard for function arguments, but controversial for operators such as if. Some people like it that way in their code bases. For instance, this institution's randomly found coding style guide recommends this way of writing if, while also recommending two-space indentation.
Vim will do the above if you remove if from lispwords.
The :set lispwords=... parameter contains a comma-separated list of identifiers which follow operator-like indentation, meaning two spaces rather than function-like alignment: second and third lines align with argument. By default, if is found in lispwords.
Lisp mode also applies two space indentation to a function (i.e. form not listed in lispwords, if there is no argument):
(gobbledygook 1 2 
              2 3)

(gobbledygook
  1)

That's also ""canonical"". Sometimes this comes in handy if you're trying to conform to some maximum line length; a function call running past the limit can sometimes be made to fit by moving all its arguments down, and just giving them two space indentation.
","This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
","The issue you're experiencing with auto indentation in Vim while programming in Lisp is related to the 'default lisp indenting' behavior. The setting `p` in `cpoptions` controls this behavior, and it defaults to Vi-compatible Lisp indenting, which can sometimes lead to unexpected indentation like what you've observed.\n\nTo change the indentation to something else (for example, tabs instead of spaces), you need to adjust your Vim settings further. Here's a possible approach:\n\n1. Set `expandtab` to enable tab expansion: `set expandtab`\n2. Adjust `shiftwidth` and `tabstop` to match your desired tab size: `set shiftwidth=4 set tabstop=4`\n3. Modify `cpoptions` to disable the 'default lisp indenting': `set cpoptions-=p`\n\nCombine these settings in your `.vimrc` file:\n```vim\ncset noexpandtab\nset autoindent\nset softtabstop=0\nset shiftwidth=4\nset tabstop=4\nset cpoptions-=p\n```\nThis should give you more control over the indentation behavior in Lisp files. If you want to specifically target Lisp files, you can use an autocmd like this:\n```vim\ncaugroup lisp_indent\nc  setlocal noexpandtab shiftwidth=4 tabstop=4 cpoptions-=p\nccend\n```\nThis will apply the settings only when editing Lisp files.",0.5113,[[0.3816516]],0.06591951686462348,0.17153284671532848,0.2752613240418118,0.027972027972027972,0.11498257839721256
"Very Simple
with this, (sort L #'> :key #'second)), I can sort, (((C) 1) ((D) 1) ((E) 1) ((F) 1) ((G) 1) ((H) 1) ((B) 3) ((A) 8))
But now I want to sort, ((((A) 8)) (((B) 3)) (((C) 1)) (((D) 1)) (((E) 1)) (((F) 1)) (((G) 1)) (((H) 1))).
What do i need to do to, (sort L #'> :key #'second)), to get the second list to sort?
","I hope I understand your question correctly.
What you need is :key (lambda (x) (second (car x))).
However, you do not even need lambda:
(cadar '(((A) 8)))
==> 8

so :key #'cadar is your friend.
","As mentioned in first comment it is necessarily to use (list a b c) form.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 If you have two criteria to sort by, you can first sort by the secondary, then stable-sort by the primary criterion:
(stable-sort (sort polynomial #'< :key #'third)
             #'string<
             :key #'second)

(You can compare symbols with string< because symbols are string designators.)
If you have a more complicated function that defines the order, define that separately, for example:
(sort polynomial #'term<)

(defun term< (term0 term1)
  (if (string= (second term0) (second term1))
      (< (third term0) (third term1))
      (string< (second term0) (second term1))))

 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

","To achieve the desired sorting, you need to change the key function in the `sort` call. Instead of using `#'second`, which refers to the second element in a list, you should use a function that accesses the first element of each sublist since your new list structure has one-element sublists. Here's how you can do it:

```lisp
(sort L #'> :key (lambda (x) (first x)))
```

This will sort the list based on the first element of each sublist, resulting in the order you want.",0.5452,[[0.14005904]],0.1440895982932439,0.3571981713613,0.20168067226890757,0.05128205128205127,0.11764705882352942
"Basically I want to spawn a process changing its working directory.
My idea was to spawn a process and set the PWD enviroment variable.
There's a way to obtain something like that?
(virtually I would like to change any of the environment variables for flexibility)
","Just bind the default-directory variable before spawning your process.  Example:
(let ((default-directory ""/tmp/""))
  (call-process ""/bin/bash"" nil ""*scratch*"" nil ""-c"" ""echo working dir is $PWD""))

I ran this from my *scratch* buffer and the string working dir is /tmp was added to the buffer.
","A good start would be to get rid of functions like car, cdr, cadar, ...
Write access functions for the data records. Use first, second and third.
For accessing the list's first element use the function FIRST.
For accessing the rest of the elements use the function REST.
This makes the code easier to read and understand.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 According to the CLHS:
load sequentially executes each form it encounters in the file
named by filespec

which means that a file is a sequence of forms.
 Finally, an option that worked for me was to use the transaction queue API, which is higher level (so it cannot handle all sorts of protocols), but ensures correct ordering of alternating messages.
 Found your bug. Most of your functions are declared to receive the expression as the first argument and the bindings as the second one, yet on your example you are calling the function passing the bindings as the first argument and the expression as the second. You must either call (evalexp p1 '((x 2) (z 8))) or swap the argument order on your function definitions (I'd suggest this solution, as it seems more natural and looks like the assignment @rainer-joswig linked).
Particularly, subst-bindings and evalexp are the ones which need the change.
 Several companies are using Racket commercially.  One significant example is Untyped, which built their scheduling/workflow tracker system Kahu in Racket, and also uses it for other projects.
","Lisp itself does not have built-in functionality to directly change the working directory or environment variables of a spawned process. However, you can achieve this by using system calls or integrating with foreign functions if your Lisp implementation supports it (e.g., via CFFI in Common Lisp).

For example, in Common Lisp, you might use the `unix:chdir` function to change the current working directory and modify environment variables through the `posix:setenv` function.

Here is a simple illustration:

```lisp
(defun spawn-process-with-cwd (command dir &rest env-vars)
  ",0.5352,[[0.20484352]],0.08158811096768431,0.2883211678832117,0.2753623188405797,0.0,0.14492753623188404
"I'm writing a program in Common Lisp in which I need a function with this basic outline:
(defun example (initial-state modify mod-list)
  (loop for modification in mod-list
        collecting (funcall modify initial-state modification)))

The problem is that I need initial-state to be the same every time it is passed to modify, but modify can be destructive.  I would simply make a copy, but I don't want to make any assumptions about what type of data initial-state is.
How can I make this happen?  Or is it even possible?
Thanks!
","If the function can be destructive and you cannot do anything about it then it's clear you need to make copies of initial-state.
One possibility to avoid preconfiguring what kind of data does initial-state contains is to leave providing a copy operation explicitly a problem for the caller or to make it a generic operation and relying on someone else to provide a method.
;; Version 1: the caller must provide a function that
;;            returns a new fresh initial state
(defun example (build-initial-state modify mod-list)
  (loop for modification in mod-list
        collecting (funcall modify (funcall build-initial-state) modification)))

;; Version 2: copy-state is a generic function that has been
;;            specialized for the state type
(defun example (initial-state modify mod-list)
  (loop for modification in mod-list
        collecting (funcall modify (copy-state initial-state) modification)))

The first version is more general because it allows the state to be any object while in the second version the copy operation depends on state object type (and this means you cannot have two callers both using lists as state with a different copy semantic).
However copy-state is a general operation that can be probably used in other places and making the operation a generic increase usability (you don't need to pass around builder functions instead); it also allows the introduction of other generic operations like compare-state, write-state, read-state...
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You're modifying a quoted list which is undefined behavior. If you want to construct a list to modify, you should use (list ...) instead of '(...).
If you initialize cnt-list to (list (list 'a 0) (list 't 0) (list 'c 0) (list 'g 0)), it should work as intended.
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
",Answer not found.,0.3436,[[0.]],3.3277630632111484e-42,0.003956478733926805,0.0,0.0,0.0
"This question arose when reading SICP. Why (list 'quote '(a b c)) evaluated by the interpreter (R5RS in Dr.Racket) as '(a b c). For me it should be (quote (a b c)). For instance (list 'quot '(a b c)) is evaluated as (quot (a b c)). What is so special in the 'quote?
","It also took me a while to understand this problem. But it's just your good-hearted lisp interpreter showing (quote (a b c)) in it's equivalent form '(a b c). Since there is no such equivalence/syntactic sugar for (quott (a b c)), it's shown as is.
","As mentioned in first comment it is necessarily to use (list a b c) form.
 'name is read to (quote name).
FUNCTION expects a name for a function, a list (setf some-name) or a lambda expression.
(quote name) is neither. So it is an error to use it.
 ' is not equivalent to list, it's shorthand for quote. You're really doing this:
(setq stuff (quote (one two three (+ 2 2))))

The argument to quote is the expression (one two three (+ 2 2)).
From http://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html: ""The special form quote returns its single argument, as written, without evaluating it"".
 The reason is that you quote the list:
> (= 'foo (first '(foo)))
true
> (= 'foo (first (list foo)))
false
> (= foo (first (list foo)))
true

 There is no need to use the sharp-quote syntax here.  Its purpose is to use a function name in a variable position, but a is a variable already.  Just write a instead of #'a.
 quote is a special operator which returns its single unevaluated argument. The form (quote ...) can be abbreviated using ' as '....  Since the ' is handled by the reader, the form
'('(1) '(2)))

is actually read the same as 
(quote ((quote (1)) (quote (2)))

The outermost application quote to the the argument((quote (1)) (quote (2))) returns that argument.  The cadr of that argument is the list
(quote (2))

whose first element is the symbol quote, and whose second element is a list of a single element 2.
","The form (list 'quote '(a b c)) evaluates to '(a b c) because 'quote is a shorthand for the quote special operator. The reader interprets 'quote' as (quote quote), and when this is passed to list, it creates a list with the single unevaluated argument '(a b c). On the other hand, if you were to use (list 'quot '(a b c)), it would not work because quot is not recognized as a special operator; thus, it would be interpreted as a variable or function name. The key point is that ' is used to quote symbols, and when quoted within list, it simply passes the symbol without evaluating it.",0.5668,[[0.26687192]],0.1689299409955897,0.39237566239574456,0.2893081761006289,0.1019108280254777,0.18867924528301888
"Hi I am trying to understand whether it is possible to take instruction opcodes and 'poke' them into memory or smehow convert them to a binary program. I have found an abandoned lisp project here: http://common-lisp.net/viewvc/cl-x86-asm/cl-x86-asm/ which takes x86 asm instructions and converts them into opcodes (please see example below). The project does not go further to actually complete the creation of the binary executable. Hence I would need to do that 'manually' Any ideas can help me. Thanks.
 ;; assemble some code in it
(cl-x86-asm::assemble-forms 
  '((.Entry :PUSH :EAX)
    (:SUB :EAX #XFFFEA)
    (:MOV :EAX :EBX)
    (:POP :EAX)
    (:PUSH :EAX)
    (.Exit :RET))

Processing...
;; print the assembled segment
(cl-x86-asm::print-segment)

* Segment type DATA-SEGMENT
Segment size 0000000C bytes
50 81 05 00 0F FF EA 89
03 58 50 C3

","I learned that it can be done using CFFI/FFI for example the very simple asm code:
(:movl 12 :eax)
(:ret)

This will be converted to the following sequence of octets: #(184 12 0 0 0 195) which in hex it is: #(B8 C 0 0 0 C3). The next step is to send it to a location in memory as such:
(defparameter pointer (cffi:foreign-alloc :unsigned-char :initial-contents #(184 12 0 0 0 195)))
;; and then execute it as such to return the integer 12:
(cffi:foreign-funcall-pointer pointer () :int)
=> result: 12

Thanks to the experts in #lisp (freenode irc channel) for helping out with this solution.
","This is an often asked question. There are possibly duplicates of this on Stackoverflow.
The output can be buffered.
You then need to call the standard Common Lisp function FINISH-OUTPUT to force the IO system to write any pending output.
After that, read.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 You could use a regex like this (PCRE syntax):
(\d*\.\d+|\d+)[fd]?

(Anchor it as required.)
Translated to Emacs style regex (by Jon O):
""\\<\\([0-9]*\\.[0-9]+\\|[0-9]+\\)[df]?\\>""

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","To take instruction opcodes and 'poke' them into memory or convert them to a binary program in Lisp, you can use the cl-x86-asm project you mentioned. After assembling the code to get the opcodes, you need to write these opcodes to memory. This typically involves creating a buffer in memory, writing the opcodes to this buffer, and then arranging for the operating system to treat this buffer as an executable file. Here is a conceptual approach using Lisp:\n\n1. Assemble the code to get the opcodes.\n2. Create a buffer in memory where you will store these opcodes.\n3. Write the opcodes into the buffer.\n4. Save or execute the buffer as needed.\n\nHere's an example of how you might do this, assuming you have already obtained the opcodes:\n\n```lisp\n(defvar *buffer* (make-array 100 :element-type 'unsigned-byte))\n\n;; Assume `opcodes' is a list of binary opcodes obtained from cl-x86-asm\n(let ((offset 0))\n  (dolist (opcode opcodes)\n    (setf (aref *buffer* offset) opcode)\n    (incf offset)))\n\n;; Save the buffer to a file or treat it as an executable in some way\n(with-open-file (out \",0.5301,[[0.28797085]],0.0923271717663728,0.32171580847499065,0.25,0.03225806451612903,0.1346153846153846
"I'm a Lisp noobie having some difficulty understanding how loop and format work when combined.
This works as I expect:
(loop for i upto 2 do (format t ""~a"" ""Badger"")) ==>
BadgerBadgerBadger
NIL
This does not:
(loop for i upto 2 do (format nil ""~a"" ""Badger"")) ==>
NIL
Why does this second loop not return BadgerBadgerBadger ? What code must I write to give this return value?
","This depends on the first parameter of the format function, called destination (see the manual):

If destination is a string, a stream, or t, then the result is nil. Otherwise, the result is a string containing the ‘output’

In the first case, format writes to the standard output (you see the three ""Budger"") and returns NIL. But you do not see that value, but the value returned by loop, which is NIL. In fact, no clause in LOOP is present  (like RETURN) to return something different from NIL.
In the second case, format returns the string, but the value of the loop is again NIL, which is result of the whole form.
If you want to return the result of the format, you could, for instance, write:
(with-output-to-string (s)
   (loop for i upto 2 do (format s ""~a"" ""Badger"")))

In this way, the format function ""write"" to the string stream s, which is returned by with-output-to-string.
","Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Please cut and paste the code in my previous answer and use it verbatim. Here, you've actually made some changes to the code to make it incorrect: instead of your original one-armed if, you've made it even worse, a zero-armed if.
A correctly-formatted two-armed if expression looks like this (noting that expr1 and expr2 are supposed to be flush with (indented to the same level as) test):
(if test
    expr1
    expr2)

This means that if test evaluates to a truthy value (anything other than nil), then expr1 is evaluated, and its value is the value of the if expression; otherwise expr2 is used instead. In the code snippet I had, test is (null (first (rest list))), expr1 is 0, and expr2 is (+ (distance (car list) (first (rest list))) (helper-2 (rest list))).

The other nice thing about using my code snippet directly is that it's already formatted correctly for standard Lisp style, which makes it much more pleasant for other Lisp programmers to read.
 One option is to have the stream as a slot instead of the filename, and then scope it with WITH-OPEN-FILE:
(with-open-file (stream file)
  (let ((foo (make-instance 'foo :stream stream)))
    (frob foo)
    (...other processing of foo...)))

Then your stream will be closed automatically.
 Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

",The difference between `(format t ,0.4178,[[0.29719849]],6.616387025089584e-15,0.014530659691950016,0.04790419161676646,0.0,0.03592814371257485
"I'm trying to understand the scheme code of make-counter procedure. It's a higher order procedure (a procedure outputs another procedure) and I'm stuck with it.
(define make-counter
  (lambda (n)
    (lambda () 
      (set! n (+ n 1))
      n)))

(define ca (make-counter 0))
(ca)
(ca)

This outputs 1 and 2 respectively as expected. Why do we need 2 nested procedures here? What are their functions individually?
I'd be appreciated if someone explains in details. Thanks from now on.
","Indented properly, this is:
(define make-counter
  (lambda (n)
    (lambda ()
      (set! n (+ n 1))
      n)))

By the way, you can use a different syntax:
(define (make-counter n)
  (lambda ()
    (set! n (+ n 1))
    n))

make-counter is a function that accepts a number n and returns an object called closure, which acts like a function but contains a state. Different invocations of  make-counter will produce different closures, even when given the same n in argument. A closure can be called using the function-call syntax, as you experimented.
When you call the closure, the code that is contained within is executed. In your example, the closure accepts zero arguments, and mutates the variable named n. Again, the binding from n to a value is local to the closure and different for all instances of counters. But inside a particular counter, n always refer to the same memory location.
A call to the set! function changes what n evaluates to, and replaces the previous value with (+ n 1), incrementing the local counter variable.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 To turn make-canned-format into a function, you need to replace
function with
compile or
(coerce (lambda ...) 'function).
However, your refactoring is misguided.
make-canned-format should be a macro - this way it will produce
a closure in the current compilation environment.
The function, however, will produce a closure in the global environment.
 You will somehow need to print the whitespace yourself.  Simple extension of your code:
(loop for i from 1 to 5
      do (princ i)
         (princ #\space))

(Note that I used princ instead of prin1.)
 Quite often they will be.  For instance imagine some debugger which is trying to print a backtrace in a useful way.  It's going to want to map between the procedure objects sitting in the backtrace and their names.  And that map is either going to point at the 'wrong' name, or it's going to point at all the names and you then have to know which one you actually used.
Here's an example in Racket:
> (object-name cons)
'cons
> (define make-thingy cons)
> (object-name make-thingy)
'cons

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

","The `make-counter` procedure is designed to create a closure that maintains its own state (the variable `n`). The two levels of procedures are necessary because of how closures work in Lisp. Here's a breakdown:\n\n- The outer lambda function `(lambda (n) ...)`: This takes an initial value `n` as its argument and returns the inner procedure.\n- The inner lambda function `(lambda () ...)`: This is the actual counter that maintains the state of `n`. Each time it is called, it increments `n` by 1 and returns the new value.\n\nThe reason for using two levels of procedures is to encapsulate the state (`n`) inside a closure. When you call `(make-counter 0)`, it creates an environment where `n` is bound to the initial value (in this case, 0). The inner procedure then has access to this environment and can modify `n`. This way, each time you call the returned procedure (e.g., `ca`), it operates on the same state.\n\nIf you only had one level of procedures, each call to `(make-counter 0)` would create a new `n` that is not related to any previously created counters. Using two levels ensures that all calls to the inner procedure share the same state.",0.5873,[[0.6112409]],0.22267765212539525,0.3827812559691521,0.5079365079365079,0.11170212765957446,0.20634920634920634
"I want to create the equivalent of a ""nested LET"" as in Haskell, where I can refer to some values bound in the outer LET. The caveat is that the function defined in the inner scope needs to dispatch on the type of its argument, so defgeneric came to mind.
Now this is my confusion: I have only ever defined this at ""top level"" (at package scope); is it possible to define it within an arbitrary lexical context ?
If not, is there a recommended alternative ? One hacky solution would be to pass the ""context"" as a defstruct argument to the function, I'm hoping there's something better ?
(I hope my intent is not lost in translation!)
Edit: This was a stupid question, I should have just tried it. In case someone looks for the answer to this, it is YES, and also ""of course"", (duh)
As a simple example,
(let ((x 4))  
      (defgeneric bar (y))  
      (defmethod bar ((y integer)) (1+ y))  
      (bar x))

evaluates to
5

","You can do that. It has a few downsides.

DEFMETHOD and DEFGENERIC are top-level forms. This means that the file compiler recognizes them and then knows about them. Inside a LET, these forms are no longer top-level forms and the compiler does not recognize them.
It makes debugging harder. Suddenly there is a context for methods.
It makes updating methods harder. I can't not just evaluate a DEFMETHOD form to update the method, I would also need to evaluate the context.

There are two typical ways to use a context at runtime:

Use a dynamic binding at runtime
Use a parameter at runtime

Example for 1:
(let ((*user* (find-current-user)))
  (declare (special *user*))
  (serve-page ...))

Alternatively the special variable could be declared global.
Example for 2:
(serve-page ... :user (find-current-user))

Even a plain package local variable can be good enough...
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 Portably, no.  Implementations are free to return whatever kind of string they deem sensible.
I'd use a simple wrapper function and maybe declaim it inline:
(declaim (inline read-simple-line))
(defun read-simple-line (stream)
  (some-> (read-line stream nil)
          (coerce 'simple-base-string)))

(Some-> is from arrows).
","In Common Lisp, you can indeed define functions such as `defgeneric` and `defmethod` within a lexical context. The example you provided is correct: defining a generic function `bar` and a method for integers within a `let` block works as expected. This is because `defgeneric` and `defmethod` are macros that expand into forms that can be evaluated in the current lexical environment, just like other top-level forms. Therefore, it's perfectly fine to define these within any appropriate lexical context.",0.5162,[[0.28906309]],0.07792022166143159,0.20540112284489367,0.3274336283185841,0.044642857142857144,0.1415929203539823
"I read the whole docs at https://github.com/fons/cl-mongo and understand (db.find ""foo"" (kv ($> ""i"" 3) ($< ""j"" 5))) means query when ""i>3 AND j<5"".
My question is what's the code for ""$or""? like query when i>3 or j<5?
Thanks.
","You need to translate whatever you need to express in mongo's format using the primitives of cl-mongo.
In mongo, I think that it would be:
{$or: [{i: {$gt: 3}},
       {j: {$lt: 5}}]}

In cl-mongo, you translate ""object""s to kv forms, and ""array""s to lists.  Many mongo operators have shorthands defined, but I think $or is not one of them, so you'd need to either define that or do it explicitly:
(kv ""$or""
    (list ($> i 3)
          ($< j 5)))

A convenience macro for $or might look like this:
(defmacro $or (&rest forms)
  `(kv ""$or"" (list ,@forms)))

Then you can write
($or ($> i 3)
     ($< j 5))

(untested).
","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 Built in:
$ clisp -q
[1]> (sublis '((a . 0) (b . 1)) '(and 1 (or a b)))
(AND 1 (OR 0 1))
[2]> 

So the homework reduces to making a wrapper for SUBLIS which accepts the bindings in the form ((a 0) (b 1)) rather than ((a . 0) (b . 1)).
Clue:
(loop for (x y) in vars collecting (cons x y))

 Not clear what you are asking, but ignoring errors simply is:
CL-USER 37 > (ignore-errors (read-from-string ""(. foo bar)""))
NIL
#<CONDITIONS:SIMPLE-READER-ERROR 402000243B>

In case of an error, IGNORE-ERRORS returns NIL and as the second return value the condition.
If you want more control, you would need to write an error handler.
","In MongoDB queries with Lisp using cl-mongo, you can use the `$or` operator by constructing a query that includes multiple conditions within an `or` clause. For example, to query when `i > 3` or `j < 5`, you would write the following code:\n\n```lisp\n(db.find \",0.5334,[[0.35842738]],0.030373661001357962,0.13309122027070747,0.2784810126582279,0.07692307692307693,0.1772151898734177
"Right to the point, in https://stackoverflow.com/questions/4696618/is-haskell-a-lisp?answertab=votes#tab-top, there is a comment by Kevin Cantu saying:

Yeah, moving beyond the syntax alone, JavaScript is probably more of
  a Lisp than Haskell. (Originally conceived as a Scheme
  implementation...)

Also, in Lambda the Ultimate: A Lisp to JavaScript Compiler in 100 Lines, they say:

It's immediately quite clear that JS and Lisp have strong ties at the
  semantics level [...]

I am familiar with Lisp and functional programming, but not with JavaScript. So these propositions made wonder how powerful is JavaScript. What I've read so far is that it provides lambda expressions and closures. What more functional programming concepts and Lisp-like features does it provide? Does it provide, for instance, tail call recursion, or macros, or ability to manipulate code as data (like Lisp)?
","Some things that JavaScript provides that can be considered ""Lisp-like"":

First class functions (inc. lambdas and closures)
Dynamic typing 
Dynamic object model that has some similarities with CLOS
A readable data format that matches the source code format (JSON)
Run time evaluation with an ""eval"" function (that can be used in an interactive REPL)

Some things that Javascript doesn't have that are pretty common or central to other Lisps:

A homoiconic representation for both code and data (S-expressions)
Built in literals for linked lists / sequences
Support for immutable data structures in general (especially true for Clojure, where every data structure is persistent and immutable)
An extensive macro system for meta-programming
Optional static typing for performance optimisation (e.g. type hints in Common Lisp or Clojure)
Concurrency support
Tail call optimisation 

","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The problem consists of two subproblems: parsing and symbolic manipulation. It seems to me the answer boils down to two possible solutions.
One is to implement everything from scratch: ""I do recommend creating the full expression tree if you want to retain maximum flexibility for handling tricky cases."" - proposed by Rex. As Sven points out: ""any of the high-level languages you listed are almost equally suited for the task,"" however ""Python (or any of the high-level languages you listed) won't take away the complexity of the problem.""
I have received very nice solutions in Scala (many thanks for Rex and Daniel), a nice little example in Python (from Sven). However, I am still interested in Lisp, Haskell or Erlang solutions.
The other solution is to use some existing library/software for the task, with all the implied pros and cons. Candidates are Maxima (Common Lisp), SymPy (Python, proposed by payne) and GiNaC (C++).
 In the metalanguage, the expression list[a; b] denotes the application of the function list to two arguments, which builds a list with two elements, which are the result of the evaluation of a and b respectively.
In the language of the S-expressions, so, this would be written as the usual function call: (LIST a b), that is a list with the first element the name of the function (LIST) and the rest of the elements the actual parameters of the function. Note that here I use the notation (a b) for S-expressions, and not (a, b). McCarthy itself changed this notation later, and in the LISP 1.5 Programmer’s Manual. 2. ed. Cambridge, Mass: MIT Pr, 1979. the new notation is used.
 Read McCarthy's 1960 paper, ""Recursive Functions of Symbolic Expressions and Their Computation By Machine, Part I"".
He starts by defining S-expressions.  One of the rules is that if e1 is an S-expression and e2 is an S-expression, then < e1 . e2 >, the dotted pair, is also an S-expression.
A few lines later, he defines the list notation, as a shorthand for an expression built up of a chain of dotted pairs.
This was the paper that first defined what would eventually become LISP.  It didn't become an actual programming language until Steve ""Slug"" Russell implemented the first interpreter.
","JavaScript is indeed more similar to Lisp at a semantic level than Haskell, primarily due to its dynamic nature and functional programming features. Here are some Lisp-like features provided by JavaScript:\n\n1. **Lambda Expressions**: JavaScript supports anonymous functions (lambda expressions) which can be created on the fly.\n2. **Closures**: JavaScript allows functions to have access to their own scope as well as the outer function’s scope, similar to lexical closures in Lisp.\n3. **Higher-Order Functions**: JavaScript has many built-in higher-order functions like `map`, `filter`, and `reduce`, which are essential for functional programming.\n\nHowever, JavaScript lacks some of the more advanced features found in Lisp, such as:\n\n1. **Tail Call Optimization (TCO)**: While JavaScript engines aim to optimize tail calls through techniques like TCO, it is not universally supported across all environments or versions.\n2. **Macros**: JavaScript does not have a macro system like Lisp’s which allows for code transformation at compile-time.\n3. **Code Manipulation as Data**: Although JavaScript can treat functions and function definitions as data (e.g., `eval`), this is generally discouraged due to security risks and performance issues compared to Lisp's more robust meta-programming facilities.\n\nOverall, while JavaScript shares many functional programming concepts with Lisp, it does not provide the full suite of features found in traditional Lisp implementations.",0.5707,[[0.26781915]],0.09292860980146904,0.3223671153732353,0.3240223463687151,0.03932584269662921,0.1340782122905028
"I was using condp form and noticed in its doc:

If no default expression is provided and no clause matches, an IllegalArgumentException is thrown.

I do not need to deal with non-match also don't want to surround condp with try form. I am thinking of putting a placeholder there. What is the fastest and easiest Clojure placeholder form?
Edit:
Thanks for everyone's opinions, very helpful! The use case of this behaviour is that in a user triggered, forced data recovery task, my application needs to dynamically parse Clojure code to recover data from log file. Corrupted data (the non-matches) shall be ignored and the same form if written in cond will take more key strokes than condp.
","You can say:
(condp = option
  :foo 1
  :bar 2
  3)

","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

",Answer not found.,0.3174,[[0.]],0.0004203989048568031,0.032051282051282055,0.0,0.0,0.0
"I'm currently trying to get an output of ... \hline in GNU Common lisp 2.49, but I can't get the format to work. This is what I've tried so far to get a single backslash:
(format nil ""\ "") => "" ""
(format nil ""\\ "") => ""\\ ""
(format nil ""\\\ "") => ""\\ ""

I thought that the double backslash would make it work, why isn't the backslash escaping just the other backslash?
","Note the difference between creating a string and actually doing output to a stream:
CL-USER 69 > (format nil ""\\ "")
""\\ ""                               ; result

CL-USER 70 > (format t ""\\ "")
\                                   ; output
NIL                                 ; result

CL-USER 71 > (format *standard-output* ""\\ "")
\                                   ; output
NIL                                 ; result

","You can use ""v"" on a frame to jump to the definition of the function in the debugger.
In this case, the function sb-kernel:two-arg-> sounds like a specialized version of > that is called when there are exactly two arguments provided. If the arguments are 1 and NIL, you'll get an error because NIL is not a number.
I'm not sure how you'd figure this out yourself, except by practicing and asking questions.
 Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Why would you do that? What you ask is to split a string (a one-dimensional array of characters) into a list of symbols. Do you really want that?
#\h is a character object printed.
You can print them differently:
CL-USER 8 > (princ #\h)
h

CL-USER 9 > (prin1 #\h)
#\h

Let's print the list using PRINC:
CL-USER 10 > (map nil #'princ (coerce ""Hello!"" 'list))
Hello!

Btw., since strings, vectors and lists are sequences, you can MAP directly over the string...
CL-USER 11 > (map nil #'princ ""Hello!"")
Hello!

 Your format call is wrong:
the second argument should be either a
string or a
function (cf. the error message!)
You need to replace it with (format stream ""~S"" text) or just use prin1 or write.
 According to https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Lexical-Binding.html, even when lexical-binding is non-nil, special variables (like x since it was defined with defvar) are still dynamically bound.
","In Common Lisp, escape sequences like \\ and \\\\ are interpreted by the reader when reading a string literal. When you use (format nil \",0.4013,[[0.12411952]],0.0038298243353879317,0.08138925240782559,0.20338983050847456,0.07017543859649122,0.16949152542372883
"I want to recur through a list of slot names of classes, the same slot names for two classes ((current-trial *exp*) & (previous *exp*) refer to instances of the same class). On each recursion, I want to evaluate the slot name so that the value of that slot of that instance may be got and set. The code below meets that expectation, but I worry about relying upon eval because it's slow and doesn't allow for lexical context (Graham, 1996). What would be alternative formulations that would be efficient and allow for lexical context?
(dolist (a '(letter number font color height))
  (eval 
   `(when (eq (,a (current-trial *exp*)) 
              (,a (previous *exp*)))
     (setf (,a (current-trial *exp*)) 
           (random-not-item 
            (,a (current-trial *exp*)) 
            (,a *exp*))))))

","Since these are slot names, you can use slot-value:
(dolist (a '(letter number font color height))
  (when (eq (slot-value (current-trial *exp*) a) 
            (slot-value (previous *exp*) a))
    (setf (slot-value (current-trial *exp*) a) 
          (random-not-item 
           (slot-value (current-trial *exp*) a) 
           (slot-value *exp* a)))))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Since these are slot names, you can use slot-value:
(dolist (a '(letter number font color height))
  (when (eq (slot-value (current-trial *exp*) a) 
            (slot-value (previous *exp*) a))
    (setf (slot-value (current-trial *exp*) a) 
          (random-not-item 
           (slot-value (current-trial *exp*) a) 
           (slot-value *exp* a)))))

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
","To avoid using `eval` and improve efficiency while maintaining lexical context, you can use a more explicit approach with lambda functions. Here is an example of how you could rewrite your code to achieve the same functionality without relying on `eval`:",0.4311,[[0.02550057]],0.03418315482184557,0.12182203389830508,0.08791208791208793,0.04494382022471909,0.08791208791208793
"I want to implement my particle filtering algorithm in parallel in Common Lisp. Particle Filtering and sampling can be parallelized and I want to do this for my 4-core machine. My question is whether programming in parallel is feasible in CL or not and if it is feasible are there any good readings, tutorials about getting started to parallel computing in CL. 
","Definitely feasible!
The Bordeaux Threads project provides thread primitives for a number of implementations; I would suggest using it instead of SBCL's implementation-specific primitives (especially if you aren't on SBCL!).
The thread primitives are provided by bt are, however, quite primitive.  I've used and enjoyed Eager Future2 which builds on bt to provide concurrency features using futures.  You can create futures that are computed lazily, eagerly (immediately), or speculatively.  The speculative futures are computed by a thread pool whose size can be customized.
I started a little project to provide parallel versions of CL functions using EF2, but it's only about three functions so far, so it won't be of much use to anyone.  I do of course welcome other coders to hack on it and submit pull requests, and I hope to do more work on it in the future.
There are many other libraries listed on Cliki that I haven't tried myself.
As far as tutorials, I don't know of any, but the concurrency features provided are found in other languages as well and good algorithms and practices are not generally language-specific.
If you're interested in reading a book, I recommend The Concurrent C Programming Language.  The authors describe a new programming language, based on C, with concurrency as a language feature. Of course, due to the nature of CL, it would likely be possible to implement these features without resorting to creating a new compiler. In my opinion the book presents excellent concurrency concepts, and addresses many of the problems you may encounter or fail to consider in writing concurrent programs.
","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Yes, it's possible. The easiest way would be to simply redefine the class. You do that by issuing another call to DEFCLASS. If you want to do more complicated things, you have to resort to the MOP (MetaObject Protocol). Essentially everything you'd ever want to do is possible using the MOP, but I would need more detailed information as to what it is you're trying to do in order to explain it further.
 Not a direct answer I'm afraid but I would recommend watching this as rainbow-delimiters is available in MELPA and this will make managing Emacs extensions MUCH easier.
 The loop/recur version is the right way.  Clojure cannot optimize tail calls due to limitations of the JVM. 
 This isn’t a perfect answer, but it’s more on-topic than other resources I found. This paper, “Functional Data Structures in Typed Racket,” discusses alternative functional data structures that perform better than standard lists in certain contexts, and gives specific timing results that includes garbage-collection time (HT Greg Hendershott):
http://www.ccs.neu.edu/racket/pubs/sfp10-kth.pdf
And here is the code for the implementations:
https://github.com/takikawa/tr-pfds
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
","Programming in parallel in Common Lisp (CL) is definitely feasible and can be effectively managed using various mechanisms provided by the language. One of the most popular approaches is using the built-in `MP:PROCESS` and `MP:THREAD` facilities for creating and managing parallel processes or threads. Additionally, you can use higher-level constructs like `MPI-Common-Lisp` if your algorithm requires distributed computing.

For a good starting point, I recommend checking out the following resources:

1. **LispWorks Parallel Programming Guide**: Provides detailed information on how to write parallel programs in Lisp.
2. **Quicklisp Documentation for ASDF**: To manage your dependencies and ensure that you have all necessary libraries installed.
3. **Common Lisp HyperSpec**: The official Common Lisp Hypermedia Specification provides comprehensive documentation, including sections on concurrency.

Here is a simple example of using threads in CL:

```lisp
(ql:quickload :cl-threads)

(defun parallel-particle-filtering (n)
  (let ((results '()))
    (dotimes (i n)
      (push (mp:process-run-function 
             (format nil ",0.544,[[0.31657018]],0.09177181353594598,0.2297439494914065,0.30484988452655887,0.03248259860788863,0.11547344110854503
"Is there a way to compare two functions for equality? For example, (λx.2*x) == (λx.x+x) should return true, because those are obviously equivalent. 
","It's pretty well-known that general function equality is undecidable in general, so you'll have to pick a subset of the problem that you're interested in. You might consider some of these partial solutions:

Presburger arithmetic is a decidable fragment of first-order logic + arithmetic.
The universe package offers function equality tests for total functions with finite domain.
You can check that your functions are equal on a whole bunch of inputs and treat that as evidence for equality on the untested inputs; check out QuickCheck.
SMT solvers make a best effort, sometimes responding ""don't know"" instead of ""equal"" or ""not equal"". There are several bindings to SMT solvers on Hackage; I don't have enough experience to suggest a best one, but Thomas M. DuBuisson suggests sbv.
There's a fun line of research on deciding function equality and other things on compact functions; the basics of this research is described in the blog post Seemingly impossible functional programs. (Note that compactness is a very strong and very subtle condition! It's not one that most Haskell functions satisfy.)
If you know your functions are linear, you can find a basis for the source space; then every function has a unique matrix representation.
You could attempt to define your own expression language, prove that equivalence is decidable for this language, and then embed that language in Haskell. This is the most flexible but also the most difficult way to make progress.

","In here, you're testing x against the actual procedures:
(or (equal? * x) (equal? + x))

Whereas in here, you're testing x against a couple of symbols:
(member x '(+ *))

The above line expands to (list '+ '*). To make an equivalent comparison, you'd have to do this instead:
(member x (list + *))

 You can define a function that returns true when a list contains another one :
(defun member (x liste) 
   (cond
      ((null liste) ()) 
      ((equal (car liste) x) liste) 
      (t (member x (cdr liste))))) 

(defun inclus (liste1 liste2) 
   (cond 
      ((null liste1) t) 
      ((member (car liste1) liste2)(inclus (cdr liste1) liste2)) 
      (t ()))) 

Then use it to determine whether the two lists are equal :
(defun compare (liste1 liste2)
   (if ((and (inclus liste1 liste2) (inclus liste2 liste1)))
      (print ""the 2 lists are equivalent"")
      (print ""the 2 lists aren't equivalent""))) 

 (second expr) is the list (* 3 x) which is not a number, but the function sqrt demands a number for its argument. Since you say you want to do symbolic differentiation, you probably should return a list with the symbol sqrt in it, rather than calling the function.
 I suggest you use (not (equal? foo bar)) if not equals works.  Please note that there may be faster comparators for your situiation such as eq?
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The difference in using the macro vs function is in whether all the choices always are evaluated.
The expanded in macro evaluates the choices sequentially. If it reaches a choice that is eql to the first argument, it returns a true value without evaluating any more
forms.
In contrast, the in-func function will evaluate all the choices at the time the function is called.
","In Lisp, comparing two functions for equality is not straightforward because functions are first-class citizens and can have different internal representations even if their behaviors are equivalent. However, you can achieve a form of comparison by comparing the source code or the lambda expressions that define these functions. For example, you could create a function that compares the structure of the lambda expressions. Here's a simple approach using `equal?` to compare the lambda forms:\n\n```lisp\n(defun equal-lambdas? (lambda1 lambda2)\n  (equal? lambda1 lambda2))\n\n(equal-lambdas? '(lambda (x) (* 2 x)) '(lambda (x) (+ x x))) ;; This will return T if the lambdas are structurally identical.\n```\nNote that this method only checks for structural equivalence, not semantic equivalence. For more complex scenarios, you might need to implement a more sophisticated analysis of the functions' behaviors.",0.5277,[[0.41505862]],0.10993565793316443,0.21435594886922324,0.32558139534883723,0.046753246753246755,0.14470284237726097
"SBCL (directory ""*"") is filtering out some file names based on extension.
How do I get it to return all files, or especially all files matching a pattern (as in bash globing)
(directory ""*"")  ;Lists some files, not all
(directory ""MyFile"")  ;Lists some files, but again, filters by extension
Extensions that seem to me ignored... at least *.lisp is not listed.
SBCL 1.1.2-1.fc18 on Fedora18
","The translation from globs to pathnames is implementation and system dependent.  Pathnames distinguish the filename and the filetype (extension).  When you specify just *, SBCL on Linux interprets this as ""any filename, but extension must be empty"".  You can say *.* to specify all files.  The . in *.* is interpreted as the separation between filename and extension, so *.* means not just the filenames containing a literal dot.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 One option is to put (sb-ext:disable-debugger) early in your startup function. When an error occurs and there is no handler, SBCL will print an error and a backtrace and exit.
Another option is to write a function that does what you want on error and set it as your debugger hook; see command-line-debugger in buildapp itself for an example.
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 Directory paths should end with a trailing slash.
The docstring in C-hv default-directory RET is explicit about that, in fact.
Fixing that ought to fix your problem.
See also:

cd function.
file-name-as-directory function.

 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

","The issue you're facing with directory filtering might be due to case sensitivity or specific file system behavior. In some Unix-like systems, file names can be case-sensitive and extensions may not be treated uniformly by default functions like DIRECTORY. To get all files including those matching a pattern similar to bash globbing, you could use a combination of CLISP's DIRECTORY function with additional logic to match the desired patterns.\n\nFor example:\n```lisp\n(defun find-files-matching-pattern (pattern directory)\n  (let ((all-files (directory (concatenate 'string directory ",0.5225,[[0.17220841]],0.06629254972797562,0.2948328267477203,0.21518987341772156,0.025641025641025644,0.12658227848101267
"I'm having difficulties with two lists of different lengths.
(f '(8 1 2 3 23 12) '(2 9 4 6)) should return (1 2 3 4 6 8 9 12 23)
This is my trying code.
(defun f (lst lst2)
  (cond ((or(null lst) (null lst2)) 0)
  (t (sort (cons (first lst) (cons (first lst2) (f (rest lst) (rest lst2)))) #'<))))

Plus, Can you handle duplicates in lisp?
I will appreciated any help.
","This can easily be done with standard functions. To make one list out of two you use append, however the last argument is shared so I copy it with copy-list since stable-sort is destructive. delete-duplicates removes the duplicates in the resulting list. 
(defun f (lst1 lst2)
  (delete-duplicates (stable-sort (append lst1 (copy-list lst2)) #'<))))

(f '(8 1 2 3 23 12) '(2 9 4 6))
; ==> (1 2 3 4 6 8 9 12 23)

","
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 You're using the function list instead of your argument lst at the second to last line. (f (rest list) n) should be (f (rest lst) n)
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 You're overcomplicating it. You don't need to sort the CDRs of the sub-lists returned by SPLIT-LIST, just sort the whole lists, and merge them.
(defun MSORT (L)
  (cond ((endp L) nil)
        ((endp (cdr L)) L)
        (t
         (let* ((S (SPLIT-LIST L ))
                (L1 (car S))
                (L2 (cadr S))
                (X (MSORT L1))
                (Y (MSORT L2)))
           (MERGE-LISTS X Y)))))

 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
 Maybe I misunderstand. If you don't want input wouldn't it be easier to just completely replace the function?
(defvar default-files-string-new ""*.sch"")
(defun igrep-read-files (&optional prompt-prefix)
  `(,(expand-file-name (concat default-directory
                               default-files-string-new))))

","To address your problem with two lists of different lengths and handling duplicates, you can modify your function `f` to concatenate both lists first, handle duplicates by converting them into a set (using `remove-duplicates`), and then sort the result. Here's an example of how you can do it:\n\n```lisp\n(defun f (lst lst2)\n  (let ((combined-list (append lst lst2)))\n    (sort (remove-duplicates combined-list) #'<)))\n\n(f '(8 1 2 3 23 12) '(2 9 4 6)) ;; This will return (1 2 3 4 6 8 9 12 23)\n```\n\nThis function first concatenates the two lists using `append`, then removes any duplicates with `remove-duplicates`, and finally sorts the resulting list in ascending order.",0.6963,[[0.38977943]],0.31649402287586487,0.4891748763659854,0.5174129353233831,0.22110552763819097,0.34825870646766166
"I'm new to lisp programming and i was wondering how do you output strings without quotes and without returning an object (that includes not returning a nil) like most languages?
std::cout<<""Hello world\n"";

I know the format t function does that but it still returns nil isn't there a way to output without nil and quotes? Is it possible?
Can someone point me to Lisp tutorials like this or this but with more detailed documentation and explanations?
","The REPL prints the value of each expression it executes
If you use the READ EVAL PRINT LOOP, the REPL will print the result. That's why it is called Read Eval Print Loop.
But output functions themselves will not print their result.
CL-USER 1 > (format t ""hello"")
hello      ; <- printed by FORMAT
NIL        ; <- printed by the REPL

CL-USER 2 > (format t ""world"")
world      ; <- printed by FORMAT
NIL        ; <- printed by the REPL

Now combine the above:
CL-USER 3 > (defun foo ()
              (format t ""hello"")
              (format t ""world""))
FOO

CL-USER 4 > (foo)
helloworld     ; <- printed by two FORMAT statements
               ;    as you can see the FORMAT statement did not print a value
NIL            ; <- the return value of (foo) printed by the REPL

If you return no value, the REPL will print no value.
CL-USER 5 > (defun foo ()
              (format t ""hello"")
              (format t ""world"")
              (values))
FOO

CL-USER 6 > (foo)
helloworld   ; <- printed by two FORMAT statements
             ; <- no return value -> nothing printed by the REPL

You can execute Lisp code without a REPL
If you use Lisp without a REPL, no values are printed anyway:
$ sbcl --noinform --eval '(format t ""hello world~%"")' --eval '(quit)'
hello world
$

Alternatively you can have Lisp execute a Lisp file:
$ cat foo.lisp
(format t ""helloworld~%"")
$ sbcl --script foo.lisp
helloworld
$

The actual command lines are implementation specific.
","Quick answer, you need to use :if-exists :append.
The Common Lisp HyperSpec has the following to say about open:

if-exists---one of :error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, or nil. The default is :new-version if the version component of filespec is :newest, or :error otherwise.

And if we look at what it says about :append:

:append
Output operations on the stream destructively modify the existing file. The file pointer is initially positioned at the end of the file. If direction is :io, the file is opened in a bidirectional mode that allows both reading and writing.

 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Quoting in lisp prevents evaluation of the s-exp and passes it around as a function.
Therefore, you're comparing the non-evaluated function '(reverse (a b)) to the list '(a b)
If you changed the code to 
(equal (reverse '(a b)) '(b a))

(reverse '(a b)) would yield '(b a), and thus the equal comparison would return true.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
","In Common Lisp, you can use the `=format` function from the `CL-USER` package (which is usually included by default) or the `FORMAT` macro to output strings without returning an object. The `FORMAT` macro allows you to output strings directly without needing to return a value. Here's an example:\n\n```lisp\n(format t \",0.4835,[[0.37242574]],0.002074692771859405,0.0660371522322524,0.20216606498194944,0.04363636363636364,0.1444043321299639
"I saw the usage of & in Clojure function signature like this (http://clojure.github.io/core.async/#clojure.core.async/thread):
(thread & body)

And this:
(doseq seq-exprs & body)

Does that means the function/macro can accept a list as variable? I also find * is often used to mean multiple parameters can be accepted, like this:
(do exprs*)

Does anyone have ideas about the difference between & and * in function/macro signature? Is there any documentation to explain this syntax?
","In clojure binding forms (let, fn, loop, and their progeny), you can bind the rest of a binding vector to a sequence with a trailing &. For instance, 
(let [[a b & xs] (range 5)] xs) ;(2 3 4)

Uses of * and other uses of & are conventions for documenting the structure of argument lists. 
","In clojure binding forms (let, fn, loop, and their progeny), you can bind the rest of a binding vector to a sequence with a trailing &. For instance, 
(let [[a b & xs] (range 5)] xs) ;(2 3 4)

Uses of * and other uses of & are conventions for documenting the structure of argument lists. 
 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

 Macros are useful for language extensions that can't easily be represented as functions. Matthias Felleisen suggests the following three semi-canonical uses for macros:

changing the order of evaluation (viz: 'or')
introducing new binding forms (viz: 'let')
introducing a new data language (viz: 'quote')

For more on these, see this posting to the LL1 mailing list
","In Clojure (and Lisp in general), both `&` and `*` are used to handle variadic arguments, but they serve different purposes within function signatures.\n\n- The `&` symbol is used for binding the rest of a list into an argument. For example, in the signature `(defn my-func [a b & xs])`, `xs` will be bound to any additional elements beyond `a` and `b`. This allows you to pass a variable number of arguments to your function.\n\n- The `*` symbol is used for destructuring sequence forms. In the context of binding forms such as `let`, `fn`, or `loop`, it binds the rest of the list into a sequence, which can be accessed within the body of the form. For example, in `(let [[a b & xs] (range 5)] xs)`, `xs` is bound to all elements after `a` and `b`.\n\nFor more detailed documentation on this syntax, you can refer to the Clojure documentation or the Common Lisp HyperSpec for similar constructs.",0.6169,[[0.49271701]],0.15661099662752612,0.37179441327288937,0.3791469194312796,0.15311004784688995,0.22748815165876776
"How to install the slime into emacs under Win7?
I download a compact package with '.tgz'. But it seems for linux. But there is really not one thing for windows(win 32 OS).
I unfold this package and I find there are lots of documents. 
","It's actually the same as for other operating systems, as far as I can tell. (At least, it always worked for me under FreeBSD/ArchLinux/Win7.) First, you unpack to a location you like, then add something like this to your .emacs (assuming you unpacked somewhere under your user directory):
(add-to-list 'load-path ""~/my/path/to/slime/"")
;; (add-to-list 'load-path ""~/my/path/to/slime/contrib/"") ; for optional features

(slime-setup
;; '(slime-fancy slime-asdf slime-references              ; optional features
;;   slime-indentation slime-xref-browser)
)

(setq slime-lisp-implementations
      '((ccl (""~/path/to/ccl/wx86cl""))
        (clisp (""~/path/to/clisp-2.49/clisp"" ""-modern""))) ; giving a command arg
      slime-default-lisp 'ccl)

Restart Emacs or type C-x C-e behind each of these toplevel forms. Then, type M-x slime RET (or C-u M-x slime RET if you want to choose between the implementations in slime-lisp-implementations, otherwise slime-lisp-default will be used) and it should just work (it does for me). The setting of slime-lisp-implementations is optional – you can also give the path to your lisp implementation executable by hand when starting Slime.
Assuming you want to use Slime with CL, since there is no Clojure tag. If you want to use it with Clojure, things are unfortunately a little different and both versions don't play very nicely together. The recommended way for use with Clojure, last time I checked, would be installation using the package system of Emacs 24 or, if you're using an older version, ELPA (which is essentially the same).
","The slime section in my .emacs:
;;; SLIME
(setq inferior-lisp-program ""/usr/bin/sbcl"")
(add-to-list 'load-path ""/usr/share/emacs/site-lisp/slime/"")
(require 'slime)
(require 'slime-autoloads)
(slime-setup '(slime-fancy))
(global-set-key ""\C-cs"" 'slime-selector)

 The codebase changed much since version 1, and the tutorial is a little bit outdated. There is, however, a compatibility layer to that version.
(ql:quickload :clack-v1-compat)

Then, the appropriate packages are loaded and you should be able to continue the tutorial.
 It is an implemntaiton issue:
ccl e$ rlwrap ./dx86cl64
Loading ~/ccl-init.lisp
Welcome to Clozure Common Lisp Version 1.7-dev-r14614M-trunk  (DarwinX8664)!
? (subtypep 'string '(array character))
T
T
? 

 As the first try, you should download and install Emacs 22.3 for your Windows box and then compare the speed.
Speed difference shouldn't be that big after upgrade.
 yasnippet is a general method in emacs for modes to provide ""templating"". Not that many people that I know using clojure all day use it directly, of the folks i know most of them use it through the clj-refactor emacs package
https://github.com/clojure-emacs/clj-refactor.el
 For GNU/Emacs, you can choose to use any one of the following three file names as the start-up configuration file:
${HOME}/.emacs
${HOME}/.emacs.el
${HOME}/.emacs.d/init.el

It would probably be a good idea to decide on one of the three options and then stick to it - the first one seems to be the most widely used one. In any case, ${HOME} stands for your home directory -- which is likely to be different from the Lisp In A Box install directory!
Coming from a Unix tradition, Emacs understands ~ (tilde) as an abbreviation for your home directory, so you can visit the .emacs file by typing:
C-x C-f ~/.emacs [ENTER]

(Note that the capital C is Emacs standard notation for a combination of the CTRL key and a second key, i.e. here you press CTRL-x CTRL-f which stands for ""find-file"" and will then ask you for a file name in the bottom part of the Frame (aka mini-buffer).)
If these are your first customizations, you will just see an empty buffer. Enter 
;; start CUA mode every time Emacs starts
(cua-mode t)

and save the buffer with C-x C-s.
Next time you start Emacs, CUA mode should be turned on automatically.
","For Windows, you typically do not need to download a tarball manually as you would for Linux. Instead, you can install SLIME using Emacs' package management system or through a pre-configured package like Spacemacs or Doom Emacs which handle the setup for you. If you prefer to set it up manually, ensure you have Emacs 24.3 or later installed, and then add the following to your .emacs file (assuming Windows paths):",0.5402,[[0.39579099]],0.011749290440477046,0.10420085329832622,0.255192878338279,0.03582089552238806,0.12462908011869436
"I learn emacs lisp now and I wonder why it maybe useful to treat code as data. What a benefits of this approach. I saw one explanation as this is alternative to traditional Von Neumann architecture where exists clear separattion between data and code. 
I'd like to understand a meaning for this decision, get the idea. 
Thanks in advance, Nick.  
","You can write code that will write code for you. This can be done in two ways:

First, your program can create new code as a list and pass it to the eval function, which will evaluate the new code at runtime (however, eval is something you should not abuse -- actually, it should be used seldomly, when you really need it). You could theoretically do this in languages that do not have the homoiconicity property, but it would be a lot harder. 
For example, in Scheme you may do this

(define form '(x 10))
(set! form (append 'define form)
(eval form (interaction-environment)

and the value of x will be 10 after that. This could be used, for example, in Genetic Programming

You may also define macros. A macro is a little function that reads something that looks like a function call, but is translated (expanded) into something else before the program starts evaluating forms (that is, before it is run). For example, in many Lisps or is a macro. This code,

(or a b c)

is translated into
(let ((tmp1 a))
  (if tmp1
      tmp1
      (let ((tmp2 b))
        (if tmp2
            tmp2
            (let ((tmp3 c))
              (if tmp3
                  tmp3
                  #f))))))

You could implement or as a function, but then the function would have to evaluate all its arguments before returning. Since or is a macro, it will not necessarily evaluate all arguments. 
You can read more about macros in Wikipedia and in this cool book [ beside several other places on the net, like here, 
here and here for example ]. And you can read about eval in Wikipedia and in this great book.
You can also read Paul Graham's On Lisp (the book is completely free), which teaches basic Common Lisp in a somewhat fast pace and then gets into all kinds of programming techniques with macros, and later you can try Let Over Lambda (only some chapters are free).
About eval it may be interestig to read this question and its answers.
","I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
 Not a direct answer I'm afraid but I would recommend watching this as rainbow-delimiters is available in MELPA and this will make managing Emacs extensions MUCH easier.
 It's a very cool idea - would be great for evaluating mathematical expressions but you simply can't set an operator (or the logic behind it) to a variable.  Sorry :-)
 The message seems pretty clear to me: you are trying to get the first element of an empty list, which conflicts with your specification.
Based on this reference, it seems that first expects a non-empty list, whereas car returns nil when your input is nil.
Either you handle the nil case explicitely with an endp test or you use car instead of first.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 My elisp is a bit rusty, but until someone comes up with the actual explanation:  I could get your examples to work a bit more as expected my replacing cmd with (eval cmd) (possibly same with name) in the macro definition body.
Hope this helps.
","Treating code as data is a powerful concept that enables dynamic behavior and flexibility in programming languages like Emacs Lisp (Elisp). This approach allows you to manipulate, evaluate, and modify code at runtime, which can be incredibly useful. Here are some benefits of this approach:\n\n1. **Dynamic Behavior**: You can generate, modify, or execute code on the fly. For example, you might write a function that generates other functions based on input parameters.\n\n2. **Configuration as Code**: Instead of hardcoding configurations in files, you can define them dynamically within your program. This makes it easier to manage and customize behavior without modifying the source code directly.\n\n3. **Scripting and Automation**: Elisp's ability to treat code as data allows for powerful scripting capabilities. You can write small scripts that automate tasks or integrate with other tools in a flexible manner.\n\n4. **Meta-programming**: Meta-programming involves writing programs that generate, transform, or analyze other programs. This is particularly useful in languages like Elisp where you can create macros to extend the language itself.\n\n5. **Reflection and Debugging**: With code as data, it's easier to inspect and modify the internal state of a program at runtime, facilitating better debugging and introspection.\n\nIn contrast to traditional Von Neumann architectures, where there is a clear separation between data and instructions (code), treating both as first-class citizens blurs this line. This leads to more flexible and powerful programming paradigms.",0.53,[[0.47131454]],0.14131470283273678,0.23537980317792837,0.34494773519163763,0.06643356643356645,0.14634146341463414
"I am reading SICP's first chapter 
1.1.3  Evaluating Combinations
It states that 
To evaluate a combination, do the following: 

1.  Evaluate the subexpressions of the combination.

2.  Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands). 

Suppose an combination (+ 1 2)
According to the above algorithms,
The first is to evaluate (retrieve) + 1 and 2)
The second is to apply + to 1 (store the intermediate state)
The third is to evaluate(retrieve)  the intermediate state and 2 again.
The forth is to apply the intermediate state to 2.
Is it right?
What' the intermediate state of +1?
","The expression (+ 1 2) is a combination composed by the primitive expressions: +, 1, and 2.
The first step says to evaluate all the subexpressions. In this case they are, respectively, the operator which performs the sum of numbers, and the numbers corresponding to the numerals 1 and 2, respectively.
So you have an operator, and two numeric values. The second step says that you must apply the operator (leftmost value) to the two numbers: in other words you must apply the sum operator to 1 and 2, so to obtain the number 3. And the process terminate.
Note that there are no intermediate states in this computation.
","The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
 Two independent for clauses will do:
(loop for i from 1 to 10
      for fi = (funcall f i)
      when (> fi 0)
      collect (list i fi))

Both iteration clauses will be executed at every iteration. The second one will see each new value of i.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 You will find that, in the REPL, the variable * holds the last result, and + holds the last evaluated form. 
For example:
> (+ 1 2)
  => 3
> +
  => (+ 1 2)
> (+ 2 3)
  => 5
> *
  => 5

Yes, these are standard, and in the HyperSpec.
If you wish to create a list containing the symbol +, rather than its value, you will need to quote it, as such: '+, or (quote +).
 In the book, authors have an example of formulating an iterative process for computing the Fibonacci numbers.
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))

The point here is that use two parameter a and b to memorise f(n+1) and f(n) during computing. The similar could be applied: we need a, b, c to memorise f(n+2), f(n+1) and f(n)
;; an interative process implementation                                                                                                                       
(define (f-i n)                                                                                                                                               
  ;; f2 is f(n+2), f1 is f(n+1), f0 is f(n)                                                                                                                   
  (define (interative-f f2 f1 f0 count)                                                                                                                       
    (cond                                                                                                                                                     
      ((= count 0) f0)                                                                                                                                         
      (else (interative-f                                                                                                                                      
              (+ f2 (* f1 2) (* f0 3))                                                                                                                          
              f2                                                                                                                                                
              f1                                                                                                                                                
              (- count 1)))))                                                                                                                                   
  (interative-f 2 1 0 n))             

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
",Your understanding is largely correct. According to SICP's description for evaluating combinations:,0.4169,[[0.04770333]],4.0492651801414096e-05,0.04132231404958678,0.06666666666666667,0.0,0.049999999999999996
"Several weeks ago, SBCL updated 2.0.2 and brought the Block compilation feature. I have read this article to understand what it is. 
I have a question, what's the difference between (declaim (inline 'some-function)) and Block compilation? Block compilation is automatic by the compiler? 
Thanks.
","Inline compilation is a specific optimization technique. A function being called is directly integrated into the calling function - usually using its source code - and then compiled.
This means that the inlined function might not be inlined only in one function, but in multiple functions.
Advantage: the overhead of calling a function disappears.
Disadvantage: the code size increases and the calling function(s) needs to be recompiled, when the inlined function changed and we want this change to become visible. Macros have the same problem.
Block compilation means that a bunch of code gets compiled together with different semantic constraints and that this enables the compiler to do a bunch of new optimizations.
Common Lisp has in the standard support for block compilation of single files. It allows the file compiler to assume that a file is such a block of code.
Example from the Common Lisp standard:
3.2.2.3 Semantic Constraints

A call within a file to a named function that is defined in the same file refers to that function, unless that function has been declared notinline. The consequences are unspecified if functions are redefined individually at run time or multiply defined in the same file.

This allows the code to call a global function and not use the symbol's function cell for the call. Thus this disables late binding for global function calls - in this file and for functions in this file.
It's not said how this can be achieved, but the compiler might just allocate the code somewhere and the calls just jump there.
So this part of block compilation is defined in the standard and some compilers are doing that.
Block compilation for multiple files
If the file compiler can use block compilation for one file, then what about multiple files? A few compilers can also tell the file compiler that several files make a block for compilation. CMUCL does that. SBCL was derived and simplified from CMUCL and lacks it until now. I think Lucid Common Lisp (which is no longer actively sold) did support something like that, too.
Might be useful to add this to SBCL, too.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 As mentioned in first comment it is necessarily to use (list a b c) form.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 New method was exposed.
If you type the following code on the JS console, you will get 12.
jscl.evaluateString(""(* 3 4)"")
","The `declaim (inline 'some-function)` directive in Lisp tells the compiler to inline the function call during compilation. This means that instead of calling the function and passing control back and forth, the body of the function is directly inserted where it is called. In contrast, Block compilation refers to a feature where the entire block of code within a form or lambda expression is compiled as a single unit, potentially leading to more efficient machine code generation. While inlining can improve performance by reducing function call overhead, Block compilation can also optimize code by better understanding the structure of the code being executed. Block compilation is not automatically enabled; it depends on the compiler's heuristics and may be controlled or triggered explicitly.",0.5649,[[0.6224634]],0.05498894062720039,0.16690019456167782,0.32848232848232845,0.10020876826722337,0.17463617463617465
"i have the following code:
(defun TREE-CONTAINS (N TREE)
  (cond (( = (car TREE) nil) nil)
        (( = (car TREE) N) t)
         (t TREE-CONTAINS (N (cdr TREE)))
  )
)

which accepts a number N and a list TREE and checks to see if N exists in the list TREE. pretty simple, but for some reason i keep getting this error when i call my function 
(TREE-CONTAINS 3 '((1 2 3) 7 8))
*** - +: (1 2 3) is not a number

is there an issue with the code? i'm very new to Lisp so maybe i'm just not seeing something very obvious.. thanks in advance!
","Syntax errors
Your code contains several syntax errors that are flagged as compiler warnings:
CL-USER> (defun TREE-CONTAINS (N TREE)
           (cond (( = (car TREE) nil) nil)
                 (( = (car TREE) N) t)
                 (t TREE-CONTAINS (N (cdr TREE)))
            )
          )
;Compiler warnings :
;   In TREE-CONTAINS: Undeclared free variable TREE-CONTAINS
;   In TREE-CONTAINS: Undefined function N
TREE-CONTAINS

The reason is that parentheses in Common Lisp have a meaning different from that of other programming languages: they are not used to specify the order of application of the operators (like in 3 * (2 + 4) which is different from 3 * 2 + 4), but are integral part of the syntax to specify the different parts of a “statement”, like in cond or in function application (like (function-name arg1 arg2 ... argn)). So the syntax error in this case is in the last line, in which you should call the function TREE-CONTAINS with arguments N and (cdr TREE) as:
CL-USER> (defun TREE-CONTAINS (N TREE)
           (cond (( = (car TREE) nil) nil)
                 (( = (car TREE) N) t)
                 (t (TREE-CONTAINS N (cdr TREE)))
            )
          )
TREE-CONTAINS

Semantic errors
If you try this function, however, you will find an error:
 CL-USER> (TREE-CONTAINS 2 '(1 2 3))

 The value NIL is not of the expected type NUMBER.

The reason is that you have used = to compare a number ((car TREE)) with the value nil, while = can be used only to compare numbers. Use eq or eql instead for the general case:
CL-USER> (defun TREE-CONTAINS (N TREE)
           (cond (( eql (car TREE) nil) nil)
                 (( = (car TREE) N) t)
                 (t (TREE-CONTAINS N (cdr TREE)))
            )
          )
TREE-CONTAINS

CL-USER> (TREE-CONTAINS 2 '(1 2 3))
T

There is also another problem: you should check if the list is empty, not if the first element is nil. In other words, the first condition should be:
(cond ((eq TREE nil) nil)

or better:
(cond ((null TREE) nil)

Stylistic notes

A list is a particular case of tree: if you use the term tree the program should be more complex, taking into account cases in which the elements can be sublists.
Use lowercase identifier, since everything is translated to upper-case
Put the close parentheses at the end of the expression, not on a new line.

So your function could be something like:
(defun list-contains (n list)
  (cond ((null list) nil)
        ((= (car list) n) t)
        (t (list-contains n (cdr list)))))

Check membership for a tree and not a list
If, on the other hand, you want to check for a generic tree, i.e. a list which can contain sublists, like in (tree-contains 3 '((1 2 3) 7 8)), in your recursion you should consider tha case in which an element of the list is itself a list, and then perform a double recursion. Here is a possible solution:
CL-USER> (list-contains 2 '(1 (2 3) 4))

The value (2 3) is not of the expected type NUMBER.

CL-USER> (defun tree-contains (n tree)
           (cond ((null tree) nil)
                 ((listp (car tree)) (or (tree-contains n (car tree))
                                         (tree-contains n (cdr tree))))
                 ((= (car tree) n) t)
                 (t (tree-contains n (cdr tree)))))
 TREE-CONTAINS
 CL-USER> (tree-contains 2 '(1 (2 3) 4))
 T

","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
","The error you are encountering is due to a misunderstanding of how Lisp handles lists and recursion. Your function tries to use arithmetic operations on what should be numbers but instead treats them as lists or atoms. The issue lies in the recursive call where (N (cdr TREE)) should properly handle the list structure rather than trying to apply arithmetic or equality directly.\n\nHere is a corrected version of your function:\n\n```lisp\n(defun TREE-CONTAINS (N TREE)\n  (cond ((null TREE) nil)\n        ((= N (car TREE)) t)\n        (t (TREE-CONTAINS N (cdr TREE))))\n)\n```\n\nIn this version, `null` is used to check if the list `TREE` is empty. The function correctly compares `N` with `(car TREE)` and recursively calls itself on `(cdr TREE)`. This should work as expected without causing an error.",0.6175,[[0.6915796]],0.009532841608190932,0.10913623598627563,0.30518518518518517,0.10995542347696878,0.15703703703703703
"I would like a macro that can take any number of arguments and return a list of each argument, like this:
(TEST first second third)
=> '(first second third)

","Like so?
(define-syntax-rule (TEST . lst)
  (quote lst))

(TEST first second third)
=> '(first second third)

or simply
(define-syntax-rule (TEST . lst)
  'lst)

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You will find that, in the REPL, the variable * holds the last result, and + holds the last evaluated form. 
For example:
> (+ 1 2)
  => 3
> +
  => (+ 1 2)
> (+ 2 3)
  => 5
> *
  => 5

Yes, these are standard, and in the HyperSpec.
If you wish to create a list containing the symbol +, rather than its value, you will need to quote it, as such: '+, or (quote +).
 'name is read to (quote name).
FUNCTION expects a name for a function, a list (setf some-name) or a lambda expression.
(quote name) is neither. So it is an error to use it.
 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 With the third ~{, you are entering element-wise printing of the first sublist.  Each iteration consumes three elements of the sublist, so it is done after a single pass.  Then, this loop is exited and the next higher loop goes to the next iteration.  It skips another element of the outer list (the second sublist), but then there are no arguments left to use for entering the inner loop again.
Instead of skipping forward and backward, you could simply use both the : and the @ modifier of ~{ to process the remaining lists:
""|~{~9<~a~>~:@{|~6d~3d~3d~}~}|""

","You can create a macro in Lisp that takes any number of arguments and returns a list of those arguments using `&rest` to collect all arguments into a list. Here's an example:\n\n`(defmacro test (&rest args) (list 'quote args))`\n\nThen, when you call `(test first second third)` it will return `'(first second third)`. The macro expands the rest of its arguments into a single list and wraps that list in a quote form to prevent evaluation.",0.5197,[[0.1336083]],0.09142254104304107,0.23437499999999997,0.1730769230769231,0.09803921568627452,0.1730769230769231
"I am attempting to understand the lambda notion found within Emacs Lisp. 
In ielm, executing:
((lambda (x) (* x x)) 5)

gives us 25, and 
(let ((x 4)) (* x x))

gives us 16.  However when I do:
(let ((f (lambda (x) (* x x)))) (f 7))

it does not give me 49, but instead informs me:
*** Eval error ***  Symbol's function definition is void: f

Don't know why, I am sure the syntax is right and f is defined in the let?
Using cl-flet to define let-ed function
We can actually do this without using funcall.  The cl module includes standard functions from Common Lisp.  We first import it:
(require 'cl)

Thereafter we can use cl-flet to define our function:
(cl-flet ((f (x) (* x x)))
  (f 7))

","I'd be surprised if this isn't a duplicate, but I can't find it readily here on Stack Overflow. In ""Lisp-2"" languages (e.g., Emacs Lisp and Common Lisp), there are separate namespaces for functions and variables.  A function call looks like:
((lambda ...) ...) ; call the lambda function

or 
(f ...) ; call the function binding of f

If you want to call the function that is the value of a variable, then you need to use funcall or apply:
(apply f ...)

(funcall f ...)

The difference between apply and funcall is well documented in other places, but the quick difference is that apply expects an argument list (in some Lisps, a ""spreadable argument list""), whereas funcall takes the arguments directly.  E.g., 
(let ((f (lambda (a b) (+ a b))))
  (funcall f 1 2)      ; arguments directly
  (apply f '(1 2)))    ; arguments in a list

In a ""Lisp-1"", (like Scheme), you don't need funcall, since there's only one space for bindings.  In Scheme you can do:
(let ((f (lambda (a b) (+ a b))))
  (f 1 2))

The difference between Lisp-1 and Lisp-2 languages is described more in What is the difference between Lisp-1 and Lisp-2?.  The big difference is when the system sees a function call, how it figures out what function to call.  In a Lisp-1, variables have values, and that's all.  So when the system sees something like:
(f ...)

f is a variable, and the only possible thing to call is the value of f.  In a Lisp-2, the systems tries to call the function value of f, which doesn't have to have anything do with the value of the variable f.  That can be a bit confusing at first, but it's actually pretty handy in many cases, because it makes it harder to accidentally obscure functions with common names.  E.g., in a Lisp-1, you'll see lots of people use lst as an argument name instead of list, because if they named the argument list, then they couldn't use the (standard) function list within the function.
","CL-USER 52 > (remove 0 '((5 ((2 x)))
                         (3 ((1 y)))
                         (0 ((2 x))))
                     :key #'first)
((5 ((2 X))) (3 ((1 Y))))

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 CL-USER 39 > (reduce #'cons
                     '(1 2 3 4 5)
                     :initial-value '(a b c d e)
                     :from-end t) 
(1 2 3 4 5 A B C D E)

 Use the macro CHECK-TYPE:
CL-USER 9 > (let ((n ""10""))
              (check-type n integer))

Error: The value ""10"" of N is not of type INTEGER.

 CL-USER 68 > (let ((ans ()))
               (dolist (i mm (reverse ans))
                 (dolist (j mm)
                   (setq ans (cons (list (nth i mm)
                                         (nth j mm))
                                   ans)))))
((0 0) (0 1) (1 0) (1 1))

","The issue with your let form is that you are defining a function `f` within it but not actually using it. The `(f 7)` expression outside of the `let` is trying to use the symbol `f`, which is only bound in the scope of the `let`. To fix this, you need to ensure that the function is used or returned from the `let`. Here's how you can do it:\n\n```lisp\n(let ((f (lambda (x) (* x x))))\n  (funcall f 7))\n```\nAlternatively, if you want to directly use the function without calling `funcall`, you could return it from the `let` and then call it:\n\n```lisp\n(let ((f (lambda (x) (* x x))))\n  f)\n(funcall (let ((f (lambda (x) (* x x))))\n             f) 7)\n```\nUsing `cl-flet` is another option, but in this case, it's not necessary because the function is only used once. If you are working within Emacs Lisp and need to define a local function that can be called later, `cl-flet` might be more appropriate for scoping purposes.",0.5887,[[0.63367386]],0.15076713063904773,0.22207885954820256,0.40150093808630394,0.10546139359698681,0.16885553470919326
"I need to write a recursive function in Scheme which takes a list of atoms and reverses it in linear time. I am only allowed to use  define, lambda, cons, car, cdr, cond, let, and null? . Here is what I have so far:
(define reverse
  (lambda (lat)
    (cond
      ((null? lat) lat)
      (else (cons (reverse (cdr lat)) (cons (car lat) '()))))))

So when I call the function:
(reverse '(a b c d))

I get the following output:
'(() (((() 4) 3) 2) 1)

Any help would be very much appreciated.
","The problem is that if (reverse (cdr lat)) returns a list eg (3 2) then (cons '(3 2) (1)) turns into ((3 2) 1).
A classical way to do this would be to make a local procedure that takes an accumulator as well as the argument of the global procedure. As you are iterating the list from the beginning to the end you accumulate a list from the end to the beginning making it the exact reverse order from the argument. When the iterated list is null your answer is in the accumulator. As you notice you iterate once each element and when you hit the empty list you return the accumulator it's a perfect O(n) 
As a hint:
(define (myreverse lst)
  (define (myreverse-aux lst acc)
    (if (null? <??>)
        <??>
        (myreverse-aux <??> (cons <??> <??>))))
  (myreverse-aux <??> <??>))

Here is a version using foldl
(define (myreverse lst)
  (foldl cons '() lst))

","To implement a reverse function, you need to use an accumulator. Here is how you might implement this (in this case, tail is the accumulator):
(defun revappend (list tail)
  (cond ((null list) tail)
        (t (revappend (cdr list) (cons (car list) tail)))))

Then, implement reverse in terms of revappend:
(defun reverse (list)
  (revappend list nil))

 I think this will work:  
(define reverseList(lambda(x)(
                          if (null? (cdr x))
                             (cons (car x) '())
                             (append (reverseList (cdr x)) (cons (car x) '()))                                  
                             )
                 )
)

 The easiest way is to reverse the result:
(defun pozpar (lst)
  (do ((l lst (cddr l))
       (x '() (cons (car l) x)))
      ((null l)
       (nreverse x))))

(pozpar '(1 2 3 4 5))
==> (1 3 5)

Notes

This returns, not outputs the value you want.
Prepending values and reverting the result is a common Lisp coding pattern.
Since append is linear in the length of its argument, using it in a loop produces quadratic code.
I formatted the code in the standard Lisp way. If you use this style, lispers will have an easier time reading your code, and, consequently, more willing to help you.

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Iterate over your list and store each pair's car into a list in an assoc that looks like this:
original: ((2 . 1) (3 . 2) (1 . 2) (5 . 1) (6 . 3))
new:      ((1 . (2 5))
           (2 . (3 1))
           (3 . (6))

Then sum together all the cdrs and flip each pair to get this:
          ((7 . 1) (4 . 2) (6 . 3))

 You have a little bug in your code, try this in the EVALPlus procedure:
(+ (car argList) (car (cdr argList)))

Remember that cdr retrieves the next list, not the next element. After obtaining the next list, we call car to obtain its first element.
","The issue with your function is that you are recursively calling reverse on (cdr lat) before cons-ing it. This will cause incorrect results. Here’s a corrected version of the function:\n\n```scheme\n(define reverse\n  (lambda (lat)\n    (cond\n      ((null? lat) '())\n      (else (cons (car lat) (reverse (cdr lat)))))))\n\n(reverse '(a b c d)) ;; Output: (d c b a)\n```\nThis function correctly reverses the list in linear time. The key is to cons the car of `lat` with the result of reversing the cdr of `lat`, ensuring that the recursion builds the reversed list correctly.",0.599,[[0.46121127]],0.17096684734988252,0.24716383230983263,0.3107569721115538,0.05622489959839357,0.17529880478087648
"I have this code:
(define-foreign-library libc
  (:unix ""libc.so.6""))
(use-foreign-library libc)
(defcfun ""setlocale"" :pointer (category :int) (locale :pointer)) 

and I want to do:
(with-foreign-string (locale ""en_US.UTF-8"")
    (setlocale XXXX locale))

How can I find the integer values of the various LC_xxx constants so that I can pass them to the call above? Is there a better way of achieving this?
","I see this in my locale.h:
/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
#define LC_CTYPE          __LC_CTYPE
#define LC_NUMERIC        __LC_NUMERIC
#define LC_TIME           __LC_TIME
#define LC_COLLATE        __LC_COLLATE
#define LC_MONETARY       __LC_MONETARY
#define LC_MESSAGES       __LC_MESSAGES
#define LC_ALL            __LC_ALL
#define LC_PAPER          __LC_PAPER
#define LC_NAME           __LC_NAME
#define LC_ADDRESS        __LC_ADDRESS
#define LC_TELEPHONE      __LC_TELEPHONE
#define LC_MEASUREMENT    __LC_MEASUREMENT
#define LC_IDENTIFICATION __LC_IDENTIFICATION

and bits/locale.h contains:
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};

You could just compile a C program that prints them.
This is what the groveller does.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 I'd recommend using url-retrieve-synchronously that's included with Emacs.  The results are placed in a buffer, but you can easily evaluate it as a string like so:
(with-current-buffer (url-retrieve-synchronously ""http://stackoverflow.com"")
  (prog1
      (buffer-string)
    (kill-buffer)))

 In my Emacs, function kill-sexp is bound to C-M-k. That is, assuming the point is just before an opening delimiter of a balanced expression, press Control, Meta, and k at the same time.
This same command works in various other non-Lisp modes, such as killing brace-delimited blocks in a C-style mode, though the kill-sexp command may not be bound to the same keys.
 (setf *trace-output* (open ""log.txt"" :direction :output))

OPEN opens files for input by default.
 To use that stream library, you need to require pfds/stream like this:
(require pfds/stream)

Once you do that, the correct versions of take and stream will be available:
> (require typed/racket)
> (require pfds/stream)
> (take 3 (stream 1 2 3 4 5 6))
- : (Rec
     anonymous-module1715254
     (U Null
        (Boxof
         (U (Pairof Integer anonymous-module1715254)
            (-> (Pairof Integer anonymous-module1715254))))))
'#&#<procedure:.../pfds/stream.rkt:41:7>

 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
","To find the integer values of the various LC_xxx constants, you can consult the documentation for your specific operating system or use a tool like `locale -m` on Unix-based systems. These constants are typically defined in C headers such as `locale.h`. For example, on many systems, `LC_CTYPE`, `LC_COLLATE`, etc., correspond to the respective locale categories.\n\nIf you want to pass these constants to your foreign function call, you can use the integer values directly after finding them. Here’s an example of how you might do it in Racket:\n\n```racket\n(define-foreign-library libc\n  (unix ",0.502,[[0.19931172]],0.017955565960502254,0.1431435556719508,0.1923076923076923,0.0310077519379845,0.1076923076923077
"From what I understand, Common Lisp has no global lexical scope, so if you want to create a global variable you have to use defvar instead of setq. I'm trying to create a macro that just does this automatically, i.e. I'd like to write
(= x 1)

and have it ""just work"" no matter where I am. I imagine the macro would look something like
(defmacro = (name value)
  `(,(if (is-global) 'defvar 'setf) ,name ,value))

How can I write is-global?
","Introducing Bindings

From what I understand, Common Lisp has no global lexical scope,

This part is correct, but there are some ""typical"" workarounds.  There's no canonical implementation, but searching for deflexical can lead you to some implementations.

so if you want to create a global variable you have to use defvar
  instead of setq. (emphasis added)

This is incorrect.  For the most part, you don't really create variables.  You introduce bindings into an environment.  The most common way of doing this is with let or as arguments to a function.  E.g.:
(defun foo (bar)
   ;; in here, there's a variable `bar`
   )

(let ((a ...))
  ;; a is bound in here

These are lexical bindings, unless the symbol that identifies the variable in the source is declared as special, which in Common Lisp means that it's a dynamically scoped variable.  You can do special declarations like:
(defun foo (bar)
   (declare (special bar))
   ;; in here, there's a variable `bar`
   )

(let ((a ...))
  (declare (special a))
  ;; a is bound in here

Now, you can also introduce global variables with defparameter and defvar.  These globally declare a variable as special.  
Updating Bindings
In both cases, you can use setq or setf to update the value of a variable.  That is, you can use setq or setf to update the value of lexical variables as well as special variables.  So you can do:
(defparameter *cat* (make-initial-cat))

(let ((cat (some-local-cat)))
  (setf *cat* (make-instance 'cat)) ; update global/dynamic
  (setf cat (make-instance 'cat))   ; update local/lexical

setf works in both cases, so it sounds like the assignment operator you're looking for is just setf.
The issue that it sounds like you're trying to work around is that you're not supposed to use setf/setq with undeclared variables.  Indeed, that's undefined behavior.  So it sounds like you're trying to make your assignment operator automatically introduce a variable if there's not one in the surrounding environment.  You can't do this, for at least two reasons:

How would you know whether to introduce a lexical or dynamic variable?  You can't determine it from the surrounding environment, because if it was already in the surrounding environment, you wouldn't need to introduce it.
There's no way to check whether it's already declared as a local or dynamic variable.  There are some workaround alternatives that will work in some cases, but environment access isn't part of standard Common Lisp. (See a related question: Macro to detect global scope.  Some implementations do implement the CLtL2 environnments API.)

","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 The best solution would be to create a function version of where. But as a simple kludge, you can use eval
(defun select (&rest fields)
    (select-custom (eval `(where ,@fields))))

 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 I think the answer to this is macros: if you write a macro which expands to the code you want, then simply place an invocation of the macro at top-level, then the expansion of the macro will end up in the compiled file.
So:
(defmacro foo ()
  (if <compile-time-condition>
      `(setq ...)
      `(setq ...)))

(foo)

Caveat: you can only conditionalise on things you know at compile time: your example of dispatching on UID might not do what you expect.
 It is bad style to setq an unknown name.  It is assumed that you mean to create a new global special variable, then set it, but this should be made explicit by introducing these bindings first.  You do this at the top level by using defvar (or defparameter or defconstant) instead, and in lexical blocks by using let, do, multiple-value-bind or similar constructs.
 In the cond special form, there's an implicit begin after each condition, so it's ok to write several expressions, remembering that only the value of the last one will be returned. Like this:
(cond [<first condition>
       (set! global-variable value)
       ""string to return""]
      [else
       ""other return value""])

","In Common Lisp, you cannot directly check if a variable has been declared globally within a macro. However, you can create a convention where users of your macro declare global variables explicitly using `defvar` before calling the macro. Here's an example of how you might implement such a macro:

```lisp
(defmacro = (name value)
  `(let ((symbol-name ',name))
     (if (find-symbol (string symbol-name) :cl)
         (warn ",0.5832,[[0.24552184]],0.0026671037702528494,0.08244548162292538,0.15261044176706828,0.028225806451612902,0.08433734939759037
"I'm trying to car/cdr to get a particular element in a list:
(define x7 '(1 3 (5 7) 9))
; The cdr     (3 (5 7) 9)
; The cddr      ((5 7) 9)
; The caddr      (5 7)
; The cdaddr       (7)

I've been able to get that far down, however, if I then do car on the result it works, but if I add another a into the short-hand form, I get an error:
(car (cdaddr x7)) ; OK
(cadaddr x7)      ; cadaddr: unbound identifier in: cadaddr

Does the short-hand form only go up to five chars/steps, or is there something else I'm missing here?
","According to the R6RS report:

Arbitrary compositions, up to four deep, are provided. There are twenty-eight of these procedures in all.

This is identical to R5RS and the new R7RS report. There is nothing stopping an implementation from adding more of course, but using these removes portability of your program as other implementations might only provide the required 4 deep.
You can provide your own of course:
(define (cadadadr p)
  (cadar (cdadr p)))

Since Scheme does not have any reserved words this should work even if the language or the implementation decides to include these at a later time. It will simply never use the new one and use your definition.
","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 One problem is you have your < and > reversed. Assuming you want your left sub tree to be the smaller, then (< value (car tree)) should call again with the (cadr tree).
Also you should use #t instead of (#t).
 You don't want caddr, you want (if (null? (cddr ls)) ... Or just use length to find the length of the list, and compare it to the value you're interested in.
The '() that terminates a list will always be in the cdr position of a pair, so looking for it in the car position (which cad+r will do) isn't going to be productive.
 Use cadr instead of cdr. Cdr gets you the rest of the list, which is a single element list. Thus, you have to call car on that list (car (cdr list)). Since this is a common thing to want to do, they made cadr a function that evaluates out to that. 
 There is no such function as caddadr, that's why. 
* (fboundp 'caddadr)

NIL
* (fboundp 'cddadr)

T

You have just CAR, CDR, CAAR, CADR, CDAR, CDDR, CAAAR, CAADR, CADAR, CADDR, CDAAR, CDADR, CDDAR, CDDDR, CAAAAR, CAAADR, CAADAR, CAADDR, CADAAR, CADADR, CADDAR, CADDDR, CDAAAR, CDAADR, CDADAR, CDADDR, CDDAAR, CDDADR, CDDDAR and CDDDDR. See: http://clhs.lisp.se/Body/f_car_c.htm
 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
","The shorthand forms like caddr and cadadr are predefined functions in Lisp that combine car and cdr operations. They are not dynamic; you cannot add more 'a's or 'd's to create new functions beyond the predefined ones (caddr, cadddr, etc.). If you need to access an element further down in the list structure, you should use a combination of car and cdr directly, like (car (cdr (cdr (cdr x7)))). This approach allows you to specify as many steps as needed.",0.5346,[[0.2467006]],0.06216877336300304,0.26458869845714594,0.25773195876288657,0.0,0.11340206185567012
"I have the following Common Lisp Function: 
(defun test(A &rest indexes)
  (if (null (first indexes))
      A
    (test (nth (+ 1 (first indexes)) A) (rest indexes))
  )
)

As far as I know &rest parameters are treated as a list in the function body but since 
(rest indexes) also returns a list I'm stuck with nested Lists as parameters.
For example (test '(""a"" ""b"" ""c"" (""d"" ""e"")) 3 1 6 7) 
would cause indexes to be ((1 6 7))  at the second call.
Is there any way to pass my list without having this problem?
","rest is a accessor function that is paired together with first to give you the first element and the rest of the list. rest is the same as cdr.
&rest is a lambda list keyword that slurps the remaining arguments in the variable name that follows it.
You are really looking for apply. Imagine I make a function that can take 0 or more numeric parameters and add them together:
(defun add (&rest numbers)
  (apply #'+ numbers))

Apply can take more than two arguments. The first is the function to call and all but the last are extra arguments that are put in front of the last arguments element. You are guaranteed the implementation supports 50 arguments or upto the number of arguments a function can take in that particular implementation supports above 50.
(apply #'+ 1 2 '(3 4 5)) ; ==> 15

Now recursing by &rest and apply makes inefficient code so you should use higher order functions, loop macro, or make a helper:
;; higher order function
(defun fetch-indexes (a &rest indexes)
  (mapcar (lambda (i) (nth i a)) indexes))

;; loop macro
(defun fetch-indexes (a &rest indexes)
  (loop :for i :in indexes
        :collect (nth i a)))

;; helper function
(defun fetch-indexes (a &rest indexes)
  (labels ((helper (indexes)
             (if (endp indexes)
                 '()
                 (cons (nth (first indexes) a)
                       (helper (rest indexes))))))
    (helper indexes)))

;; test (works the same with all)
(fetch-indexes '(a b c d) 2 3 0 1)
; ==> (c d a b)

Using apply in recursion should be avoided, but I'll show how it's done.
(defun fetch-indexes (a &rest indexes)
  (if (endp indexes)
      '()
      (cons (nth (first indexes) a)
            (apply #'fetch-indexes a (rest indexes)))))

In your example you have nested lists. In order for that to work you would need to flatten it as well. I haven't done that so these supports one proper list of elements. 
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

",Answer not found.,0.3169,[[0.]],2.6230625762102276e-66,0.0018628912071535022,0.0,0.0,0.0
"I'm trying to create a custom reverse of list in Lisp. I'm pretty new to Lisp programming, and still struggling with syntax. This is my code so far
(defun new-union(l1 l2)
    (setq l (union l1 l2))
       (let (res) 
         (loop for x in l
           do(setq res (cons (car l) res))
           do(setq l (cdr l)))))

Here I'm taking two lists, and forming union list l. Then for reversing the list l I'm accessing element wise to append it to a new list res. Then consequently using the cons,  car and cdr to update the list. 
However, I'm getting a weird output. Can someone please suggest where I'm going wrong?
I'm aware of an inbuilt function for the same called nreverse , but I wanted to experiment to see how the Lisp interprets the data in list.
On printing res at the end, for example 
(new-union '(a b c) '(d e f))

the output for above call gives me 
(L A A A A A A A X X)

I think I'm doing the looping wrong. 
","Problems
(summary of previous comments)

Bad indentation, spaces, and names; prefer this:
(defun new-union (l1 l2)
  (setq list (union l1 l2))
  (let (reversed) 
    (loop for x in list
          do (setq res (cons (car list) reversed))
          do (setq list (cdr list)))))

Usage of SETQ on undeclared, global variables, instead of a LET
Mutation of the structure being iterated (LIST)
Not using X inside the LOOP (why define it?)
The return value is always NIL

Refactoring
(defun new-union (l1 l2)
  (let ((reverse))
    (dolist (elt (union l1 l2) reverse)
      (push elt reverse))))


Define a local reverse variable, bound to NIL by default (you could set it to '(), this is sometimes preferred).
Use DOLIST to iterate over a list and perform side-effects; the third argument is the return value; here you can put the reverse variable where we accumulate the reversed list.
For each element elt, push it in front of reverse; if you want to avoid push for learning purposes, use (setf reverse (cons elt reverse)).

Common Lisp is multi-paradigm and favors pragmatic solutions: sometimes a loop is more natural or more efficient, and there is no reason to force yourself to adopt a functional style.
Functional implementation
However, lists provide a natural inductive structure: recursive approaches may be more appropriate in some cases.
If you wanted to use a functional style to compute reverse, be aware that tail-call optimization, though commonly available, is not required by the language specification (it depends on your implementation capabilities and compiler options).
With default settings, SBCL eliminates calls in tail positions and would eliminate the risk of stack overflows with large inputs. But there are other possible ways to obtain bad algorithmic complexities (and wasteful code) if you are not careful.
The following is what I'd use to define the combination of union and reverse; in particular, I prefer to define a local function with labels to avoid calling new-union with a dummy nil parameter. Also, I iterate the list resulting from the union only once.
(defun new-union (l1 l2)
  (labels ((rev (list acc)
             (etypecase list
               (null acc)
               (cons (rev (rest list)
                          (cons (first list) acc))))))
    (rev (union l1 l2) nil)))

Trace
  0: (NEW-UNION (A B C) (D E F))
    1: (UNION (A B C) (D E F))
    1: UNION returned (C B A D E F)
    1: (REV (C B A D E F) NIL)
      2: (REV (B A D E F) (C))
        3: (REV (A D E F) (B C))
          4: (REV (D E F) (A B C))
            5: (REV (E F) (D A B C))
              6: (REV (F) (E D A B C))
                7: (REV NIL (F E D A B C))
                7: REV returned (F E D A B C)
              6: REV returned (F E D A B C)
            5: REV returned (F E D A B C)
          4: REV returned (F E D A B C)
        3: REV returned (F E D A B C)
      2: REV returned (F E D A B C)
    1: REV returned (F E D A B C)
  0: NEW-UNION returned (F E D A B C)

Remark
It is quite surprising to reverse the result of union, when the union is supposed to operate on unordered sets: the order of elements in the result do not have to reflect the ordering of list-1 or list-2 in any way. Sets are unordered collections having no duplicates; if your input lists already represent sets, as hinted by the name of the function (new-union), then it makes no sense to remove duplicates or expect the order to be meaningful. 
If, instead, the input lists represents sequences of values, then the order matters; feel free to use append or concatenate in combination with remove-duplicates, but note that the latter will remove elements in front of the list by default:
(remove-duplicates (concatenate 'list '(4 5 6) '(2 3 4)))
=> (5 6 2 3 4)

You may want to use :from-end t instead.
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 You need to change o somewhere. PUSH for example has the desired side-effect. CONS does not.
(defun r (list)
  (let ((o ()))
    (dolist (x list o)
      (push x o))))

> (r (list 1 2 3))
(3 2 1)

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You're overcomplicating it. You don't need to sort the CDRs of the sub-lists returned by SPLIT-LIST, just sort the whole lists, and merge them.
(defun MSORT (L)
  (cond ((endp L) nil)
        ((endp (cdr L)) L)
        (t
         (let* ((S (SPLIT-LIST L ))
                (L1 (car S))
                (L2 (cadr S))
                (X (MSORT L1))
                (Y (MSORT L2)))
           (MERGE-LISTS X Y)))))

","Your issue lies in how you are updating and accessing the list within the loop. The variable `l` is being updated inside the loop, but its value is not correctly propagated to subsequent iterations of the loop due to Lisp's functional nature. Here’s a corrected version of your function using `nreverse`, which is more appropriate for reversing lists in Common Lisp:\n\n```lisp\n(defun new-union (l1 l2)\n  (let ((res (union l1 l2)))\n    (nreverse res)))\n```\n\nAlternatively, you can use the `reverse` function if it is available. If you still want to manually reverse the list using a loop, here’s how you could do it:\n\n```lisp\n(defun new-union (l1 l2)\n  (let ((res ())\n        (l (union l1 l2)))\n    (loop while l do\n          (setq res (cons (car l) res))\n          (setq l (cdr l))))\n  res)\n```\nThis version correctly updates `res` with the car of `l`, and then removes the head from `l`. Note that `let` is used to initialize `res` as an empty list, and the loop structure ensures the correct behavior.\n\nYour previous concern about destructive operations like `push` or `cons` followed by `reverse` is valid. Destructive updates can be efficient but are generally avoided in Lisp due to their side effects. However, for reversing a list, `reverse` is straightforward and safe.",0.5851,[[0.58652297]],0.0437032668181621,0.1307121581458021,0.3054626532887402,0.09385474860335194,0.12040133779264213
"I'm writing an interactive function that I'd like to have remember the last argument the user supplied and use it as the default.  
(defun run-rake (param)
  (interactive ""sTask: "")
  (shell-command (format ""rake %s"" task)))

The first time the function is invoked I want it to remember the argument the user supplied so that the next time they invoke the function they can just press enter and it will use the value they supplied the previous time.
I can't seem to find this in the documentation - how do you do this in elisp?
","You can see how the compile command does this.  Bring up the help text for the compile command with C-h f compile, move the cursor over the name of the file that contains the function, then hit RETURN.  This will bring up the source file for compile.
Basically, there's a dynamic/global variable compile-command that holds the last compile command.  Emacs is a single-user, single-threaded system, so there's really no need for much more.  Also keep in mind that Elisp is a very old school Lisp, and variables have dynamic (call stack), not lexical, scope.  In this kind of system it is natural to:
(let ((compile-command ""gcc -o foo foo.c frobnicate.c""))
     ...
     (compile)
     ...)

Speaking of the compile command, have you tried using it instead of your own run-rake function?
","(caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 You have to evaluate each argument recursively, something like:
template <typename T>
auto eval(T t)
{
    return t;
}

template <typename ...Ts>
auto eval(std::tuple<Ts...> tuple)
{
    return std::apply([](auto... args){ return std::invoke(eval(args)...); }, tuple);
}

Demo.
 Use with-input-from-string. 
(with-input-from-string (s ""4 3 2"")
  (let ((a (read s))
        (b (read s))
        (c (read s)))
    (format t ""~a, ~a, ~a~%"" a b c))) 

You could also just read from a file, but reading from a string is much easier for making different test cases.
 What you're missing is a call to interactive:
(defun na ()
  ""Liten å""
  (interactive)
  (setq varlol ""å"")
  (insert varlol))

From the documentation for it:

This special form declares that a
  function is a command, and that it may
  therefore be called interactively (via
  M-x or by entering a key
  sequence bound to it). The argument
  arg-descriptor declares how to compute
  the arguments to the command when the
  command is called interactively.

 You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

","To achieve remembering the last argument and using it as a default for subsequent invocations of an interactive function in Emacs Lisp (Elisp), you can use a global variable to store this value. Here's how you can modify your function to remember the user's input and provide a default value if they press just Enter again:\n\n```elisp\n(defvar last-task \",0.5354,[[0.23738506]],0.05033859220729318,0.16181355572203895,0.28571428571428575,0.03980099502487562,0.11822660098522168
"i have a problem. How do I get all possible combinations of x booleans in Racket? (on a low language level)
I need something like that:
For x=1
(list
(list false)
(list true))
For x=2
(list
(list false false)
(list false true)
(list true false)
(list true true))
For x=3
(list
(list false false false)
(list false false true)
(list false true false)
(list false true true)
(list true false false)
(list true false true)
(list true true false)
(list true true true))
etc.
I have no idea how to do this in Racket.
Thanks you!
","Here is one way to convert a number to a list of booleans.
To generate all combinations, use it in a loop as you described.
  (map (λ (x) (eqv? x #\1)) 
       (string->list (number->string 12345 2)))

Replace 12345 with any number.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 The reason is that you quote the list:
> (= 'foo (first '(foo)))
true
> (= 'foo (first (list foo)))
false
> (= foo (first (list foo)))
true

 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
","In Lisp (including Racket), you can generate all possible combinations of x booleans by using recursion or iteration. Here is a simple recursive function that generates these combinations:\n\n```\n(define (generate-combinations n)\n  (if (= n 0)\n      '(())\n      (let ((prev-combs (generate-combinations (- n 1))))\n        (append (map (lambda (comb) (cons #f comb)) prev-combs)\n                (map (lambda (comb) (cons #t comb)) prev-combs)))))\n```\n\nThis function works as follows:\n- If `n` is 0, it returns a list containing an empty list.\n- Otherwise, it recursively generates combinations for `n-1`, then for each combination, it creates two new combinations: one with `#f` prepended and another with `#t` prepended. Finally, it combines these lists using `append`. This approach avoids the performance issues associated with functions like `append` when used in loops or on long lists.",0.5811,[[0.18960037]],0.09324695964948011,0.36149236212849445,0.24309392265193372,0.0335195530726257,0.12154696132596686
"I am familiar with how to set elements in a 2D array, which can be done using the following statement.
(setf (aref array2D 0 0) 3)

However, I am not familiar how to set elements in a list of lists, such as the following input: '((1) (2) (2) (1)). I can't use aref, since it only works on arrays.
","As mentioned, while aref works on arrays, elt works on sequences which can be:

an ordered collection of elements
a vector or a list.

* (setf test-list '((1) (2) (2) (1)))
((1) (2) (2) (1))
* (setf (elt test-list 2) 'hi)
HI
* test-list
((1) (2) HI (1))


You can indeed use variables in place of fixed offsets:
* (setf test-list '((1) (2) (2) (1)))
((1) (2) (2) (1))
* (setf offset 2)
2
* (setf (elt test-list offset) 'hi)
HI
* test-list
((1) (2) HI (1))

","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Each of the inputs is building a different output, so they're printed differently. Notice that the following expressions are equivalent:
(cons 1 (cons 2 3))
; (1 2 . 3)

(list 1 (cons 2 3))
(cons 1 (cons (cons 2 3) '()))
; (1 (2 . 3))

(cons 1 (list 2 3))
(cons 1 (cons 2 (cons 3 '())))
; (1 2 3)

(list 1 (list 2 3))
(cons 1 (cons (cons 2 (cons 3 '())) '()))
; (1 (2 3))

Remember: a list is defined if and only if the cdr part of each cons is also a cons cell, or an empty list.
 If your implementation has SRFI 1 available, there is lset= to achieve what you want:
Set operations on lists
 Because you are using an array of lists how about:
(defun element-of-matrix (matrix i j)
  (nth j (aref matrix i)))

 The function list? checks wether a list is proper or not:
(list? '(1 2 3))   ; ==> #t
(list? '(1 2 . 3)) ; ==> #f

Use this in your function to return either of the two lists in your specification. 
EDIT 
Because of the strange requirement that (a . b) would not be considered a improper list I think you should add an extra term in you cond that differentiate the two improper lists of one pair in chain and more than one pair in chain by using pair? in the cdr. (pair? (cdr '(a . b)) ; ==> #f and (pair? (cdr '(a b . c)) ; ==> #t
 The lexicographical (not lexicological) order can be obtained through the following function that checks if the list a precedes the list b in lexicographical order:
(defun lex<= (a b)
  (or (null a)
      (and b 
           (string<= (car a) (car b))
           (lex<= (cdr a) (cdr b)))))

so, you could produce all the combinations, like in the answer of coredump, and then sort them with (sort result #'lex<=).
","To set elements in a list of lists, you cannot use `aref` because it is specific to arrays. Instead, you can use functions like `set-car!` and `set-cdr!` for modifying the structure of cons cells directly. For example, if you want to change the first element of the second sublist from 2 to 5, you would do something like this in Scheme Lisp (Lisp dialect):

```lisp
(set-car! (cadr list-of-lists) 5)
```

Here, `cadr` retrieves the second sublist, and `set-car!` sets the car (first element) of that sublist. The equivalent in Common Lisp would use `setf` with `car`:

```lisp
(setf (car (nth 1 list-of-lists)) 5)
```

This changes the first element of the second sublist to 5.",0.5607,[[0.13440329]],0.05862436126907669,0.2541350653028832,0.1932367149758454,0.01951219512195122,0.1352657004830918
"I wrote a function for recursive subtraction in lisp, but when i load it and run the function with numbers for example ( subtract 4 3 ) the output is -3 which I do not understand why.
(defun subtract (x y)
  (if (eq y 0) 
    x
    (- 1 (subtract x (- y 1) ) ) ) )

","Here's a fixed version of your code:
(defun subtract (x y)
  (if (zerop y) 
    x
    (subtract (1- x) (1- y))))

Notice that in the recursive call we subtract 1 from both x (to actually decrement the number) and y (to get it closer to the base case, 0).
","Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 (second expr) is the list (* 3 x) which is not a number, but the function sqrt demands a number for its argument. Since you say you want to do symbolic differentiation, you probably should return a list with the symbol sqrt in it, rather than calling the function.
 I just tested your three functions and it gave me the correct output, so perhaps your issue isn't where you think it is.
(initBoard '(4 5 15 10 14 11 1 8 9 16 6 3 7 2 12 13))

=> ((4 5 15 10) (14 11 1 8) (9 16 6 3) (7 2 12 13))
","The issue with your `subtract` function lies in its recursive call. Specifically, the recursive call should be `(subtract (+ x 1) (- y 1))` instead of `(- 1 (subtract x (- y 1)))`. The current implementation incorrectly decrements `x` by 1 at each step rather than incrementing it. Here is the corrected version of your function:

```lisp
(defun subtract (x y)
  (if (eq y 0) 
      x
      (subtract (+ x 1) (- y 1))))
```

This will correctly perform subtraction through recursion by incrementing `x` until `y` reaches 0.",0.698,[[0.38577796]],0.2709160588098695,0.42968195623172767,0.4461538461538461,0.17187499999999997,0.2923076923076923
"I read in the book 'On Lisp' that one should avoid excessive use of cons in the body of expanded macros.  Why is cons considered to be an inefficient operation?  Does Lisp not do structure sharing with the cons cells?
","You need to understand the jargon first.
CONS is a primitive operation to create a fresh cons cell.
Consing means allocation of memory on the heap in general, not only cons cells: Consing of numbers, Consing of arrays, Consing of CLOS objects, ...
The definition from the 'memory management glossary' says:

cons(1) In Lisp, cons is a primitive operation creating a list element (from English ""CONStruct""). By extension, a cons is the element created.
cons(2) (for full details, see allocate) Allocation is the process
of assigning resources. When
requested to by the program, an
application memory manager or
allocator allocates a block of
memory(2) for the program to store
its data in. Allocation is also
known as consing, from cons(1).

So, Graham uses the second meaning.
If Graham says 'Avoid consing especially. A utility which conses unnecessarily can ruin the performance of an otherwise efficient program.' - that means: avoid unnecessary memory allocation on the heap. But this can be true for any code - macro, function, whatever.
That was particular true when computers had less memory and Garbage Collection was more costly (especially when it needed to scan swapped out memory in virtual memory systems, where the physical memory is smaller than the virtual memory).
Today consing is less an issue, but can still be relevant.
Take for example a the function READ-LINE, it reads a line from a stream and 'conses' a new string. Note that the string is not built out of conses, but it is a vector. We mean here 'allocates a string on the heap'. If you have a large file with lots of lines, it can be faster to have a routine that gets a buffer and which fills the buffer with the line characters (there are vectors in Common Lisp with a fill pointer for this). That way the line buffer is just one object and can potentially be reused for calls to this line reading function.
See this example in the Allegro CL documentation: Some techniques for reducing consing when processing very large text files.
","IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 I think, they should have used macros for the sake of example solely... because constructing the lambda around cl-ppcre: calls can indeed be completed during the reading phase, provided that the reader macro doesn't make use of any other form than the string, that follows the macro character. In general, the golden rule states, that macros should be avoided in cases when an ordinary function can be used. Sometimes (for example, when it's necessary to control the evaluation of the arguments) macros are inevitable, but it this particular case function is sufficient.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 In ANSI Common Lisp:
(sort (copy-list '((a 22) (b 2) (c 5)))  #'< :key #'second)
-> ((B 2) (C 5) (A 22))

The copy-list is there because sort clobbers the input list. We need that because our input list is a literal, but even if it isn't, sometimes you don't want to scramble the original object that you wish to sort.
 You have three options:

Rewrite the algorithm to be tail-recursive or, equivalently, iterative
Change the algorithm all together
Increase the lisp's stack size

","The function `cons` is considered less efficient than other operations because it always creates a new cons cell, which involves heap allocation and memory management. In Lisp, structure sharing can indeed occur with cons cells when they are shared between multiple data structures, but this sharing does not eliminate the cost of creating a new cons cell each time `cons` is called in a loop or within an iterative process. The creation of these new cells can lead to increased garbage collection activity and higher memory usage. Therefore, using `cons` in tight loops or recursive functions without careful consideration can impact performance.",0.5388,[[0.43370487]],0.01981377167256717,0.12241720917067647,0.2639821029082774,0.05393258426966291,0.1342281879194631
"My Common Lisp program writes out an HTML file.  I then want to launch this file in the user's default browser.
Is there a way of doing this in Common Lisp?  Moreover, is there an OS-independent way of doing this?
","This depends on the Common Lisp implementation and possibly the platform it runs on (Windows, Mac, Linux, ...).
LispWorks provides the function SYS:OPEN-URL. See http://www.lispworks.com/documentation/lw60/LW/html/lw-1369.htm#pgfId-1219832
(sys:open-url ""http://www.foo.com/"")

One certainly can also use a file URL.
","To use open files, you must save the return value of open and uses it as the second argument to princ. You must also use that same return value as an argument to close.
This is usually done with the convenience macro with-open-file.
The files chapter of Practical Common Lisp shows how to use these and other functions and macros.
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 The reason the ANSI CL standard does not specify the algorithmic complexity of 
library functions is that it is not its job. The standard describes the behavior, and leaves performance to the implementation-specific docs. 
It was assumed that the best theoretical performance will be provided by all implementations (otherwise no one would use it).
To answer your specific question, gethash is O(1) in all implementations.
 Another simple way is to have Lisp running a HTTP server and contact Lisp from the outside via HTTP requests.
 
use WITH-OPEN-FILE instead of OPEN
use READ instead of READ-LINE

Example:
CL-USER 11 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (read in)))
(1 2 3)

CL-USER 12 > (let ((*read-eval* nil))
               (with-open-file (in ""/tmp/test.data"")
                 (describe (read in))))

(1 2 3) is a LIST
0      1
1      2
2      3

","To launch an HTML file in the user's default browser from a Common Lisp program, you can use platform-specific functions or third-party libraries that handle cross-platform operations. One approach is to use the `uiop` (Unix I/O Processing) library which provides portable mechanisms for interacting with the operating system. Here’s how you might do it using `subprocess:*default-subprocess*` on Unix-like systems and a similar mechanism on Windows or other platforms.

For example, in an environment like SBCL with the `sb-ext:run-program` function, you can launch the default web browser by passing the path to your HTML file:

```lisp
(use-package :uiop)

(defun open-in-browser (file-path)
  #+sbcl
  (sb-ext:run-program ",0.5452,[[0.20442295]],0.06445991376397929,0.2693125442948264,0.24137931034482762,0.023255813953488372,0.13793103448275862
"I need to make a named function, which makes a new list from the 3rd item from three master lists. I made this code
    (defun func (nth n))
    (lambda (l1 l2 l3) '(H G (U J) (T R)) '(2 1 (+ 4 5)) '(TYPE CHAR REAL (H G)))
    (write (func (lambda (l1 l2 l3) '(H G (U J) (T R)) '(2 1 (+ 4 5)) '(TYPE CHAR REAL (H G))) 2))


but it returns NIL. What do I do wrong?
","You need to indent and format your code. Otherwise it's an unreadable blob of characters.
Here is what you have:
Your function func takes two arguments and does nothing. It always returns NIL.
Then there is a lambda expression which takes three arguments. It uses none of them. It has three body expressions. The first two are not used and the third is being returned.
The third expression calls the function func, which always returns NIL. WRITE then prints this NIL.
Your code, but formatted readably for humans, looks like this:
(defun func (nth n)
  ; no functionality, does nothing and returns NIL
  )

(lambda (l1 l2 l3)
   '(H G (U J) (T R))
   '(2 1 (+ 4 5))
   '(TYPE CHAR REAL (H G)))

(write (func (lambda (l1 l2 l3)
               '(H G (U J) (T R))
               '(2 1 (+ 4 5))
               '(TYPE CHAR REAL (H G)))
             2))

Hint: you would need to write actual functionality.
","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
","The issue with your code is that you are defining a function `func` but not actually using its parameters inside the function body. The lambda expression inside `func` is not being evaluated with the provided lists. You should modify your function to correctly use the passed parameters. Here's an example of how you can fix it:\n\n```lisp\n(defun func (nth n l1 l2 l3)\n  (let ((item1 (nth nth l1))\n        (item2 (nth nth l2))\n        (item3 (nth nth l3)))\n    `(H G ,item1 ,item2 ,item3)))\n\n(write (func 2 '(U J) '(1 (+ 4 5)) '(\n  TYPE CHAR REAL (H G))))\n```\nIn this corrected version, the function `func` takes `nth`, `l1`, `l2`, and `l3` as arguments. It then extracts the nth item from each list using `(nth nth l1)`, `(nth nth l2)`, and `(nth nth l3)`. Finally, it returns a new list with these items.",0.6242,[[0.40202248]],0.27498677344054673,0.3723011541800533,0.45544554455445546,0.15946843853820597,0.2376237623762376
"There is a defconstant statement:
(defconstant *contant2* '((Allan 4) (Zols 5) (Milo 2) (Judh 0)))

I want to take separated from this constant the name and the value associated with the name. How can I do that?
I need to achieve this goal:

Give taste scores: ((name-1 score-1) ... (name-n score-n)) as an argument, LISP functions which avare score and other which generate word scores (9-10 is VeryGood, 7-8 is Good).

I appreciate any help! Thanks.
","To answer your direct question:
? (mapcar #'car *cookie-scores*)
(JOHN MARY MIKE JANE)
? (mapcar #'cadr *cookie-scores*)
(8 9 1 0)

In a loop, you can use loop's destructuring:
for (name val) in

Other options are available; here's 2 example implementations of the required functions that I will leave uncommented; please ask questions, or show us your code.
(defun average-score (lst)
  (/ (reduce #'+ lst :key #'cadr) (length lst))))

? (average-score *cookie-scores*)
9/2

and 
(defun word-scores (lst)
  (loop 
    for (name val) in lst
    collect (list name
                  (cond
                   ((> val 8) 'Excellent)
                   ((> val 6) 'Tasty)
                   ((> val 0) 'Terrible)
                   (t         'Garbage)))))

? (word-scores *cookie-scores*)
((JOHN TASTY) (MARY EXCELLENT) (MIKE TERRIBLE) (JANE GARBAGE))

","You're doing all right, just remove the print statements, for example replace (print ""Capricorn"") with ""Capricorn"", and the function will work. 
You also don't need the (remove nil? ...)
 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 Use --eval or -e option.
sbcl --eval '(write-line ""Hello, World!"")', it'll eval your code and keep you inside REPL.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 You moslty already answered your own question, the difference is as you described. :some-symbol will be in :KEYWORD package, and 'SOME-SYMBOL will be in your current package CL-USER by default. In loop macro it's just a matter of taste. Some people prefer to use :for notation to get better syntax highlighting in their text editor, for example.
",You can achieve this by using the CAR and CDR functions to extract names and scores from the constant. Here's how you could define a function that takes a list of (name score) pairs and returns them as separate lists for names and scores:\n\n```lisp\n(defun extract-names-and-scores (data)\n  (let ((names '())\n        (scores '()))\n    (dolist (pair data)\n      (push (car pair) names)\n      (push (cadr pair) scores))\n    (values names scores)))\n\n;; Example usage:\n(let ((data '((Allan 4) (Zols 5) (Milo 2) (Judh 0))))\n  (multiple-value-bind (names scores) (extract-names-and-scores data)\n    (format t \,0.5957,[[0.20290206]],0.14174465561944852,0.3212804582600994,0.28959276018099545,0.03652968036529681,0.15384615384615383
"May be, it is a stupid question, but it may help many of newbies. How do I add a key-value pair to the map?
I mean something like:
(defn init-item [v item]
  (let [{:keys [id value]} item]
    (-> v
        (assoc :{ID_AS_A_KEY} value))))

And I get:
(init-item {} {:id ""123456789"" :value [:name ""King"" :surname ""Leonid""]})
user=> {:123456789 [:name ""King"" :surname ""Leonid""]}

","I think this is what you meant to do:
  (defn init-item
    [dest-map item]
    (let [item-id-str (:id item)
          item-val    (:value item)
          item-id-kw  (keyword item-id-str)]
      (assoc dest-map item-id-kw item-val)))

  (let [all-items {:a 1 :b 2 :c 3}
        item-1    {:id    ""123456789""
                   :value [:name ""King"" :surname ""Leonid""]}]

(init-item all-items item-1)  
  ;=>  {:a 1, :b 2, :c 3, :123456789 [:name ""King"" :surname ""Leonid""]}

Clojure has functions name, symbol, and keyword to convert between strings and symbols/keywords.  Since you already have the ID as a string, you just need to call keyword to convert it.
Be sure to always keep a browser tab open to The Clojure CheatSheet.
","Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
 I am not a smartparens user but I found the answer from its wiki: 
You can bind ) to sp-up-sexp command: 
(define-key smartparens-mode-map "")"" #'sp-up-sexp) 

 You are looking for the procedure identity:
(count identity '(#t #f #t #t #f))
=> 3

(count identity '(1 2 #t #f #f 9))
=> 4

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
",Answer not found.,0.321,[[0.]],4.073947955292363e-30,0.00563063063063063,0.0,0.0,0.0
"I'm stucked on my next problem.
I read a line from a textfile containing like: 
((""ITEM"" ""05"") (""NUMBER"" ""1"") (""DESCRIPTION"" ""*RECHTE INSTEEKKOP. 1/4\""-8MM"") (""ARTICLENUMBER"" ""S110010000104""))

In Lisp this is a List and for retrieving the value of eg ITEM in Lisp: 
(cadr (assoc ""ITEM"" str))

This gives 05
How can I achieve this simply in C#?
","You could use Regex to parse the value and then fetch the result. For example,
var valueCollection = Regex.Matches(datastring,@""\(""""(?<Key>.+?(?=""""))""""\s+""""(?<Value>.+?(?=""""))""""\)"")
                                 .Cast<Match>()
                                .Select(x=>new {Key = x.Groups[""Key""].Value,Value = x.Groups[""Value""].Value,});


This would provide you with collection as the following 

You could now fetch the Value where Key is equal to ""ITEM"" using Linq.
var itemValue = valueCollection.First(x=>x.Key==""ITEM"").Value;

Alternatively, you could convert the string to a Dictionary as
var valueCollection = Regex.Matches(datastring,@""\(""""(?<Key>.+?(?=""""))""""\s+""""(?<Value>.+?(?=""""))""""\)"")
                                 .Cast<Match>()
                                 .ToDictionary(x=>x.Groups[""Key""].Value,y=>y.Groups[""Value""].Value);


You could now parse the required ITEM value as
var itemValue = valueCollection[""ITEM""];

Update Based on comment
In case you expect empty values, you could use the following regex pattern.
@""\(""""(?<Key>.+?(?=""""))""""\s+""""(?<Value>.*?(?=""""))""""\)""

","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 This seems like an odd thing to want to do, but you could do it by advising the function, I suppose.  Example:
(defadvice * (around ultimate-answer activate)
  (if (and (eq major-mode 'html-mode) (equal (ad-get-args 0) '(6 9)))
      (setq ad-return-value 42)
    ad-do-it))

After evaluating this advice, the * function will return 42 if it is given the two arguments 6 and 9, but only in html-mode.
 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
","In C#, you can achieve similar functionality using the `Dictionary` or `List` of key-value pairs. Here's how you can do it:\n\nAssuming `str` is your string containing the list-like structure, first parse it into a dictionary:\n\n```csharp\nstring str = @",0.4936,[[0.23540746]],0.0010658396066415602,0.05850091407678244,0.16759776536312848,0.03389830508474576,0.11173184357541899
"I am trying to add (not(X)) to all my items X in a sequence.
For example:
Convert (a b) to
( (not(a)) (not(b)) )
When I use (map (fn [x] (not(x))) mylist), it tries to evaluate the nots and return booleans.
When I use (map (fn [x] '(not(x))) mylist), it just returns a list of (not(x)) without actually putting in my list's variables.
(a b) --> ( (not(a)) (not(b)) ) ? Thanks!
","user=> (map (fn [x] (list 'not (list x))) '(a b))
((not (a)) (not (b)))

The ' single quote operator is convenient for making lists because it prevents evaluation, but it isn't usable in your case because you have content inside the resulting list that you want to be evaluated.
Another option would have been ` AKA quasiquote, which allows selective unquoting, but also namespaces symbols (once again, not useful in your case, where you want the symbol used literally).
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

","To achieve the desired transformation where each item X in a sequence is wrapped in a list with its negation, you can use the following approach in Lisp:\n\n`(map (lambda (x) `(not ,x)) '(a b))`\n\nThis will correctly return `((not a) (not b))`. The backquote and comma syntax are used to properly construct the nested list structure.",0.5858,[[0.32808637]],0.16941586594479105,0.2900416167453023,0.33333333333333337,0.08823529411764705,0.18840579710144928
"I can write a function like this
(define (bool-num x) (if x 1 0))
(define (cnt-true lst)
  (foldl + 0 (map bool-num lst)))

But I found is not elegant, because racket has a count function and false?, but there's no true?
So I can count the number of false element:
(count false? lst)

Anything I miss?
","You are looking for the procedure identity:
(count identity '(#t #f #t #t #f))
=> 3

(count identity '(1 2 #t #f #f 9))
=> 4

","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 To call the function count repeatedly with each item from a list (A B C), every time counting matching items the same sequence mylist:
(mapcar (lambda (x) (count x mylist)) '(A B C))

 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
","You're on the right track! Racket (and Scheme) indeed provide a `count` function that can be used with a predicate. Your example of counting false elements using `(count false? lst)` is correct and quite elegant. If you want to count true elements, you can use the `bool-num` function you defined or define a similar function for truth values, like this: `(define (true? x) (if x 1 0))`. Then you can count true elements with `(count true? lst)`. This approach is both clear and leverages Racket's built-in functions effectively.",0.4753,[[0.18818798]],0.024814924878701333,0.21860986547085204,0.10344827586206896,0.0,0.08620689655172414
"I want mylist to have the same functionality as list. In most Lisps (I'm on Emacs Lisp) I can simply write
(defalias 'mylist 'list)

But if I want to write my own I can write
(defun mylist (&rest x)
    (car (list x)))

which has the same functionality. But then I got this by experimenting. First, I had this code
(defun mylist (&rest x)
        (list x))

which produced a list in a list. I wasn't sure why, but the simple solution was to just put (list x) inside a car and call it good. But I'd like to know why I get a list inside a list when I don't use the car trick. What am I missing?
","
(defun my-list (&rest x) …

The &rest parameter means that all remaining arguments are put into a list that is bound to this parameter.  X then holds the list that you want.  You're done.
(defun my-list (&rest x)
  x)

","Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 In your code, change this part:
(append (car L) x)

To this:
(append (car L) (list x))

It wasn't working before because append should receive two lists as parameters, not a list and an element.
 I don't understand why your function takes 2 arguments when it's going to rearrange one list.
Your t case is almost correct, but you've practically turned it inside out - it should be
(cons (car x) (Func1 (cdr x)))

That is, a list where the car is the same as in the input, and the cdr is the result of flattening the cdr of the input.
The listp case looks like it's suffering from a similar form of ""inside-out-ness"".
Apart from the inexplicable y you have all the right bits but in the wrong order, except that it needs two Func1 calls - one for the car and one for the cdr.  
I'll leave the rearrangement of the bits in that case as an exercise.
 The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 In Lisp, a linked list element is called a CONS. It is a data structure with two elements, called the CAR and the CDR for historical reasons. (Some Common Lisp programmers prefer to refer to them using the FIRST and REST functions, while others like CAR and CDR because they fit well with the precomposed versions such as (CADR x) ≡ (CAR (CDR x)).
The joke is a parody of the bumper stickers you sometimes see on beat-up old cars saying ""My other car is a Porsche/BMW/etc.""
My response to this joke has always been ""My other CAR is a CADR. CDR isn't a CAR at all.""
 You have a little bug in your code, try this in the EVALPlus procedure:
(+ (car argList) (car (cdr argList)))

Remember that cdr retrieves the next list, not the next element. After obtaining the next list, we call car to obtain its first element.
","When you define your function as (defun mylist (&rest x) (list x)), it creates a list containing one element: the entire argument list x. The rest operator (&rest) collects all arguments into a list, and passing this list directly to (list x) results in another list that contains the original list as its only element. By using (car (list x)), you extract the first element of this new list, which is the original argument list x itself. This is why you get a 'list inside a list' when not using (car). The correct way to create a list from multiple arguments without wrapping them in another list is to directly use (cons x nil) for each element and combine them or use (apply #'list x) which will properly handle the rest arguments as separate elements.",0.5728,[[0.500454]],0.10634456382390872,0.3261954183202556,0.2727272727272727,0.06896551724137931,0.21590909090909088
"I am learning clojure now, I wrote a file like this:
;; File ./mycode/myvoc.clj

(ns mycode.myvoc
    (:use 'clojure.java.io)
    (:import (java.io.File)))

; more code here...

this file resides in ./mycode/, when I run REPL, I wanna use the function in myvoc.clj, like this:
user=> (use 'mycode.myvoc)
java.lang.Exception: lib names inside prefix lists must not contain periods (myv
oc.clj:1)

I don't know why. if I change myvoc.clj as :
(ns mycode.myvoc)
;    (:use 'clojure.java.io)
;    (:import (java.io.File)))

It'll be ok but just report no ""reader in this context"" for I commented the import part.
Could somebody fix this? I alse use require but get the same kind of error.
","You need to remove the quote from your :use clause:
(ns mycode.myvoc
  (:use clojure.java.io)  ; note no '
  (:import java.io.File)) ; extra parens removed here; they do no harm,
                          ; though

'clojure.java.io is shorthand for (quote clojure.java.io), so your original :use clause was
(:use (quote clojure.java.io))

This looks as if you were trying to :use a namespace with a prefix of quote and final segment clojure.java.io. The dots in the latter are the direct cause of the error from the point of view of ns.
Incidentally, it's much more usual to (:require [clojure.java.io :as io]) and then say io/file, io/reader etc. than it is to pull in the entire namespace.
Finally, just to be clear, the quote is necessary when using the function use (like in your (use 'mycode.myvoc) call), as opposed to a :use clause in a ns declaration.
","You've messed up the key vector, and I believe you have to use a single function name, with no arguments, to make this work:
(global-set-key ""\C-xO"" 'my-other-window)

(defun my-other-window ()
  (interactive)
  (other-window -1)
  )

See the manual for more details:
(info ""(emacs)Init Rebinding"")

 You can do e.g.
(require '[clojure.contrib.io :as io])

(io/with-in-reader (io/file ""foo.txt"") (read))
; => (1 2 3)

Note that you'll likely want to rebind *read-eval* to false first. Also note that the above works with current contrib HEAD (and will almost certainly work in 1.2 when it's released); for Clojure 1.1, the same functionality is available in the clojure.contrib.duck-streams and clojure.contrib.java-utils namespaces.
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 CL-USER> (mapcar #'caddr *jack*)
(FRUIT FRUIT AGENT AGENT)

EDIT: If you want to practise your recursive approach, try:
(defun attempt (list-of-lists)
    (if (null list-of-lists) nil
        (cons (third (car list-of-lists))
              (attempt (cdr list-of-lists)))))

EDIT2: Tail-recursively:
(defun attempt-tail (list-of-lists)
    (labels ((iter (rest ans)
               (if (null rest) (nreverse ans)
                   (iter (cdr rest) (push (third (car rest)) ans)))))
      (iter list-of-lists nil)))

EDIT3: While I'm at it, here's the loop version:
(loop for list in *jack* collect (third list))

 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 The code as you pasted is fine.
The behavior you describe is indicative of lisp choking on a non-ascii character.
Please copy the code into Emacs and find the offending character using, e.g., 
(defun my-search-for-non-acsii ()
  (interactive)
  (skip-chars-forward ""\000-\177""))

","The issue you're encountering is due to the way namespaces and require/use statements are handled in Clojure. When using `use`, all namespaces specified must be valid without periods for the symbols they contain. In your case, changing the namespace declaration to just `(ns mycode.myvoc)` allows you to use `:use` or `:require` with qualified names. However, if you want to include other namespaces within your own namespace, you should do so using `:require` or `:import`, but these shouldn't contain periods in their names directly under the `ns` declaration. Here's how you can adjust your code:\n\n```clojure\n(ns mycode.myvoc\n  (:require [clojure.java.io :as io]\n            [java.io.File]))\n\n; more code here...\n```\n\nThis way, you're specifying the dependencies correctly and avoiding the error related to periods in namespace names.",0.6233,[[0.53917832]],0.23430680633596374,0.30840467444599906,0.44444444444444436,0.10847457627118644,0.1952861952861953
"I'm passing the name of a function for use in another method. 
(defn mapper [m function]
  (cond
   (= '() m) '()
   true (cons (function (first m))
            (mapper (rest m) function))))

(println (mapper '((blue red)(green red)(white red)) #'first))

Is there a more idiomatic way to do this in clojure?
","
Prefer vectors to lists.  You don't have to quote a vector most of the time, and it has better performance for a lot of things, like random access.  Lists are used much more rarely in Clojure than in other Lisps.
Prefer keywords to quoted symbols.  Keywords stand out as ""constant strings"" or enumerated values.  Keywords in Clojure can belong to a namespace, so they have all the advantages of symbols.  And again, there's no need to quote keywords, which is nice.  Quoted symbols are used pretty rarely in Clojure, unless you're writing macros.
#'first is the var called ""first""; first is the value of the var called ""first"", i.e. the fn.  In this case (#'first foo) and (first foo) give the same answer, but #'first does an extra dereference every time you call it.  So don't do this unless you want that dereference to happen over and over.  There's usually no need to use #'.
The built-in map is lazy, whereas yours isn't. The built-in map takes advantage of chunked seqs for better performance, whereas yours doesn't.  Idiomatic code doesn't have to be lazy or use chunked seqs, but keep in mind that the builtins have some of this magic going on.  So it's good to take advantage.
Rather than (= '() x), the idiomatic test for an empty seq is (seq x), which returns nil if x is empty.  Note that in Clojure, (= '() nil) is false.
If you do ever need to use the empty list (which you should rarely need to do), you don't have to quote it.  Just use ().
Built-in map takes the function argument first because it accepts multiple collection arguments.  When a function takes multiple arguments, those arguments have to go last in the argument list.  I think it reads better the other way too: ""(map f coll): map this function across this collection"".
There's no need to use cond if you only have two options.  You can use if instead.  And if one of the branches in your if returns nil, you can use when.  It's nice to use when and if when appropriate, because they signal your intentions to the reader immediately, whereas cond could do anything and forces the reader to read more.

Rafał Dowgird's version is idiomatic, except I'd flip the order of arguments around.  And I'd call it like this:
user> (mapper first [[:blue :red] [:green :red] [:white :red]])
(:blue :green :white)

","Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 An alternate approach:
(require 'cl)

(defun is-useless-buffer (buffer)
  (let ((name (buffer-name buffer)))
    (and (= ?* (aref name 0))
         (not (string-match ""^\\*shell\\*"" name)))))

(defun kill-useless-buffers ()
  (interactive)
  (loop for buffer being the buffers
        do (and (is-useless-buffer buffer) (kill-buffer buffer))))

 If the file contents have been read in, then, assuming there have been no errors thrown, all the forms of the contents have been executed. If one of those is a DEFUN form, then the function will have been defined.
To be precise, examine the LOAD definition in the HyperSpec.
 You need another comma before A in the nested backquote, so it expands to the value of the variable outside the outside the outer backquote. And then it needs to be quoted to keep from evaluating that as a variable. So it becomes ,',A
(defmacro define-access (F A)
  (let ((X (gensym))
        (Y (gensym)))
    `(progn
       (defun ,F (,X)
         (,A ,X))
       (defsetf ,F (,X) (,Y)
         `(setf (,',A ,,X) ,,Y)))))

DEMO
 Your implementation scans the list twice, so it is suboptimal.
I don't think you can write what you need without an explicit loop (or, equivalently, recursion):
(defun pop-from-list (object list &key (key #'identity) (test #'eql) kept)
  ""Like `remove', but return the object removed as the second value.""
  (let ((1st (car list)))
    (if (funcall test object 1st)
        (values (revappend kept (rest list))
                1st)
        (pop-from-list object (rest list) :key key :test test
                       :kept (cons 1st kept)))))

Now you can define your function like this:
(defun find-remove-third (x)
  (multiple-value-bind (list object)
      (pop-from-list x *test-list* :key #'third)
    (setq *test-list* list)
    object))

","In Clojure, your provided `mapper` function is quite functional and idiomatic. However, you can make it more concise using higher-order functions like `map`. Here's a more concise version:\n\n```\nclojure\n(defn mapper [m f] (map f m))\n```\n\nYou can then use this function as follows:\n\n```\nclojure\n(println (mapper '((blue red) (green red) (white red)) first))\n```\nThis leverages `map` to apply the given function `f` to each element of the collection `m`, which is a common and idiomatic way to handle such transformations in Clojure.",0.5409,[[0.43283059]],0.010043831396496705,0.09001546277888225,0.19921875,0.04705882352941177,0.0859375
"I'm still having problems to really grasp case. I have understood that you provide symbols which are internally compared using eq, but I'm not sure if I have gotten one thing correctly:
I have seen that I can write, e.g.:
(case n
  (23 'foo)
  (42 'bar)
  (otherwise 'something-else))

I can also write:
(case n
  ((23 42) 'foo-or-bar)
  (otherwise 'something-else))

So am I right that if I specify a list that case then checks whether the variable n matches one of the list's elements, but if I specify a single value, then case directly matches this value?
In other words: Is it okay to use the non-list version if I only have a single value?
","Keys are conceptually lists of keys
Conceptually each clause uses a list of keys. The test-key will be compared against each key in the keylist.
The key list (foo bar baz) is exactly (foo bar baz). 
The key foo is thought to denote (foo). It helps to write code shorter.
(case x
  (foo       41)
  ((bar baz) 42)))

The exception of T and OTHERWISE
Note that otherwise and (otherwise), t and (t) are exceptions. You need to write (otherwise) if you want to match the symbol:
(case 'otherwise
  ((otherwise) 'the-symbol-otherwise)
  (otherwise   'the-otherwise-clause))

EQ vs. EQL
Also note that most comparisons in Common Lisp are done by default with EQL, not EQ. EQ is pointer equality, EQL also works for numbers and characters.
","The problem is that I'm using parentheses ('(' and ')'), rather than square brackets ('[' and ']'), for the arguments list.
It should start out like this:
(defn match [x y &optional binds]

(I found the answer in Programming Clojure by Stuart Halloway.)
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 The problem is that you're quoting the list and therefore none of its elements will be evaluated, but will merely be passed in as literal symbols. If you'd like to evaluate certain elements of the list while passing others in as literals, the most convenient form is to use the backquote, i.e.:
(member 9 `(1 2 3 4 ,(sq 3)))

Backquote behaves identically to normal quote, except that list elements preceded by a comma are evaluated, with the result of the evaluation substituted back into the list.
Alternatively, you could use the list function, which evaluates its parameters (unless explicitly quoted):
(member 9 (list 1 2 3 4 (sq 3)))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 I suggest you use (not (equal? foo bar)) if not equals works.  Please note that there may be faster comparators for your situiation such as eq?
","Yes, you are correct. In Common Lisp's `case` construct, when you specify a single value without enclosing it in parentheses, `case` directly matches that value against the variable `n`. If you want to match any of multiple values, you should enclose them in a list with parentheses, like this: ((23 42) 'foo-or-bar). This way, `case` checks if `n` is equal to either 23 or 42. So, it's perfectly fine and often more readable to use the non-list version when you only have a single value.",0.5248,[[0.25789936]],0.10877369922121219,0.22775810429730342,0.2962962962962962,0.06542056074766356,0.1388888888888889
"I recently asked a question about sbcl for which a response mentioned two functions of which I wasn't aware: #'sb-ext:string-to-octets and #'sb-ext:octets-to-string. In addition to answering my question, this also taught me that I should browse through the external symbols of package sb-ext to see what else might be of use.
My question (sbcl-related) is this: other than browsing through the external symbols of package sb-ext, is there some other manual which describes package sb-ext, and other additions (I'm trying to avoid the word ""extension"" because it's a specific technical term) to sbcl? #'sb-ext:string-to-octets and #'sb-ext:octets-to-string, for example, are not discussed in the sbcl manual.
","As pointed in one answer in the other question by @svante, for things like that I prefer to use another libray for postabiliyt and usually well documented like babel. 
Normally for checking doc in common lisp if the symbol is in the ansi common lisp, you should check teh clhs sly and slime has an excelent facility for that.
And normally I proceed as follow:
CL-USER> (documentation 'sb-ext:octets-to-string 'function)
NIL
CL-USER> (describe 'sb-ext:octets-to-string)
SB-EXT:OCTETS-TO-STRING
  [symbol]

OCTETS-TO-STRING names a compiled function:
  Lambda-list: (VECTOR &KEY (EXTERNAL-FORMAT DEFAULT) (START 0) END)
  Derived type: (FUNCTION
                 ((VECTOR (UNSIGNED-BYTE 8)) &KEY (:EXTERNAL-FORMAT T)
                  (:START T) (:END T))
                 *)
  Source file: SYS:SRC;CODE;OCTETS.LISP
; No values

The describe function always get you relevant info about the symbol, then you can go to teh source using sly or slime is with M-. 
(defun octets-to-string (vector &key (external-format :default) (start 0) end)
  (declare (type (vector (unsigned-byte 8)) vector))
  (with-array-data ((vector vector)
                    (start start)
                    (end end)
                    :check-fill-pointer t)
    (declare (type (simple-array (unsigned-byte 8) (*)) vector))
    (let ((ef (maybe-defaulted-external-format external-format)))
      (funcall (ef-octets-to-string-fun ef) vector start end))))

and finally you can go to teh repository for reading tests in this case going to the github SBCL repo and looking for this fucntion gives source code tests that you can read for getting an easy usage of the function:
https://github.com/sbcl/sbcl/search?utf8=%E2%9C%93&q=string-to-octets&type=
like this:
https://github.com/sbcl/sbcl/blob/622c9daf9bb41ef9ad4b8a063c62c4baf59a1c1a/tests/octets.pure.lisp 
","One option is to put (sb-ext:disable-debugger) early in your startup function. When an error occurs and there is no handler, SBCL will print an error and a backtrace and exit.
Another option is to write a function that does what you want on error and set it as your debugger hook; see command-line-debugger in buildapp itself for an example.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 SBCL:
* (apropos ""unexport"")

UNEXPORT (fbound)


* (documentation 'unexport 'function)

""Makes SYMBOLS no longer exported from PACKAGE.""


* (apropos ""unintern"")

UNINTERN (fbound)


* (documentation 'unintern 'function)

""Makes SYMBOL no longer present in PACKAGE. If SYMBOL was present then T is
returned, otherwise NIL. If PACKAGE is SYMBOL's home package, then it is made
uninterned.""

 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 This better formatting should make it easy to spot the error:
(defun f (l) 
  (cond ((null l) nil)
        ((listp (car l)) 
         (append (f (car l)))
         (f (cdr l)
            (car (f (car l)))))
        (t (list (car l)))))

If that does not help, use SBCL to compile the function. It will give you a very clear error message.
","Yes, there are other resources besides browsing through the external symbols of package SB-EXT. The SBCL repository contains a lot of information and documentation within its source code comments and tests. Additionally, you can refer to the SBCL Cookbook (https://www.sbcl.org/doc/Cookbook/index.html) which provides practical examples and solutions for common tasks. For more detailed documentation on specific functions like SB-EXT:STRING-TO-OCTETS and SB-EXT:OCTETS-TO-STRING, you might want to look at the SBCL source code itself or consult external resources such as the Quicklisp documentation or other Lisp programming books that cover SBCL.",0.5248,[[0.41214038]],0.014909913307043339,0.11529845829490051,0.29533678756476683,0.05729166666666667,0.1295336787564767
"I am trying to use the reduce function in a more complex way then what it is usually intended for. I’m not even sure if this is possible, but here’s what I’m trying to do:
Given a list (1 2 3) and two constants, let’s have them be 9 and 13, I’m trying to use reduce to end up with:
(+ 1 (* 9 (+ 2 (* 9 (+ 3 (* 9 13))))))
I tried a method where I added 13 to the back of then list, so I had (1 2 3 13) then tried doing some mapping with Lambda and reduce, but I can’t get the correct answer.
I would post my code that I’ve tried but my internet went out and I’m typing this on my phone, so sorry I can’t show what I tried to do, but the goal is the form of the expression above using reduce 
","The proposed operations can indeed be implemented as a reduce (a.k.a. foldr):
(+ 1 (* 9 (+ 2 (* 9 (+ 3 (* 9 13))))))
=> 9739

(reduce (lambda (e acc) (+ e (* 9 acc)))
        13
        '(1 2 3))
=> 9739

Regarding the constants, 13 is used only once in the innermost expression, so it's a good fit to be used as an initial value. 9 is used to multiply the accumulated value. The input list is used from right to left when the recursion starts to unwind, and at that point we add the current element to the accumulated result.
","Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
 If I understood correctly, you can combine reduce and append to flatten the list before returning it.  
Example:  
(reduce 'append '((1) (2) (3)))

Output:  
(1 2 3)

In your case this might work:
(reduce 'append (mapcar 'recursive-function L))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The proposed operations can indeed be implemented as a reduce (a.k.a. foldr):
(+ 1 (* 9 (+ 2 (* 9 (+ 3 (* 9 13))))))
=> 9739

(reduce (lambda (e acc) (+ e (* 9 acc)))
        13
        '(1 2 3))
=> 9739

Regarding the constants, 13 is used only once in the innermost expression, so it's a good fit to be used as an initial value. 9 is used to multiply the accumulated value. The input list is used from right to left when the recursion starts to unwind, and at that point we add the current element to the accumulated result.
 A solution that uses your initial approach is the following:
(defun max-occurrences(l)
  (let* ((occurrences (remove-duplicates 
                        (mapcar #'(lambda (elt) (cons elt (count elt l))) l) 
                        :test 'equal))
         (max-occurrence (reduce #'max occurrences :initial-value 0 :key #'cdr)))
    (mapcar #'car (remove-if-not (lambda(x) (= x max-occurrence)) occurrences :key #'cdr))))

However, this solution is not efficient, since it has a cost of O(n2) (in the initial phase, each element of the list is compared with all the others to count its frequency). 
Edited
A more efficient solution could be obtained for instance by using a hash table (with the improvement suggested in the comment by @uselpa):
(defun max-occurrences(l)
   (let* ((table (make-hash-table))
          (max-count (loop for elt in l maximize (incf (gethash elt table 0)))))
     (loop for elt being the hash-key of table using (hash-value count)
        when (= count max-count) collect elt)))

 Use the function EVERY instead.
(every #'identity '(t t t))  -> t

You can't apply special operators.
Next solution:
(reduce (lambda (a b) (and a b))
        '(t t t)
        :initial-value t)

Don't use APPLY for list operations. Use REDUCE.
","To achieve the desired result using `reduce`, you can define a lambda function that constructs the expression step by step. Here's how you can do it:\n\n```lisp\n(defun build-expression (constants list)\n  (reduce (lambda (acc elt) (+ acc (* (car constants) elt)))\n          (cdr list)\n          :initial-value (car list)))\n\n(build-expression '(9 13) '(1 2 3))\n```\n\nThis function will take a list of constants and another list, then use `reduce` to build the expression from right to left. The initial value is set as the first element of the constants list, and each subsequent element in the list multiplies with the accumulated result.\n\nFor your specific example, you would call `(build-expression '(9 13) '(1 2 3))`, which will yield `(+ 1 (* 9 (+ 2 (* 9 (+ 3 (* 9 13)))))).`",0.6354,[[0.47667633]],0.321662714474707,0.41923224134722276,0.4761904761904762,0.15720524017467247,0.2337662337662338
"I like Clojure. One thing that bothers me about the language is that I don't know how lazy sequences are implemented, or how they work.
I know that lazy sequences only evaluate the items in the sequence that are asked for. How does it do this?

What makes lazy sequences so efficient that they don't consume much
stack?
How come you can wrap recursive calls in a lazy sequence and no
longer get a stack over flow for large computations?
What resources do lazy sequences consume to do what it does?
In what scenarios are lazy sequences inefficient?
In what scenarios are lazy sequences most efficient?

","Let's do this.
• I know that lazy sequences only evaluate the items in the sequence that are asked for, how does it do this?
Lazy sequences (henceforth LS, because I am a LP, or Lazy Person) are composed of parts. The head, or the part(s, as really 32 elements are evaluated at a time, as of Clojure 1.1, and I think 1.2) of the sequence that have been evaluated, is followed by something called a thunk, which is basically a chunk of information (think of it as the rest of the your function that creates the sequence, unevaluated) waiting to be called. When it is called, the thunk evaluates however much is asked of it, and a new thunk is created, with context as necessary (how much has been called already, so it can resume from where it was before).
So you (take 10 (whole-numbers)) – assume whole-numbers is a lazy sequence of whole numbers. That means you're forcing evaluation of thunks 10 times (though internally this may be a little difference depending on optimizations.
• What makes lazy sequences so efficient that they don't consume much stack?
This becomes clearer once you read the previous answer (I hope): unless you call for something in particular, nothing is evaluated. When you call for something, each element of the sequence can be evaluated individually, then discarded.
If the sequence is not lazy, oftentimes it is holding onto its head, which consumes heap space. If it is lazy, it is computed, then discarded, as it is not required for subsequent computations.
• How come you can wrap recursive calls in a lazy sequence and no longer get a stack over flow for large computations?
See the previous answer and consider: the lazy-seq macro (from the documentation) will
will invoke the body only the first time seq
is called, and will cache the result and return it on all subsequent
seq calls.

Check out the filter function for a cool LS that uses recursion:
(defn filter
  ""Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.""
  [pred coll]
  (let [step (fn [p c]
                 (when-let [s (seq c)]
                   (if (p (first s))
                     (cons (first s) (filter p (rest s)))
                     (recur p (rest s)))))]
    (lazy-seq (step pred coll))))

• What resources do lazy sequences consume to do what it does?
I'm not quite sure what you're asking here. LSs require memory and CPU cycles. They just don't keep banging the stack, and filling it up with results of the computations required to get the sequence elements.
•  In what scenarios are lazy sequences inefficient?
When you're using small seqs that are fast to compute and won't be used much, making it an LS is inefficient because it requires another couple chars to create.
In all seriousness, unless you're trying to make something extremely performant, LSs are the way to go.
•  In what scenarios are lazy sequences most efficient?
When you're dealing with seqs that are huge and you're only using bits and pieces of them, that is when you get the most benefit from using them.
Really, it's pretty much always better to use LSs over non-LSs, in terms of convenience, ease of understanding (once you get the hang of them) and reasoning about your code, and speed.
","The loop/recur version is the right way.  Clojure cannot optimize tail calls due to limitations of the JVM. 
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 AutoLISP does not support multiple threads - programs are executed in 'series' using a single processor thread. As such, this is unfortunately not possible.
 You have three options:

Rewrite the algorithm to be tail-recursive or, equivalently, iterative
Change the algorithm all together
Increase the lisp's stack size

 The reason the ANSI CL standard does not specify the algorithmic complexity of 
library functions is that it is not its job. The standard describes the behavior, and leaves performance to the implementation-specific docs. 
It was assumed that the best theoretical performance will be provided by all implementations (otherwise no one would use it).
To answer your specific question, gethash is O(1) in all implementations.
 Repeated accumulative operation over a list is known as reduction:
(defun apply-values (DictValues Monomial)
   (reduce #'*
      (mapcar 
         (lambda (x)
            (expt (cdr (assoc (varpower-symbol x) DictValues))
                  (varpower-power x)))
         (varpowers Monomial))
      :initial-value (monomial-coefficient Monomial)))
    

Using a higher-order function that properly fits the situation allows for the functional style, without explicitly naming the interim values. The code is clearer and less prone to errors by a human coder.
","Lazy sequences in Clojure work by only evaluating elements that are actually needed. This is achieved through a combination of demand-driven evaluation and the use of a delay mechanism. When you create a lazy sequence, each element is not computed immediately but rather when it is demanded (i.e., accessed or iterated over). This means that if your sequence contains many elements, only those required for the current operation are evaluated.",0.5146,[[0.48870271]],0.00013980136336882204,0.05611672278338945,0.15552099533437014,0.03744149765990639,0.10264385692068428
"((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5)

For this code, the result is [5 4 3 2 1]
Why isn't is [1,2,3,4,5]?
I see we do conf from result of recursive foo call with a value.
For I thought it should be 1 2 3 4 5?
Need help to understand this.
Thanks.
","From the documentation of conj:

clojure.core/conj
  ([coll x] [coll x & xs])
    conj[oin]. Returns a new collection with the xs
      'added'. (conj nil item) returns (item).  The 'addition' may
      happen at different 'places' depending on the concrete type.

The termination condition of your function yields nil, because the test is a when. So the deepest conj call will be:
(conj nil 1)
(1) <-- a list

The next one:
(conj (conj nil 1) 2)
(2 1)

So your result will be in decreasing order because conj appends at the front for lists. If you want it in increasing order, start with an empty vector like this:
((fn foo [x] (if (> x 0) (conj (foo (dec x)) x) [])) 5)
[1 2 3 4 5]

","Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 I suggest you use (not (equal? foo bar)) if not equals works.  Please note that there may be faster comparators for your situiation such as eq?
 decode-json appears to return an association list (at least in this case; see documentation). You can access the values with the function assoc:
(defun test-json ()
  (with-input-from-string (s ""{\""foo\"": [1, 2, 3], \""bar\"": true, \""baz\"": \""!\""}"")
    (let ((data (json:decode-json s)))
      (format t ""~a~%"" (rest (assoc :foo data))))))

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
","The reason the result is [5 4 3 2 1] instead of [1 2 3 4 5] is because of how `conj` works in Clojure (and similar Lisps). When you call `(conj (foo (dec x)) x)`, it adds the current value of `x` to the beginning of the result list from the recursive call. This means that when the recursion unwinds, each element is prepended to the growing list. Therefore, the final list starts with 5 and ends with 1, which matches the order in which the numbers are decremented.",0.5738,[[0.48972087]],0.14409526619390312,0.2590553807895282,0.4205607476635514,0.10377358490566037,0.19626168224299062
"Sometimes we need to modify a place but here is no built-in function that meets our needs.
For instance, here are incf and decf for addition and subtraction:
CL-USER> (defvar *x* 5)
*X*
CL-USER> (incf *x* 3)
8
CL-USER> *x*
8
CL-USER> (decf *x* 10)
-2
CL-USER> *x*
-2

But how about multiplication and division? What if we wish to modify a place with arbitrary function, like this:
(xf (lambda (x) ...) *x*)

xf utility would be very useful, especially when we have to deal with deeply nested structures:
(my-accessor (aref (cdr *my-data*) n))

","Defining new macros with define-modify-macro
One simple way to define new handy macros for our needs is define-modify-macro. This is a handy macro which can create other macros for us.

Syntax:
define-modify-macro name lambda-list function [documentation]
⇒ name

We should supply name of new macro, list of parameters (not including place there) and symbol of function that will be used for processing.
Example of use:
(define-modify-macro togglef () not
  ""togglef modifies place, changing nil value to t and non-nil value to nil"")

(define-modify-macro mulf (&rest args) *
  ""mulf modifies place, assigning product to it"")

(define-modify-macro divf (&rest args) /
  ""divf modifies place, assigning result of division to it"")

However, define-modify-macro cannot be used for arbitrary processing. Here we have to take a look at other possibilities.
Function get-setf-expansion
Function get-setf-expansion does not create any macros, but provides information which we can use to write our own.

Syntax:
get-setf-expansion place &optional environment
⇒ vars, vals, store-vars, writer-form, reader-form

As you can see, it returns a bunch of values, so it may be confusing at first sight. Let's try it on example:
CL-USER> (defvar *array* #(1 2 3 4 5))
*ARRAY*
CL-USER> (get-setf-expansion '(aref *array* 1))
; get-setf-expansion is a function, so we have to quote its argument
(#:G6029 #:G6030)        ; list of variables needed to modify place
(*ARRAY* 1)              ; values for these variables
(#:G6031)                ; variable to store result of calculation
(SYSTEM::STORE #:G6029   ; writer-form: we should run it to modify place
               #:G6030   ; ^
               #:G6031)  ; ^  
(AREF #:G6029 #:G6030)   ; reader-form: hm.. looks like our expression

Writing xf macro
It seems like now we've got all information to write our xf macro:
(defmacro xf (fn place &rest args &environment env)
  (multiple-value-bind (vars forms var set access)
      (get-setf-expansion place env)
    (let ((g (gensym)))
      `(let* ((,g ,fn)   ; assign supplied function to generated symbol
              ,@(mapcar #'list vars forms) ; generate pairs (variable value)
              (,(car var) (funcall ,g ,access ,@args))) ; call supplied function
              ; and save the result, we use reader-form here to get intial value
         ,set)))) ; just put writer-from here as provided

Note, that xf macro takes evironment variable and pass it to get-setf-expansion. This variable is needed to ensure that any lexical bindings or definitions established in the compilation environment are taken into account.
Let's try it:
CL-USER> (defvar *var* '((""foo"" . ""bar"") (""baz"" . ""qux"")))
*VAR*
CL-USER> (xf #'reverse (cdr (second *var*)))
""xuq""
CL-USER> *var*
((""foo"" . ""bar"") (""baz"" . ""xuq""))

Expansion:
(LET* ((#:G6033 #'REVERSE)
       (#:TEMP-6032 (SECOND *VAR*))
       (#:NEW-6031 (FUNCALL #:G6033
                            (CDR #:TEMP-6032))))
  (SYSTEM::%RPLACD #:TEMP-6032 #:NEW-6031))

I hope this information is useful.
This answer is based on Paul Graham's On Lisp, section 12.4 More Complex Utilities.
","Here is a slightly simpler version:
CL-USER> (loop for x on '(1 3 5 7 9)
               nconc (loop for y in x collect (cons (car x) y)))

((1 . 1) (1 . 3) (1 . 5) (1 . 7) (1 . 9) (3 . 3) (3 . 5) (3 . 7) (3 . 9) (5 . 5) (5 . 7) (5 . 9) (7 . 7) (7 . 9) (9 . 9))

 CL-USER 68 > (let ((ans ()))
               (dolist (i mm (reverse ans))
                 (dolist (j mm)
                   (setq ans (cons (list (nth i mm)
                                         (nth j mm))
                                   ans)))))
((0 0) (0 1) (1 0) (1 1))

 See the CLISP implementation notes, section 20.3.2:
""If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")).""
 CL-USER> (mapcar #'caddr *jack*)
(FRUIT FRUIT AGENT AGENT)

EDIT: If you want to practise your recursive approach, try:
(defun attempt (list-of-lists)
    (if (null list-of-lists) nil
        (cons (third (car list-of-lists))
              (attempt (cdr list-of-lists)))))

EDIT2: Tail-recursively:
(defun attempt-tail (list-of-lists)
    (labels ((iter (rest ans)
               (if (null rest) (nreverse ans)
                   (iter (cdr rest) (push (third (car rest)) ans)))))
      (iter list-of-lists nil)))

EDIT3: While I'm at it, here's the loop version:
(loop for list in *jack* collect (third list))

 I ended up changing cl-actors slightly and adding a send-receive construct that does what I want in this situation. The modified code is here (comments encouraged). The core is this:
(defmethod send-receive ((self actor) message &optional (timeout 0))
  (let ((tmp (make-queue)))
    (send self tmp message)
    (car (dequeue tmp timeout))))

Essentially, we declare a temporary queue, send a message with that queue as a receiver, then try to pop a value off it with an optional timeout (0 means wait forever). This depends on the target actor accepting a sender parameter, which seems like a sufficiently actorsy way to go about it..
 Use the function STRING.
CL-USER > (string ""FOO"")
""FOO""

CL-USER > (string 'FOO)
""FOO""

","To create a utility function like `xf` that allows you to modify a place using an arbitrary function, you can define a macro or a function. Here's a simple example of how you might implement such a function in Common Lisp:\n\n```lisp\n(defun xf (function place &optional (test #'eql) (update nil update-p)\n  \",0.5439,[[0.2932877]],1.581814536921186e-05,0.039579844725224536,0.13584905660377358,0.01893939393939394,0.07169811320754717
"I would like to do the following pattern in scheme:
if N > 0:
    pass
else:
    do-function()

Currently I have it mocked up as something like this:
(if (> N 0) pass?? (do-function))

What's the proper way to do pass or continue or return or ; or whatever it is to 'do-nothing' in scheme, but keep it there as a placeholder so I know that it's intentional (rather than changing the if to if not N > 0 or if N<=0 etc.)
","You could just add a dummy expression of your liking,
(if (> n 0) '() (do-something))

or with sugar-coating,
(define pass '())
(if (> n 0) pass (do-something))

but there are constructs in both Common Lisp and Scheme that make the intention  clear without the clutter – unless and when:
(unless (> n 0) (do-something))
(when (<= n 0) (do-something))

If the branch isn't taken, the value is nil in Common Lisp, and unspecified (i.e. some implementation-dependent value) in Scheme.
","You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 The rule is that one-word predicate names end in just P, while multi-word predicate names end in -P.  The reason for the former is mostly historical; the reason for the latter is that a name like input-streamp would wrongly suggest that the question being asked is “is this input a stream?” or something like that.
 As mentioned in first comment it is necessarily to use (list a b c) form.
 The primary problem seems to be that you need to reset the file position after each pass.  The infinite loop happens because you never check for the file end (and suppressed the signal).
Side hint: use dolist instead of that dotimes and nth construction.
If you do not want to make n passes (n being the number of patches), and you cannot hold the entire contents in memory, you could write the patches to temporary files, then concatenate them in the desired order.  If you also do not have enough disk space, it becomes an in-place sort problem with varying element sizes, which is a bit more involved.
 The alternate expression for the 'if' expression is ((set! ...) ...).  The first position needs to be either a function or a syntactic form.  In this case you need progn as:
(progn
  (setq list1 ...)
  (setq list2 ...)
  (eql x y))

 I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.
In Scheme, the only false value is #f, and in particular, many ""side-effecting"" procedures return ""an unspecified value""¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.
¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns.
","In Scheme, you can use 'begin' with an empty list of expressions to represent a 'no-op' (do-nothing) operation. So your if statement would look like this:\n\n`(if (> N 0) (begin) (do-function))`\n\nAlternatively, you can simply use `;` to denote a comment or do-nothing part in the if expression:",0.5624,[[0.25951012]],0.10488969215170088,0.2247219816653948,0.3407407407407407,0.04511278195488722,0.19259259259259257
"Trying to pass a function and a list to a function.  Trying to compare each item in the list with the following item.
Function is:
(defun my-list-function(fn L)
    (if (< (length L) 2)
        (message ""List needs to be longer than 2"")
        (progn (setq newL L) ;; Save the list locally
               (while (> (length newL) 1)  ;; While list has 2 items
                      (setq t (car newL)) ;; Get first item
                      (setq newL (cdr newL)) ;; resave list minus first item
                      (funcall #'fn t #'car newL)))))  ;; pas first two items to a function

I keep getting an error - setting constant-t
","t is a reserved name (see 11.2 Variables that never change). Use instead of t a different variable name that tells what it contains/means (like for example firstItem).
","The call to LIST creates a new list each time it is evaluated.  The list literal might be placed in a read-only memory segment after compilation. A destructive update on the lists with NCONC is then problematic, possibly with undefined consequences (segmentation error, changing the literal for future references, or nothing at all).
 Append returns the concatenated list (queue1 with the first element of stack1 appended).  It does not modify queue1.
The destructive equivalent of append is nconc: this appends to the list ""in place.""
 This is a bug in the HyperSpec and Issue ADJOIN-SPECIFICATION has been written about it on the CLiki.  The relevant parts are:

Problem Description:
CLHS specifies ADJOIN behavior in presence of a :KEY argument by reference to Section 17.2.1 Satisfying a
  Two-Argument Test. This is incorrect, since section 17.2.1 specifies
  that the key function is NOT called on the ITEM parameter, but ADJOIN
  does, as is specified in pushnew. Proposal (ADJOIN:CLARIFICATION):
Replace:

The test, test-not, and key affect how it is determined whether item
    is the same as an element of list. For details, see Section 17.2.1
    (Satisfying a Two-Argument Test).

by:

Whether or not item is already a member of the list is determined by
    comparisons using :test or :test-not. The first argument to the :test
    or :test-not function is the result returned by the :key function (if
    supplied), applied to the item; the second argument is an element of
    the list as returned by the :key function (if supplied). If :key is
    supplied, it is used to extract the part to be tested from both item
    and the list element.

Rationale:
Clarification of the specification of ADJOIN.
Current practice:
All implementations implement ADJOIN as specified on pushnew, and not as specified on adjoin.

 Of course, it's pretty simple. I'm not giving a straight answer because this looks like homework and anyway it's trivial to write. Fill-in the blanks:
(define (length lst)
  (if <???>              ; if the list is empty
      <???>              ; return 0
      (<???>             ; otherwise add 1 and
       (length <???>)))) ; advance the recursion over the rest of the list

Notice that only cdr is used. We're not interested in the actual contents of the list, so we can ignore car.
 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 Change the initialization form for VAR to be an expression that creates new lists, such as (make-list 10 :initial-element 0) or even (list 0 0 0 0 0 0 0 0 0 0).
Basically, do not ever use quoted objects if you have intentions on modifying them, as the consequences are undefined if you do. In fact, evaluating  that function definition gives a warning about that:

; in: LAMBDA NIL
;     (INCF (NTH K VAR))
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:TMP5 #:TMP4 #:NEW3)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition

","The issue you're encountering with 'setting constant' likely stems from trying to modify a list that was passed as a quoted literal. In Lisp, quoted lists (like '(1 2 3)) are read-only and any attempt to modify them will result in an error or undefined behavior. To avoid this, ensure the list is not quoted when it's being modified within your function. Here’s how you can adjust your `my-list-function` to avoid modifying a constant list:",0.4882,[[0.04629655]],0.04256016328111754,0.2792553191489362,0.12612612612612611,0.0,0.07207207207207207
"How to import modules in Scheme (guile especially)?
How to create a module and import it in another script in scheme? How should I compile the script when I import a module, what are the command-line arguments that has to be passed? How to import the module if it is in another directory?
","Lets create a module test_module.scm with the following code in it and its location being /some/dir,
(define-module (test_module)
    #: export (square
               cube))

(define (square a)
    (* a a))
(define (cube a)
    (* a a a))

Here we have created a module using the syntax:
(define-module (name-of-the-module)
    #: export (function1-to-be-exported
               function2-to-be-exported))
;; rest of the code goes here for example: function1-to-be-exported

Now lets create a script that imports the module that we created named use_module.scm with this code in it, located in the current directory.
(use-modules (test_module))
(format #t ""~a\n"" (square 12))

Here we have used module using the syntax:
(use-modules (name-of-the-module))
;; now all the functions that were exported from the 
;; module will be available here for our use

Now lets come to the compiling part, we have to set GUILE_LOAD_PATH to the location /some/dir and then compile the script.
Now lets assume that both test_module.scm and use_module.scm are in the same directory, then do this:
$ GUILE_LOAD_PATH=. guile use_module.scm

but generally do this if the module is present in /some/dir:
$ GUILE_LOAD_PATH=/some/dir guile code.scm

p.s. The easier way to do this would be to write the script that uses add-to-load-path telling guile the location of the module. Now we can compile without worrying about the environment variables.
(add-to-load-path ""/some/dir"")
(use-modules (name-of-the-module))
;; rest of the code

","In Python you create an object by calling the constructor, a function that has the same name as the class. The exact same applies in Hy.
(import sys)
(import [PySide.QtGui [QApplication]])

(setf app (QApplication sys.argv))

Notes:

You assign the object created with setf
Be sure to import all the necessary modules

 Judging from the question, I think that you have a strange setup.  It seems to indicate that you are writing your functions directly at the REPL.  Don't do that.
The usual setup is to have an IDE (for example, Emacs with Slime) where you edit a source file, and then ""send"" top-level forms (like function definitions) to the REPL.
 Enclose your call to f in a module clause in a.rkt:
#lang racket
(provide f)
(define (f) 10)
(module+ main
  (f))

The forms in the module+ main part will only be executed when you run a.rkt directly, not when you require it.
For more info see here.
 From the user manual:

Scheme supports init files: an init file is a file containing Scheme code that is loaded when Scheme is started, immediately after the identification banner, and before the input prompt is printed. This file is stored in your home directory, which is normally specified by the HOME environment variable. Under unix, the file is called .scheme.init; on the PC it is called scheme.ini.

So, create an initiation file that loads your other files (Or put their contents in it; whatever you prefer).
 IIRC in Common Lisp at least defun is a macro (HyperSpec), meaning it may define any evaluation strategy whatsoever for its arguments.
 Since you're not quoting the arguments, it has to be a macro:
(defmacro clean (&rest symbols)
  `(progn
     ,@(mapcar (lambda (sym) (list 'setq sym 'nil))
               symbols)))

","In Scheme (Guile), creating and importing modules is similar to other Lisp dialects. You can create a module by defining functions or procedures within a file. For example, you might have a file named `my-module.scm` with the following content:\n\n```scheme\n(define (add x y) (+ x y))\n(define (subtract x y) (- x y))\n```\n\nTo import and use this module in another script, you can use the `use` or `require` form. Here is an example of how to do it:\n\n```scheme\n(use-modules (my-module))\n(display (add 5 3)) ; Output: 8\n(display (subtract 10 4)) ; Output: 6\n```\n\nAlternatively, if the module file is in a directory, you might need to add that directory to your load path. You can do this with `add-to-load-path` and then require the module:\n\n```scheme\n(use-modules (ice-9 popen))\n(add-to-load-path \",0.5949,[[0.44314911]],0.12392086747198913,0.20500798027884093,0.3507109004739336,0.11904761904761904,0.21327014218009477
"I'm currently trying to do exercise 1.22, which needs a function called runtime that returns the number of milliseconds the system has been running. However, my environment (R5RS) does not seem to have this. It does not have time, current-milliseconds, current-inexact-milliseconds, etc, either. 
What function do I have access to, to profile my function? Which functions returns the number of milliseconds, microseconds, etc, that have passed? I would of course prefer the highest precision timer available.
","Probably, the best thing to do is switch the language in DrRacket to ""Use the language declared in the source"", and start your file with #lang racket.  Then functions like current-seconds and friends will be available.
Alternatively, you could use the profiling library, available via (require profile) and documented here.  
Finally, you might want to look at Neil Van Dyke's SICP library for DrRacket.
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 AutoLISP does not support multiple threads - programs are executed in 'series' using a single processor thread. As such, this is unfortunately not possible.
 (caar '(6 4 2 3)) signals an error cause you are trying to do (car 6), and 6 is not a list.
Inside your function, you dont have (caar '(6 4 2 3)), but(caar '((6 4 2 3))).
Look how cdr works:
(cdr '((1 9 8 5) (6 4 2 3)))) => '((6 4 2 3)), not '(6 4 2 3)
So...
(caar '((6 4 2 3))) => 6, and (car '(6 4 2 3)) => 6
Do you see your mistake?
 The TIME macro is specified to “pass trough” the value of whatever it runs. In this way, it is like PRINT (i.e. you can wrap TIME or PRINT around anything without changing the internal dataflow—they do add stuff to the output though).  (time (foo)) returns whatever (foo) would return.
The specification provides no hard requirements as to what information is printed, that part is implementation specific.
Depending on your requirements, you might be better off looking for a profiling package (SBCL has a couple, I believe). Otherwise, you might like to look at GET-INTERNAL-RUN-TIME, GET-INTERNAL-REAL-TIME, and INTERNAL-TIME-UNITS-PER-SECOND.
 current-milliseconds is a function that returns the current millisecond count from the system, but it might decrease.  current-inexact-milliseconds is similar, but returns a guaranteed-to-increase floating point number.
There are also a bunch of similar functions that you can find on that page, but if all you need is to time a certain function, then just use (time expr) and it will print out the time it took to evaluate the expression.
Another thing that is relevant here is the profiler, in case you need some more verbose analysis of your code.
 The state is changed: the value referenced with the variable foo changes.
This is ""not functional"" in any pure sense. I might be tempted to call it ""confusing"" ;-)
Happy coding.
",Answer not found.,0.4113,[[0.]],2.2065146789969156e-12,0.014847809948032666,0.0,0.0,0.0
"As Rich Hickey says, the secret sauce of Lisp languages is the ability to directly manipulate the Abstract Syntax Tree through macros. Can this be achieved in any non-Lisp dialect languages?
","Being able to ""directly manipulate the abstract syntax tree"" by itself is nothing new, though it's something that very few languages have.  For example, many languages these days have some kind of an eval function -- but it should be obvious that that's not manipulating the abstract syntax tree, instead, it is a manipulation of the concrete syntax -- the direct source code.  Incidentally, the mentioned functionality in D falls under the same category, as is CPP: both deal with raw source text.
To give an example of a language that does have that feature (but not something that would be considered macros proper), see OCaml.  It has a syntactic extension system, CamlP4, which is essentially a compiler extension toolkit, and it revolves around the OCaml abstract syntax as its most important purpose.  But this is still not what makes the corresponding feature in Lisps so great.
The important feature of Lisps is that the extensions that you get using macros are part of the language in the same way that any other syntactic form is.  To put this differently, when you use something like if in a Lisp, there is no difference in functionality whether it's implemented as a macro or as a primitive form.  (Actually there is a minor difference: in some cases it's important to know the set of primitive forms that don't expand further.)  More specifically, a Lisp library can provide plain bindings and macros, which means that libraries can extend the language in a much more interesting way than the usual boring extensions you get in most languages, capable of adding only plain bindings (functions and values).
Now, viewed in this light, something like the D facility is very similar in nature.  But the fact that it deals with raw text rather than ASTs limit its utility.  If you look at the example on that page,
mixin(GenStruct!(""Foo"", ""bar""));

you can see how this doesn't look like part of the language -- to make it more like Lisp, you'd use it in a natural way:
GenStruct(Foo, bar);

with no need for a mixin keyword that marks where a macro is used, no need for that !, and the identifiers being specified as identifiers rather than strings.  Even better, the definition should be expressed more naturally, something like (inventing some bad syntax here):
template expression GenStruct(identifier Name, identifier M1) {
    return [[struct $Name$ { int $M1$; }; ]]
}

One important thing to note here is that since D is a statically typed language, ASTs have crept into this mental exercise in an explicit way -- as the identifier and expression types (I'm assuming here that template marks this as a macro definition, but it still needs a return type).
In Lisp, you're essentially getting something very close to this functionality, rather than the poor string solution.  But you get even more -- Lisp intentionally puns over the basic list type, and unifies the ASTs with the runtime language in a very simple way: the AST is made of symbols and lists and other basic literals (numbers, strings, booleans), and those are all part of the runtime language.  In fact, for those literals, Lisp takes another step forward, and uses the literals as their own syntax -- for example, the number 123 (a value that exists at runtime) is represented by a syntax which is also the number 123 (but now it's a value that exists at compile-time).  The bottom line of this is that macro-related code in Lisp tends to be far easier to deal with than what other languages call ""macro""s.  Imagine, for example, making the D example code create N int fields in a struct (where N is a new input to the macro) -- that would require using some function to translate a string into a number.
","One solution is python-on-lisp. It should be ASDF-installable. It hasn't been maintained or updated for a couple years, so there may be something better available.
 Lisp syntax seems to lend itself very nicely for a combined REPL-and-source-file approach.  It is much easier to move code snippets around programmatically when the textual limits of each form are clear.
 No.  Macros cannot change the lexical syntax of the language.  That requires read-macros, which Clojure doesn't have.
 Alternatives:

Just write it as a string.
use READ-CHAR, READ-LINE or READ-SEQUENCE
advanced: write and read using a custom reader macro

Btw., please post formatted Lisp code.
 Another simple way is to have Lisp running a HTTP server and contact Lisp from the outside via HTTP requests.
 The problem consists of two subproblems: parsing and symbolic manipulation. It seems to me the answer boils down to two possible solutions.
One is to implement everything from scratch: ""I do recommend creating the full expression tree if you want to retain maximum flexibility for handling tricky cases."" - proposed by Rex. As Sven points out: ""any of the high-level languages you listed are almost equally suited for the task,"" however ""Python (or any of the high-level languages you listed) won't take away the complexity of the problem.""
I have received very nice solutions in Scala (many thanks for Rex and Daniel), a nice little example in Python (from Sven). However, I am still interested in Lisp, Haskell or Erlang solutions.
The other solution is to use some existing library/software for the task, with all the implied pros and cons. Candidates are Maxima (Common Lisp), SymPy (Python, proposed by payne) and GiNaC (C++).
","As Rich Hickey mentions, the direct manipulation of the Abstract Syntax Tree (AST) through macros is a key feature of Lisp languages. This capability is not available in non-Lisp dialects due to their different syntactic structures and lack of macro systems. While some high-level languages like Python offer dynamic evaluation capabilities, they do not provide the same level of flexibility for AST manipulation as provided by Lisps. However, you can still achieve similar results in other languages by writing custom parsers and evaluators.",0.5226,[[0.39942305]],0.0002868577729754306,0.059094397544128936,0.1521438450899032,0.036061026352288486,0.08852005532503457
"So I have this simple expression to evaluate and list the two roots of a quadratic equation: 
(defun QUADRATIC (A B C) (list (/  (+  (- B) (sqrt(- (* B B) - (* 4 A C)))) (* 2 A)) (/  (- (- B) (sqrt(- (* B B) - (* 4 A C)))) (* 2 A))))

But when I evaluate it in CLISP with any three numbers for parameters, say
(quadratic 2 2 2)

I get the following error: (quadratic 2 2 2) is not a number
I am sure there is an easy fix but I can't figure it out!
","There is a syntactic error in your definition (and using an editor that format properly the code help in finding this kind of errors). 
The correct definition is:
 (defun quadratic (A B C) 
    (list (/  (+ (- B) (sqrt(- (* B B) (* 4 A C)))) 
              (* 2 A)) 
          (/  (- (- B) (sqrt(- (* B B) (* 4 A C)))) 
              (* 2 A))))

while you have an extra - in the sqrt call: (sqrt(- (* B B) - (* 4 A C)))) (* 2 A)) (the second -). 
The reason for the particular error message is that - used not in function position is a special variable that refer to the current form (see the specification).
","Easiest way I can think of off the top of my head is to simply convert 2^n to binary and count down, then convert the output to a list.
ie for n=3:
Truth table:
a b c
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1

2^3 = 8, 8 in binary = 1000, start from 1000-1 = 111 and work your way down to 0, record outputs, and voila!
 You have several errors. You're not quoting the list, so it's trying to call the string ""list foo"" as a function. Then you're calling message with the wrong type of argument.
(setq myHash (make-hash-table :test 'equal))
(puthash ""5"" '(""list foo"" ""baa"" ""baz"") myHash)
(message ""%S"" (gethash ""5"" myHash))

 Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
 You are calling with-output-to-file incorrectly.
The second argument is a thunk, and not a procedure expecting a port argument.
So call it like:
(with-output-to-file ""biophilia.c""
  (lambda ()
    (write ""Hello"")))

with-output-to-file already does the re-binding of the current-port for you (as you tried in your reconstruction).
See the Racket docs for it here.
 I fail to see why this would be called a reverse ASSOC.
(assoc '(0 2) dist :test #'equal)
> ((0 2) 3)

It looks like ASSOC works fine, provided you change the test function, so that lists used as keys are correctly tested.
","The issue with your function definition lies in the calculation inside the square root. The expression `(* B B)` is correct, but `- (* 4 A C)` should be `(- (* 4 A C))` to ensure proper negation. Additionally, the entire argument of the square root needs to be non-negative for real roots to exist. Here's the corrected function:\n\n```lisp\n(defun QUADRATIC (A B C) (let ((discriminant (- (* B B) (* 4 A C)))) (if (< discriminant 0) \",0.6105,[[0.40453643]],0.21035303440441486,0.24950125669962925,0.39306358381502887,0.17543859649122806,0.20809248554913296
"Lets say I have two variables and I want to set the variable with lower value to nil.
Is it possible to make it work this way?
(setf a1 5)
(setf a2 6)  
(setf
  (if (< a1 a2) a1 a2)
  nil
)

","If you want to do something close to this, you can use (setf (symbol-value var) ...):
> (defparameter a1 5)
> (defparameter a2 6)
> (setf (symbol-value (if (< a1 a2) 'a1 'a2)) nil)
> a1
nil
> a2
6

To get a syntax closer to the one in your question, you can define an setf-expanderfor if:
(defsetf if (cond then else) (value)
     `(progn (setf (symbol-value (if ,cond ,then ,else)) ,value)
              ,value))

Then you can write (setf (if (< a1 a2) 'a1 'a2) nil)
However, the best way of writing the code is probably to do it straight forward, using an if with setf forms in both branches:
(if (< a1 a2) 
    (setf a1 nil)
    (setf a2 nil))

","Yes!  It's called the splat operator.
a = [1, 44]
p(*a)

 The question is very subtle, and in the first moment I thought that the call would cause an infinte loop. But the real affair is the following:
Let's start calling F1 and F2 the two functions passed to A the first time, that is
F1 = (lambda() 1)
F2 = (lambda() -1)

So, after the first call of (A 2 F1 F2), A establishes the following environment, that we will name E1:

The test is now false, so A calls B1. B1 first decrements k in E1, then calls again A, passing 1, itself, and x1, which is F1. So this is the call with parameters substituted with their values: (A 1 B1 F1). And the new environment established by this call (E2) is shown in the following picture:

The test is still false, so A calls B2, which first modifies k in E2, then calls A with 0, itself, and x1 (which now is B1). So the call is (A 0 B2 B1), and the new set of environments is now:

The test is now true, so A call x2, which is B1. Now B1 modifies k in its environment (which is E1), and then calls A with 0, itself, and the value of x1, which, in E1, is F1. So the call is (A 0 B1 F1) and the environment established by this call is depicted in the next figure:

And finally, after checking that the test is true, A calls x2, that is F1, which returns 1. At last! 
 the listp tells you that :
(listp (elt '(a (b c) d) 1))

 You've got it almost right. However, you're terminating your list with 0, when the correct termination is nil. This code works:
(defun vecmul (list list2)
  (cond ((null list) nil)
     (t (cons (* (car list) (car list2)) (vecmul (cdr list) (cdr list2))))))

When you call (cons 1 2), the cons cell you get is written (1 . 2). the notation (1 2 3 4 5) is just shorthand for (1 . (2 . (3 . (4 . (5 . nil))))). If the cdr of the last cons cell is 6, not nil, then you get (1 . (2 . (3 . (4 . (5 . 6))))), which shortens to (1 2 3 4 5 . 6).
 use
(- b)

to negate b. It is equivalent to
(- 0 b)

 You could use append, but beware that it can lead to bad performance if used in a loop or on very long lists.
(append '(1 2 3) (list (+ 2 2)))

If performance is important, the usual idiom is building lists by prepending (using cons), then reverse (or nreverse).
","Yes, it is possible to achieve this using the setf function with multiple values. However, your syntax needs a slight adjustment. You can use the following approach:\n\n(setf (if (< a1 a2) a1 a2) nil)\n\nThis will effectively set the variable that has the lower value to nil.",0.6004,[[0.52088957]],0.05035868591560172,0.14025007061648187,0.34355828220858897,0.09937888198757763,0.2331288343558282
"From reading introductory material on Lisp, I now consider the following to be identical:
(list 1 2 3)

'(1 2 3)

However, judging from problems I face when using the quoted form in both Clojure and Emacs Lisp, they are not the same. Can you tell me what the difference is?
","By numbers do you mean the strings?
var_dump(array_values($your_array));

","You are comparing a list containing 1 & 2 with a list containing the symbols a & b. Symbols are legitimate values in Clojure. '(a b) is equivalent to (list 'a 'b) not (list a b).
 (= '(1 2) (list a b))

Is probably the comparison you want.
 All the functions from the CLHS chapters conses and sequences apply to lists.
Also note that it is good programming style (for various reasons) to name global variables like this: *bc*, *fc* and *gap*.
Also note that in newer code one often uses FIRST instead of CAR and REST instead of CDR.
 
Am I misunderstanding how substitute-if works or misunderstanding the representation of the list?

Probably the latter.
#1=... marks a spot in the data structure and #1# refers back to it. The idea is to show that both elements refer to the same list. (See also http://www.lispworks.com/documentation/HyperSpec/Body/02_dhp.htm.)
It's like:
(let ((x '(0)))
  (list '(1) x '(3) x))

Because they refer to the same object, if you were to modify the second list in place, the modification would also show up in the fourth list.
 They are the same, since one gets expanded into the other.  The first expression is easier to both write & read; having it expand into the second simplifies the interpreter (something you should appreciate).
 Oh, I see it now. Each of the functions is evaluated with the same argument and saved for comparison, i.e. juxtaposition.
From the documentation:
((juxt a b c) x) => [(a x) (b x) (c x)]

 What you demonstrate seems to be the question how to get the elements of a list as multiple values:
CL-USER> (values 1 2 3)
1
2
3
CL-USER> (apply #'values '(1 2 3))
1
2
3

See also multiple-value-bind and nth-value in the hyperspec.
","In Lisp dialects like Common Lisp, Scheme, Clojure, and Emacs Lisp, both `(list 1 2 3)` and `'(1 2 3)` can appear similar, but they have different meanings:

- `'(1 2 3)` is a quoted list. The quote (') prevents the forms inside from being evaluated immediately. This means that `'(1 2 3)` literally represents a list containing three elements: the integer `1`, the integer `2`, and the integer `3`.

- `(list 1 2 3)`, on the other hand, is a function call to `list` with arguments `1`, `2`, and `3`. The function `list` evaluates its arguments and constructs a list from their values. In this case, it will also create a list containing three elements: the integer `1`, the integer `2`, and the integer `3`.

The key difference is that `(list 1 2 3)` involves evaluation of its arguments before constructing the list, while `'(1 2 3)` simply represents the literal form without immediate evaluation.

In Clojure, symbols like `a` and `b` are not automatically quoted. If you want to create a quoted list with symbols, you need to use single quotes: `(list 'a 'b)`. This is equivalent to `'('a 'b)`, which is a list containing the symbols `a` and `b`.

Understanding this distinction can help avoid common pitfalls when working with lists in Lisp-like languages.",0.4093,[[0.10790239]],0.0057790998692591015,0.12432231356256815,0.03508771929824561,0.0,0.02631578947368421
